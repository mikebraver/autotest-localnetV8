{
  "swagger": "2.0",
  "info": {
    "title": "Exocore - gRPC Gateway docs",
    "description": "A REST interface for state queries and transactions",
    "version": "1.0.0"
  },
  "paths": {
    "/exocore/epochs/v1/current_epoch/{identifier}": {
      "get": {
        "summary": "CurrentEpoch provide the current epoch for the specified identifier.",
        "operationId": "CurrentEpoch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "current_epoch": {
                  "type": "string",
                  "format": "int64",
                  "title": "current_epoch is the number of the current epoch"
                }
              },
              "description": "QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "identifier",
            "description": "identifier of the epoch for which the current number is requested.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/epochs/v1/epochs": {
      "get": {
        "summary": "EpochInfos provide a list of currently running epochs.",
        "operationId": "EpochInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "epochs": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "identifier": {
                        "type": "string",
                        "description": "identifier is the unique identifier of the epoch, typically, the measure\nof time used to define the epoch."
                      },
                      "start_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "start_time of the epoch. it may be in the future, in which case, the epoch\nis not yet active."
                      },
                      "duration": {
                        "type": "string",
                        "description": "duration is the time in between epoch i and epoch i+1. for an epoch to\nbe meaningful, the duration should be more than the block time of the chain."
                      },
                      "current_epoch": {
                        "type": "string",
                        "format": "int64",
                        "description": "current_epoch is the number of the currently ongoing epoch, identified by the\nidentifier. the first epoch starts during the first block whose block time\nis greater than or equal to the start_time of the epoch."
                      },
                      "current_epoch_start_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "current_epoch_start_time is the start time of the current time interval, which\nis (current_epoch_start_time, current_epoch_start_time + duration]. when we say\nthat the timer has \"ticked\", it means that the interval's components are increased\nby the duration. note, however, that only one tick can occur in any given block.\n\nthe above constraint results in a deviation from the \"ideal\" tick time / the wall\nclock time. this is particularly obvious when a chain goes down.\nsay, at t = 13, the interval is (10, 10 + 5 = 15].\nat t = 14, it is unchanged even in a new block, since 10 < t <= 15\nat t = 15, it is unchanged even in a new block, since 10 < t <= 15\nat t = 16, it increases to (15, 20]. but then assume that the chain goes down\nand comes back up at t = 35, producing 1 block each second after that as well.\nat t = 35, the interval increases by 1 tick to (15, 20] (at the block end).\nat t = 36, it increases to (20, 25].\nat t = 37, it increases to (25, 30].\nat t = 38, it increases to (30, 35].\nat t = 39, it increases to (35, 40].\nat t = 40, it is unchanged even in a new block, since 35 < t <= 40.\nat t = 41, it increases to (40, 45]."
                      },
                      "epoch_counting_started": {
                        "type": "boolean",
                        "description": "epoch_counting_started is true if the epoch counting has started for this identifier.\nit is independent of the epoch number or the time; it just indicates that at least\none epoch for this identifier has started counting."
                      },
                      "current_epoch_start_height": {
                        "type": "string",
                        "format": "int64",
                        "description": "current_epoch_start_height is the block height at which the current epoch started,\nor the height at which the timer last \"ticked\"."
                      }
                    },
                    "description": "EpochInfo defines an epoch and its metadata. An epoch is a period of time\nthat is used to define a time frame for a system."
                  },
                  "description": "epochs is a slice of all EpochInfos returned by the query."
                },
                "block_time": {
                  "type": "string",
                  "format": "date-time",
                  "description": "block_time is the block time of the query block ctx."
                },
                "pagination": {
                  "description": "pagination defines the pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/params": {
      "get": {
        "summary": "Params retrieves the erc20 module params",
        "operationId": "ERC20Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "title": "params are the erc20 module parameters",
                  "type": "object",
                  "properties": {
                    "enable_erc20": {
                      "type": "boolean",
                      "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
                    },
                    "enable_evm_hook": {
                      "type": "boolean",
                      "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/token_pairs": {
      "get": {
        "summary": "TokenPairs retrieves registered token pairs",
        "operationId": "TokenPairs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "token_pairs": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "erc20_address": {
                        "type": "string",
                        "title": "erc20_address is the hex address of ERC20 contract token"
                      },
                      "denom": {
                        "type": "string",
                        "title": "denom defines the cosmos base denomination to be mapped to"
                      },
                      "enabled": {
                        "type": "boolean",
                        "title": "enabled defines the token mapping enable status"
                      },
                      "contract_owner": {
                        "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                        "type": "string",
                        "enum": [
                          "OWNER_UNSPECIFIED",
                          "OWNER_MODULE",
                          "OWNER_EXTERNAL"
                        ],
                        "default": "OWNER_UNSPECIFIED",
                        "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
                      }
                    },
                    "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
                  },
                  "title": "token_pairs is a slice of registered token pairs for the erc20 module"
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/erc20/v1/token_pairs/{token}": {
      "get": {
        "summary": "TokenPair retrieves a registered token pair",
        "operationId": "TokenPair",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "token_pair": {
                  "type": "object",
                  "properties": {
                    "erc20_address": {
                      "type": "string",
                      "title": "erc20_address is the hex address of ERC20 contract token"
                    },
                    "denom": {
                      "type": "string",
                      "title": "denom defines the cosmos base denomination to be mapped to"
                    },
                    "enabled": {
                      "type": "boolean",
                      "title": "enabled defines the token mapping enable status"
                    },
                    "contract_owner": {
                      "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                      "type": "string",
                      "enum": [
                        "OWNER_UNSPECIFIED",
                        "OWNER_MODULE",
                        "OWNER_EXTERNAL"
                      ],
                      "default": "OWNER_UNSPECIFIED",
                      "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
                    }
                  },
                  "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address.",
                  "title": "token_pairs returns the info about a registered token pair for the erc20 module"
                }
              },
              "description": "QueryTokenPairResponse is the response type for the Query/TokenPair RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "token",
            "description": "token identifier can be either the hex contract address of the ERC20 or the\nCosmos base denomination",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/account/{address}": {
      "get": {
        "summary": "Account queries an Ethereum account.",
        "operationId": "Account",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "string",
                  "description": "balance is the balance of the EVM denomination."
                },
                "code_hash": {
                  "type": "string",
                  "description": "code_hash is the hex-formatted code bytes from the EOA."
                },
                "nonce": {
                  "type": "string",
                  "format": "uint64",
                  "description": "nonce is the account's sequence number."
                }
              },
              "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/balances/{address}": {
      "get": {
        "summary": "Balance queries the balance of a the EVM denomination for a single\nEthAccount.",
        "operationId": "Balance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "string",
                  "description": "balance is the balance of the EVM denomination."
                }
              },
              "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the balance for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/base_fee": {
      "get": {
        "summary": "BaseFee queries the base fee of the parent block of the current block,\nit's similar to feemarket module's method, but also checks london hardfork status.",
        "operationId": "BaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "base_fee": {
                  "type": "string",
                  "title": "base_fee is the EIP1559 base fee"
                }
              },
              "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/codes/{address}": {
      "get": {
        "summary": "Code queries the balance of all coins for a single account.",
        "operationId": "Code",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "code": {
                  "type": "string",
                  "format": "byte",
                  "description": "code represents the code bytes from an ethereum address."
                }
              },
              "description": "QueryCodeResponse is the response type for the Query/Code RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the code for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/cosmos_account/{address}": {
      "get": {
        "summary": "CosmosAccount queries an Ethereum account's Cosmos Address.",
        "operationId": "CosmosAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "cosmos_address": {
                  "type": "string",
                  "description": "cosmos_address is the cosmos address of the account."
                },
                "sequence": {
                  "type": "string",
                  "format": "uint64",
                  "description": "sequence is the account's sequence number."
                },
                "account_number": {
                  "type": "string",
                  "format": "uint64",
                  "title": "account_number is the account number"
                }
              },
              "description": "QueryCosmosAccountResponse is the response type for the Query/CosmosAccount\nRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/estimate_gas": {
      "get": {
        "summary": "EstimateGas implements the `eth_estimateGas` rpc api",
        "operationId": "EstimateGas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "gas": {
                  "type": "string",
                  "format": "uint64",
                  "title": "gas returns the estimated gas"
                }
              },
              "title": "EstimateGasResponse defines EstimateGas response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "args",
            "description": "args uses the same json format as the json rpc api.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "gas_cap",
            "description": "gas_cap defines the default gas cap to be used.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "proposer_address",
            "description": "proposer_address of the requested block in hex format.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chain_id",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/eth_call": {
      "get": {
        "summary": "EthCall implements the `eth_call` rpc api",
        "operationId": "EthCall",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "title": "hash of the ethereum transaction in hex format. This hash differs from the\nTendermint sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference"
                },
                "logs": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "title": "address of the contract that generated the event"
                      },
                      "topics": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "description": "topics is a list of topics provided by the contract."
                      },
                      "data": {
                        "type": "string",
                        "format": "byte",
                        "title": "data which is supplied by the contract, usually ABI-encoded"
                      },
                      "block_number": {
                        "type": "string",
                        "format": "uint64",
                        "title": "block_number of the block in which the transaction was included"
                      },
                      "tx_hash": {
                        "type": "string",
                        "title": "tx_hash is the transaction hash"
                      },
                      "tx_index": {
                        "type": "string",
                        "format": "uint64",
                        "title": "tx_index of the transaction in the block"
                      },
                      "block_hash": {
                        "type": "string",
                        "title": "block_hash of the block in which the transaction was included"
                      },
                      "index": {
                        "type": "string",
                        "format": "uint64",
                        "title": "index of the log in the block"
                      },
                      "removed": {
                        "type": "boolean",
                        "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
                      }
                    },
                    "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
                  },
                  "description": "logs contains the transaction hash and the proto-compatible ethereum\nlogs."
                },
                "ret": {
                  "type": "string",
                  "format": "byte",
                  "title": "ret is the returned data from evm function (result or data supplied with revert\nopcode)"
                },
                "vm_error": {
                  "type": "string",
                  "title": "vm_error is the error returned by vm execution"
                },
                "gas_used": {
                  "type": "string",
                  "format": "uint64",
                  "title": "gas_used specifies how much gas was consumed by the transaction"
                }
              },
              "description": "MsgEthereumTxResponse defines the Msg/EthereumTx response type."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "args",
            "description": "args uses the same json format as the json rpc api.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "gas_cap",
            "description": "gas_cap defines the default gas cap to be used.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "proposer_address",
            "description": "proposer_address of the requested block in hex format.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chain_id",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/evm module.",
        "operationId": "EvmParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params define the evm module parameters.",
                  "type": "object",
                  "properties": {
                    "evm_denom": {
                      "type": "string",
                      "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
                    },
                    "enable_create": {
                      "type": "boolean",
                      "title": "enable_create toggles state transitions that use the vm.Create function"
                    },
                    "enable_call": {
                      "type": "boolean",
                      "title": "enable_call toggles state transitions that use the vm.Call function"
                    },
                    "extra_eips": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "int64"
                      },
                      "title": "extra_eips defines the additional EIPs for the vm.Config"
                    },
                    "chain_config": {
                      "title": "chain_config defines the EVM chain configuration parameters",
                      "type": "object",
                      "properties": {
                        "homestead_block": {
                          "type": "string",
                          "title": "homestead_block switch (nil no fork, 0 = already homestead)"
                        },
                        "dao_fork_block": {
                          "type": "string",
                          "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
                        },
                        "dao_fork_support": {
                          "type": "boolean",
                          "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork"
                        },
                        "eip150_block": {
                          "type": "string",
                          "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
                        },
                        "eip150_hash": {
                          "type": "string",
                          "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)"
                        },
                        "eip155_block": {
                          "type": "string",
                          "title": "eip155_block: EIP155Block HF block"
                        },
                        "eip158_block": {
                          "type": "string",
                          "title": "eip158_block: EIP158 HF block"
                        },
                        "byzantium_block": {
                          "type": "string",
                          "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)"
                        },
                        "constantinople_block": {
                          "type": "string",
                          "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)"
                        },
                        "petersburg_block": {
                          "type": "string",
                          "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
                        },
                        "istanbul_block": {
                          "type": "string",
                          "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)"
                        },
                        "muir_glacier_block": {
                          "type": "string",
                          "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)"
                        },
                        "berlin_block": {
                          "type": "string",
                          "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
                        },
                        "london_block": {
                          "type": "string",
                          "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
                        },
                        "arrow_glacier_block": {
                          "type": "string",
                          "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)"
                        },
                        "gray_glacier_block": {
                          "type": "string",
                          "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)"
                        },
                        "merge_netsplit_block": {
                          "type": "string",
                          "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter"
                        },
                        "shanghai_block": {
                          "type": "string",
                          "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
                        },
                        "cancun_block": {
                          "type": "string",
                          "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
                        }
                      },
                      "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
                    },
                    "allow_unprotected_txs": {
                      "type": "boolean",
                      "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
                    },
                    "active_precompiles": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active"
                    }
                  },
                  "title": "Params defines the EVM module parameters"
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/storage/{address}/{key}": {
      "get": {
        "summary": "Storage queries the balance of all coins for a single account.",
        "operationId": "Storage",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "value": {
                  "type": "string",
                  "description": "value defines the storage state value hash associated with the given key."
                }
              },
              "description": "QueryStorageResponse is the response type for the Query/Storage RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the ethereum hex address to query the storage state for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "key",
            "description": "key defines the key of the storage state",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/trace_block": {
      "get": {
        "summary": "TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api",
        "operationId": "TraceBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "data": {
                  "type": "string",
                  "format": "byte",
                  "title": "data is the response serialized in bytes"
                }
              },
              "title": "QueryTraceBlockResponse defines TraceBlock response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "trace_config.tracer",
            "description": "tracer is a custom javascript tracer.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.timeout",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.reexec",
            "description": "reexec defines the number of blocks the tracer is willing to go back.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "trace_config.disable_stack",
            "description": "disable_stack switches stack capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.disable_storage",
            "description": "disable_storage switches storage capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.debug",
            "description": "debug can be used to print output during capture end.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.limit",
            "description": "limit defines the maximum length of output, but zero means unlimited.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "trace_config.overrides.homestead_block",
            "description": "homestead_block switch (nil no fork, 0 = already homestead).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.dao_fork_block",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.dao_fork_support",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.overrides.eip150_block",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip150_hash",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip155_block",
            "description": "eip155_block: EIP155Block HF block.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip158_block",
            "description": "eip158_block: EIP158 HF block.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.byzantium_block",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.constantinople_block",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.petersburg_block",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.istanbul_block",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.muir_glacier_block",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.berlin_block",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.london_block",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.arrow_glacier_block",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.gray_glacier_block",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.merge_netsplit_block",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.shanghai_block",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.cancun_block",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.enable_memory",
            "description": "enable_memory switches memory capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.enable_return_data",
            "description": "enable_return_data switches the capture of return data.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.tracer_json_config",
            "description": "tracer_json_config configures the tracer using a JSON string.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "block_number",
            "description": "block_number of the traced block.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "block_hash",
            "description": "block_hash (hex) of the traced block.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "block_time",
            "description": "block_time of the traced block.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "proposer_address",
            "description": "proposer_address is the address of the requested block.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chain_id",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "block_max_gas",
            "description": "block_max_gas of the traced block.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/trace_tx": {
      "get": {
        "summary": "TraceTx implements the `debug_traceTransaction` rpc api",
        "operationId": "TraceTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "data": {
                  "type": "string",
                  "format": "byte",
                  "title": "data is the response serialized in bytes"
                }
              },
              "title": "QueryTraceTxResponse defines TraceTx response"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "msg.data.type_url",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg.data.value",
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "msg.size",
            "description": "size is the encoded storage size of the transaction (DEPRECATED).",
            "in": "query",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "msg.hash",
            "description": "hash of the transaction in hex format.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg.from",
            "description": "from is the ethereum signer address in hex format. This address value is checked\nagainst the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.tracer",
            "description": "tracer is a custom javascript tracer.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.timeout",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.reexec",
            "description": "reexec defines the number of blocks the tracer is willing to go back.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "trace_config.disable_stack",
            "description": "disable_stack switches stack capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.disable_storage",
            "description": "disable_storage switches storage capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.debug",
            "description": "debug can be used to print output during capture end.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.limit",
            "description": "limit defines the maximum length of output, but zero means unlimited.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "trace_config.overrides.homestead_block",
            "description": "homestead_block switch (nil no fork, 0 = already homestead).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.dao_fork_block",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.dao_fork_support",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.overrides.eip150_block",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip150_hash",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip155_block",
            "description": "eip155_block: EIP155Block HF block.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.eip158_block",
            "description": "eip158_block: EIP158 HF block.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.byzantium_block",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.constantinople_block",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.petersburg_block",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.istanbul_block",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.muir_glacier_block",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.berlin_block",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.london_block",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.arrow_glacier_block",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.gray_glacier_block",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.merge_netsplit_block",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.shanghai_block",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.overrides.cancun_block",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun).",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "trace_config.enable_memory",
            "description": "enable_memory switches memory capture.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.enable_return_data",
            "description": "enable_return_data switches the capture of return data.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "trace_config.tracer_json_config",
            "description": "tracer_json_config configures the tracer using a JSON string.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "block_number",
            "description": "block_number of requested transaction.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "block_hash",
            "description": "block_hash of requested transaction.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "block_time",
            "description": "block_time of requested transaction.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "proposer_address",
            "description": "proposer_address is the proposer of the requested block.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "chain_id",
            "description": "chain_id is the the eip155 chain id parsed from the requested block header.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "block_max_gas",
            "description": "block_max_gas of the block of the requested transaction.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/evm/v1/validator_account/{cons_address}": {
      "get": {
        "summary": "ValidatorAccount queries an Ethereum account's from a validator consensus\nAddress.",
        "operationId": "ValidatorAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account_address": {
                  "type": "string",
                  "description": "account_address is the cosmos address of the account in bech32 format."
                },
                "sequence": {
                  "type": "string",
                  "format": "uint64",
                  "description": "sequence is the account's sequence number."
                },
                "account_number": {
                  "type": "string",
                  "format": "uint64",
                  "title": "account_number is the account number"
                }
              },
              "description": "QueryValidatorAccountResponse is the response type for the\nQuery/ValidatorAccount RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "cons_address",
            "description": "cons_address is the validator cons address to query the account for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/base_fee": {
      "get": {
        "summary": "BaseFee queries the base fee of the parent block of the current block.",
        "operationId": "FeeMarketBaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "base_fee": {
                  "type": "string",
                  "title": "base_fee is the EIP1559 base fee"
                }
              },
              "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/block_gas": {
      "get": {
        "summary": "BlockGas queries the gas used at a given block height",
        "operationId": "BlockGas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "gas": {
                  "type": "string",
                  "format": "int64",
                  "title": "gas is the returned block gas"
                }
              },
              "description": "QueryBlockGasResponse returns block gas used for a given height."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/evmos/feemarket/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/feemarket module.",
        "operationId": "FeeMarketParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params define the evm module parameters.",
                  "type": "object",
                  "properties": {
                    "no_base_fee": {
                      "type": "boolean",
                      "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)"
                    },
                    "base_fee_change_denominator": {
                      "type": "integer",
                      "format": "int64",
                      "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks."
                    },
                    "elasticity_multiplier": {
                      "type": "integer",
                      "format": "int64",
                      "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave."
                    },
                    "enable_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "enable_height defines at which block height the base fee calculation is enabled."
                    },
                    "base_fee": {
                      "type": "string",
                      "description": "base_fee for EIP-1559 blocks."
                    },
                    "min_gas_price": {
                      "type": "string",
                      "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions"
                    },
                    "min_gas_multiplier": {
                      "type": "string",
                      "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit"
                    }
                  },
                  "title": "Params defines the EVM module parameters"
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address": {
      "get": {
        "summary": "EscrowAddress returns the escrow address for a particular port and channel id.",
        "operationId": "EscrowAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "escrow_address": {
                  "type": "string",
                  "title": "the escrow account address"
                }
              },
              "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "unique channel identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "unique port identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denom_hashes/{trace}": {
      "get": {
        "summary": "DenomHash queries a denomination hash information.",
        "operationId": "DenomHash",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "description": "hash (in hex format) of the denomination trace information."
                }
              },
              "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "trace",
            "description": "The denomination trace ([port_id]/[channel_id])+/[denom]",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces": {
      "get": {
        "summary": "DenomTraces queries all denomination traces.",
        "operationId": "DenomTraces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_traces": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "path": {
                        "type": "string",
                        "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                      },
                      "base_denom": {
                        "type": "string",
                        "description": "base denomination of the relayed fungible token."
                      }
                    },
                    "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                  },
                  "description": "denom_traces returns all denominations trace information."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denom_traces/{hash}": {
      "get": {
        "summary": "DenomTrace queries a denomination trace information.",
        "operationId": "DenomTrace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_trace": {
                  "type": "object",
                  "properties": {
                    "path": {
                      "type": "string",
                      "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                    },
                    "base_denom": {
                      "type": "string",
                      "description": "base denomination of the relayed fungible token."
                    }
                  },
                  "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                }
              },
              "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/denoms/{denom}/total_escrow": {
      "get": {
        "summary": "TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.",
        "operationId": "TotalEscrowForDenom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/transfer/v1/params": {
      "get": {
        "summary": "Params queries all parameters of the ibc-transfer module.",
        "operationId": "TransferParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "boolean",
                      "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
                    },
                    "receive_enabled": {
                      "type": "boolean",
                      "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_states": {
      "get": {
        "summary": "ClientStates queries all the IBC light clients of a chain.",
        "operationId": "ClientStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "client_id": {
                        "type": "string",
                        "title": "client identifier"
                      },
                      "client_state": {
                        "title": "client state",
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    },
                    "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                  },
                  "description": "list of stored ClientStates of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_states/{client_id}": {
      "get": {
        "summary": "ClientState queries an IBC light client.",
        "operationId": "ClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "client_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "client state associated with the request identifier"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client state unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/client_status/{client_id}": {
      "get": {
        "summary": "Status queries the status of an IBC client.",
        "operationId": "ClientStatus",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "status": {
                  "type": "string"
                }
              },
              "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}": {
      "get": {
        "summary": "ConsensusStates queries all the consensus state associated with a given\nclient.",
        "operationId": "ConsensusStates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_states": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "height": {
                        "title": "consensus state height",
                        "type": "object",
                        "properties": {
                          "revision_number": {
                            "type": "string",
                            "format": "uint64",
                            "title": "the revision that the client is currently on"
                          },
                          "revision_height": {
                            "type": "string",
                            "format": "uint64",
                            "title": "the height within the given revision"
                          }
                        },
                        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                      },
                      "consensus_state": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "title": "consensus state"
                      }
                    },
                    "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
                  },
                  "title": "consensus states associated with the identifier"
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/heights": {
      "get": {
        "summary": "ConsensusStateHeights queries the height of every consensus states associated with a given client.",
        "operationId": "ConsensusStateHeights",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state_heights": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "revision_number": {
                        "type": "string",
                        "format": "uint64",
                        "title": "the revision that the client is currently on"
                      },
                      "revision_height": {
                        "type": "string",
                        "format": "uint64",
                        "title": "the height within the given revision"
                      }
                    },
                    "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
                    "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
                  },
                  "title": "consensus state heights"
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ConsensusState queries a consensus state associated with a client state at\na given height.",
        "operationId": "ConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the client identifier at the given height"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
                  "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
                }
              },
              "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "description": "consensus state revision number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "description": "consensus state revision height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "latest_height",
            "description": "latest_height overrrides the height field and queries the latest stored\nConsensusState.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/params": {
      "get": {
        "summary": "ClientParams queries all parameters of the ibc client submodule.",
        "operationId": "ClientParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "allowed_clients": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list."
                    }
                  }
                }
              },
              "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/upgraded_client_states": {
      "get": {
        "summary": "UpgradedClientState queries an Upgraded IBC light client.",
        "operationId": "UpgradedClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "upgraded_client_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "client state associated with the request identifier"
                }
              },
              "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/client/v1/upgraded_consensus_states": {
      "get": {
        "summary": "UpgradedConsensusState queries an Upgraded IBC consensus state.",
        "operationId": "UpgradedConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "upgraded_consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "Consensus state associated with the request identifier"
                }
              },
              "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/client_connections/{client_id}": {
      "get": {
        "summary": "ClientConnections queries the connection paths associated with a client\nstate.",
        "operationId": "ClientConnections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection_paths": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "slice of all the connection paths associated with a client."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was generated",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "client_id",
            "description": "client identifier associated with a connection",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections": {
      "get": {
        "summary": "Connections queries all the IBC connections of a chain.",
        "operationId": "Connections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string",
                        "description": "connection identifier."
                      },
                      "client_id": {
                        "type": "string",
                        "description": "client associated with this connection."
                      },
                      "versions": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "identifier": {
                              "type": "string",
                              "title": "unique version identifier"
                            },
                            "features": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "title": "list of features compatible with the specified identifier"
                            }
                          },
                          "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                        },
                        "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
                      },
                      "state": {
                        "description": "current state of the connection end.",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                      },
                      "counterparty": {
                        "description": "counterparty chain associated with this connection.",
                        "type": "object",
                        "properties": {
                          "client_id": {
                            "type": "string",
                            "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                          },
                          "connection_id": {
                            "type": "string",
                            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                          },
                          "prefix": {
                            "description": "commitment merkle prefix of the counterparty chain.",
                            "type": "object",
                            "properties": {
                              "key_prefix": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                          }
                        }
                      },
                      "delay_period": {
                        "type": "string",
                        "format": "uint64",
                        "description": "delay period associated with this connection."
                      }
                    },
                    "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
                  },
                  "description": "list of stored connections of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}": {
      "get": {
        "summary": "Connection queries an IBC connection end.",
        "operationId": "Connection",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "connection": {
                  "title": "connection associated with the request identifier",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "description": "client associated with this connection."
                    },
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "identifier": {
                            "type": "string",
                            "title": "unique version identifier"
                          },
                          "features": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "title": "list of features compatible with the specified identifier"
                          }
                        },
                        "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                      },
                      "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
                    },
                    "state": {
                      "description": "current state of the connection end.",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED"
                    },
                    "counterparty": {
                      "description": "counterparty chain associated with this connection.",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "type": "string",
                          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                        },
                        "connection_id": {
                          "type": "string",
                          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                        },
                        "prefix": {
                          "description": "commitment merkle prefix of the counterparty chain.",
                          "type": "object",
                          "properties": {
                            "key_prefix": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                        }
                      }
                    },
                    "delay_period": {
                      "type": "string",
                      "format": "uint64",
                      "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
                    }
                  },
                  "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
      "get": {
        "summary": "ConnectionClientState queries the client state associated with the\nconnection.",
        "operationId": "ConnectionClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                      "title": "client state"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ConnectionConsensusState queries the consensus state associated with the\nconnection.",
        "operationId": "ConnectionConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the channel"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection_id",
            "description": "connection identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/connection/v1/params": {
      "get": {
        "summary": "ConnectionParams queries all parameters of the ibc connection submodule.",
        "operationId": "ConnectionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "max_expected_time_per_block": {
                      "type": "string",
                      "format": "uint64",
                      "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block."
                    }
                  }
                }
              },
              "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels": {
      "get": {
        "summary": "Channels queries all the IBC channels of a chain.",
        "operationId": "Channels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of stored channels of the chain."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
      "get": {
        "summary": "Channel queries an IBC Channel.",
        "operationId": "Channel",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channel": {
                  "title": "channel associated with the request identifiers",
                  "type": "object",
                  "properties": {
                    "state": {
                      "title": "current state of the channel end",
                      "type": "string",
                      "enum": [
                        "STATE_UNINITIALIZED_UNSPECIFIED",
                        "STATE_INIT",
                        "STATE_TRYOPEN",
                        "STATE_OPEN",
                        "STATE_CLOSED"
                      ],
                      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                    },
                    "ordering": {
                      "title": "whether the channel is ordered or unordered",
                      "type": "string",
                      "enum": [
                        "ORDER_NONE_UNSPECIFIED",
                        "ORDER_UNORDERED",
                        "ORDER_ORDERED"
                      ],
                      "default": "ORDER_NONE_UNSPECIFIED",
                      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                    },
                    "counterparty": {
                      "title": "counterparty channel end",
                      "type": "object",
                      "properties": {
                        "port_id": {
                          "type": "string",
                          "description": "port on the counterparty chain which owns the other end of the channel."
                        },
                        "channel_id": {
                          "type": "string",
                          "title": "channel end on the counterparty chain"
                        }
                      }
                    },
                    "connection_hops": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                    },
                    "version": {
                      "type": "string",
                      "title": "opaque channel version, which is agreed upon during the handshake"
                    }
                  },
                  "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
      "get": {
        "summary": "ChannelClientState queries for the client state for the channel associated\nwith the provided channel identifiers.",
        "operationId": "ChannelClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "identified_client_state": {
                  "title": "client state associated with the channel",
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "title": "client identifier"
                    },
                    "client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                      "title": "client state"
                    }
                  },
                  "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "summary": "ChannelConsensusState queries for the consensus state for the channel\nassociated with the provided channel identifiers.",
        "operationId": "ChannelConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "consensus_state": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                  "title": "consensus state associated with the channel"
                },
                "client_id": {
                  "type": "string",
                  "title": "client ID associated with the consensus state"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "revision_number",
            "description": "revision number of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "revision_height",
            "description": "revision height of the consensus state",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
      "get": {
        "summary": "NextSequenceReceive returns the next receive sequence for a given channel.",
        "operationId": "NextSequenceReceive",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "next_sequence_receive": {
                  "type": "string",
                  "format": "uint64",
                  "title": "next sequence receive number"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
      "get": {
        "summary": "PacketAcknowledgements returns all the packet acknowledgements associated\nwith a channel.",
        "operationId": "PacketAcknowledgements",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "acknowledgements": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "port_id": {
                        "type": "string",
                        "description": "channel port identifier."
                      },
                      "channel_id": {
                        "type": "string",
                        "description": "channel unique identifier."
                      },
                      "sequence": {
                        "type": "string",
                        "format": "uint64",
                        "description": "packet sequence."
                      },
                      "data": {
                        "type": "string",
                        "format": "byte",
                        "description": "embedded data that represents packet state."
                      }
                    },
                    "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                  }
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "packet_commitment_sequences",
            "description": "list of packet sequences.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "multi"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
      "get": {
        "summary": "PacketAcknowledgement queries a stored packet acknowledgement hash.",
        "operationId": "PacketAcknowledgement",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "acknowledgement": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
      "get": {
        "summary": "PacketCommitments returns all the packet commitments hashes associated\nwith a channel.",
        "operationId": "PacketCommitments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "port_id": {
                        "type": "string",
                        "description": "channel port identifier."
                      },
                      "channel_id": {
                        "type": "string",
                        "description": "channel unique identifier."
                      },
                      "sequence": {
                        "type": "string",
                        "format": "uint64",
                        "description": "packet sequence."
                      },
                      "data": {
                        "type": "string",
                        "format": "byte",
                        "description": "embedded data that represents packet state."
                      }
                    },
                    "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                  }
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
      "get": {
        "summary": "UnreceivedAcks returns all the unreceived IBC acknowledgements associated\nwith a channel and sequences.",
        "operationId": "UnreceivedAcks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "title": "list of unreceived acknowledgement sequences"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "packet_ack_sequences",
            "description": "list of acknowledgement sequences",
            "in": "path",
            "required": true,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "csv",
            "minItems": 1
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
      "get": {
        "summary": "UnreceivedPackets returns all the unreceived IBC packets associated with a\nchannel and sequences.",
        "operationId": "UnreceivedPackets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "sequences": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "title": "list of unreceived packet sequences"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "packet_commitment_sequences",
            "description": "list of packet sequences",
            "in": "path",
            "required": true,
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "collectionFormat": "csv",
            "minItems": 1
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
      "get": {
        "summary": "PacketCommitment queries a stored packet commitment hash.",
        "operationId": "PacketCommitment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "commitment": {
                  "type": "string",
                  "format": "byte",
                  "title": "packet associated with the request fields"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
      "get": {
        "summary": "PacketReceipt queries if a given packet sequence has been received on the\nqueried chain",
        "operationId": "PacketReceipt",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "received": {
                  "type": "boolean",
                  "title": "success flag for if receipt exists"
                },
                "proof": {
                  "type": "string",
                  "format": "byte",
                  "title": "merkle proof of existence"
                },
                "proof_height": {
                  "title": "height at which the proof was retrieved",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "channel_id",
            "description": "channel unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "port_id",
            "description": "port unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "sequence",
            "description": "packet sequence",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/core/channel/v1/connections/{connection}/channels": {
      "get": {
        "summary": "ConnectionChannels queries all the channels associated with a connection\nend.",
        "operationId": "ConnectionChannels",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "channels": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "state": {
                        "title": "current state of the channel end",
                        "type": "string",
                        "enum": [
                          "STATE_UNINITIALIZED_UNSPECIFIED",
                          "STATE_INIT",
                          "STATE_TRYOPEN",
                          "STATE_OPEN",
                          "STATE_CLOSED"
                        ],
                        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
                      },
                      "ordering": {
                        "title": "whether the channel is ordered or unordered",
                        "type": "string",
                        "enum": [
                          "ORDER_NONE_UNSPECIFIED",
                          "ORDER_UNORDERED",
                          "ORDER_ORDERED"
                        ],
                        "default": "ORDER_NONE_UNSPECIFIED",
                        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
                      },
                      "counterparty": {
                        "title": "counterparty channel end",
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "port on the counterparty chain which owns the other end of the channel."
                          },
                          "channel_id": {
                            "type": "string",
                            "title": "channel end on the counterparty chain"
                          }
                        }
                      },
                      "connection_hops": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
                      },
                      "version": {
                        "type": "string",
                        "title": "opaque channel version, which is agreed upon during the handshake"
                      },
                      "port_id": {
                        "type": "string",
                        "title": "port identifier"
                      },
                      "channel_id": {
                        "type": "string",
                        "title": "channel identifier"
                      }
                    },
                    "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                  },
                  "description": "list of channels associated with a connection."
                },
                "pagination": {
                  "title": "pagination response",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                },
                "height": {
                  "title": "query block height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the revision that the client is currently on"
                    },
                    "revision_height": {
                      "type": "string",
                      "format": "uint64",
                      "title": "the height within the given revision"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                }
              },
              "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "connection",
            "description": "connection unique identifier",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/account_info/{address}": {
      "get": {
        "summary": "AccountInfo queries account info which is common to all account types.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "AccountInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "description": "info is the account info which is represented by BaseAccount.",
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string"
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "account_number": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sequence": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryAccountInfoResponse is the Query/AccountInfo response type.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the account address string.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/accounts": {
      "get": {
        "summary": "Accounts returns all the existing accounts.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.43",
        "operationId": "Accounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "accounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "title": "accounts are the existing accounts"
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "summary": "Account returns account details based on address.",
        "operationId": "AuthAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address defines the address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/address_by_id/{id}": {
      "get": {
        "summary": "AccountAddressByID returns account address based on account number.",
        "description": "Since: cosmos-sdk 0.46.2",
        "operationId": "AccountAddressByID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account_address": {
                  "type": "string"
                }
              },
              "description": "Since: cosmos-sdk 0.46.2",
              "title": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Deprecated, use account_id instead\n\nid is the account number of the address to be queried. This field\nshould have been an uint64 (like all account numbers), and will be\nupdated to uint64 in a future version of the auth query.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "account_id",
            "description": "account_id is the account number of the address to be queried.\n\nSince: cosmos-sdk 0.47",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32": {
      "get": {
        "summary": "Bech32Prefix queries bech32Prefix",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "Bech32Prefix",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "bech32_prefix": {
                  "type": "string"
                }
              },
              "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{address_bytes}": {
      "get": {
        "summary": "AddressBytesToString converts Account Address bytes to string",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AddressBytesToString",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "address_string": {
                  "type": "string"
                }
              },
              "description": "AddressBytesToStringResponse is the response type for AddressString rpc method.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address_bytes",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/bech32/{address_string}": {
      "get": {
        "summary": "AddressStringToBytes converts Address string to bytes",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AddressStringToBytes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "address_bytes": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address_string",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts": {
      "get": {
        "summary": "ModuleAccounts returns all the existing module accounts.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "ModuleAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "accounts": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              },
              "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/module_accounts/{name}": {
      "get": {
        "summary": "ModuleAccountByName returns the module account info by module name",
        "operationId": "ModuleAccountByName",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "account": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "summary": "Params queries all parameters.",
        "operationId": "AuthParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "max_memo_characters": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_sig_limit": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "tx_size_cost_per_byte": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_ed25519": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "sig_verify_cost_secp256k1": {
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants": {
      "get": {
        "summary": "Returns list of `Authorization`, granted to the grantee by the granter.",
        "operationId": "Grants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "grants": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "authorization": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "expiration": {
                        "type": "string",
                        "format": "date-time",
                        "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)"
                      }
                    },
                    "description": "Grant gives permissions to execute\nthe provide method with expiration time."
                  },
                  "description": "authorizations is a list of grants granted for grantee by granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "grantee",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "msg_type_url",
            "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants/grantee/{grantee}": {
      "get": {
        "summary": "GranteeGrants returns a list of `GrantAuthorization` by grantee.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "GranteeGrants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "grants": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "granter": {
                        "type": "string"
                      },
                      "grantee": {
                        "type": "string"
                      },
                      "authorization": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "expiration": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
                  },
                  "description": "grants is a list of grants granted to the grantee."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/authz/v1beta1/grants/granter/{granter}": {
      "get": {
        "summary": "GranterGrants returns list of `GrantAuthorization`, granted by granter.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "GranterGrants",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "grants": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "granter": {
                        "type": "string"
                      },
                      "grantee": {
                        "type": "string"
                      },
                      "authorization": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "expiration": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
                  },
                  "description": "grants is a list of grants granted by the granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "AllBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "balances is the balances of all the coins."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
      "get": {
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "BankBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denom_owners/{denom}": {
      "get": {
        "summary": "DenomOwners queries for all account addresses that own a particular token\ndenomination.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.46",
        "operationId": "DenomOwners",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "denom_owners": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "description": "address defines the address that owns a particular denomination."
                      },
                      "balance": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom defines the coin denomination to query all account holders for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata": {
      "get": {
        "summary": "DenomsMetadata queries the client metadata for all registered coin\ndenominations.",
        "operationId": "DenomsMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "metadatas": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "description": {
                        "type": "string"
                      },
                      "denom_units": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string",
                              "description": "denom represents the string name of the given denom unit (e.g uatom)."
                            },
                            "exponent": {
                              "type": "integer",
                              "format": "int64",
                              "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                            },
                            "aliases": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "title": "aliases is a list of string aliases for the given denom"
                            }
                          },
                          "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                        },
                        "title": "denom_units represents the list of DenomUnit's for a given coin"
                      },
                      "base": {
                        "type": "string",
                        "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                      },
                      "display": {
                        "type": "string",
                        "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                      },
                      "name": {
                        "type": "string",
                        "description": "Since: cosmos-sdk 0.43",
                        "title": "name defines the name of the token (eg: Cosmos Atom)"
                      },
                      "symbol": {
                        "type": "string",
                        "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                      },
                      "uri": {
                        "type": "string",
                        "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                      },
                      "uri_hash": {
                        "type": "string",
                        "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                      }
                    },
                    "description": "Metadata represents a struct that describes\na basic token."
                  },
                  "description": "metadata provides the client information for all the registered tokens."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
      "get": {
        "summary": "DenomsMetadata queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "denom_units": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string",
                            "description": "denom represents the string name of the given denom unit (e.g uatom)."
                          },
                          "exponent": {
                            "type": "integer",
                            "format": "int64",
                            "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                          },
                          "aliases": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            },
                            "title": "aliases is a list of string aliases for the given denom"
                          }
                        },
                        "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                      },
                      "title": "denom_units represents the list of DenomUnit's for a given coin"
                    },
                    "base": {
                      "type": "string",
                      "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                    },
                    "display": {
                      "type": "string",
                      "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                    },
                    "name": {
                      "type": "string",
                      "description": "Since: cosmos-sdk 0.43",
                      "title": "name defines the name of the token (eg: Cosmos Atom)"
                    },
                    "symbol": {
                      "type": "string",
                      "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                    },
                    "uri": {
                      "type": "string",
                      "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                    },
                    "uri_hash": {
                      "type": "string",
                      "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                    }
                  },
                  "description": "Metadata represents a struct that describes\na basic token."
                }
              },
              "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query the metadata for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of x/bank module.",
        "operationId": "BankParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "enabled": {
                            "type": "boolean"
                          }
                        },
                        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                      },
                      "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
                    },
                    "default_send_enabled": {
                      "type": "boolean"
                    }
                  },
                  "description": "Params defines the parameters for the bank module."
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/send_enabled": {
      "get": {
        "summary": "SendEnabled queries for SendEnabled entries.",
        "description": "This query only returns denominations that have specific SendEnabled settings.\nAny denomination that does not have a specific setting will use the default\nparams.default_send_enabled, and will not be returned by this query.\n\nSince: cosmos-sdk 0.47",
        "operationId": "SendEnabled",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "send_enabled": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "enabled": {
                        "type": "boolean"
                      }
                    },
                    "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                  }
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response. This field is only\npopulated if the denoms field in the request is empty.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denoms",
            "description": "denoms is the specific denoms you want look up. Leave empty to get all entries.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}": {
      "get": {
        "summary": "SpendableBalances queries the spendable balance of all coins for a single\naccount.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.46",
        "operationId": "SpendableBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "description": "balances is the spendable balances of all the coins."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying\nan account's spendable balances.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query spendable balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom": {
      "get": {
        "summary": "SpendableBalanceByDenom queries the spendable balance of a single denom for\na single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.47",
        "operationId": "SpendableBalanceByDenom",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for\nquerying an account's spendable balance for a specific denom.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "address",
            "description": "address is the address to query balances for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "summary": "TotalSupply queries the total supply of all coins.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "TotalSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "supply": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  },
                  "title": "supply is the supply of the coins"
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/bank/v1beta1/supply/by_denom": {
      "get": {
        "summary": "SupplyOf queries the supply of a single coin.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "SupplyOf",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "denom",
            "description": "denom is the coin denom to query balances for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
      "get": {
        "summary": "Allowance returns fee granted to the grantee by the granter.",
        "operationId": "Allowance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "allowance": {
                  "description": "allowance is a allowance granted for grantee by granter.",
                  "type": "object",
                  "properties": {
                    "granter": {
                      "type": "string",
                      "description": "granter is the address of the user granting an allowance of their funds."
                    },
                    "grantee": {
                      "type": "string",
                      "description": "grantee is the address of the user being granted an allowance of another user's funds."
                    },
                    "allowance": {
                      "description": "allowance can be any of basic, periodic, allowed fee allowance.",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      }
                    }
                  },
                  "title": "Grant is stored in the KVStore to record a grant with full context"
                }
              },
              "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "description": "granter is the address of the user granting an allowance of their funds.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "grantee",
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
      "get": {
        "summary": "Allowances returns all the grants for address.",
        "operationId": "Allowances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "allowances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "granter": {
                        "type": "string",
                        "description": "granter is the address of the user granting an allowance of their funds."
                      },
                      "grantee": {
                        "type": "string",
                        "description": "grantee is the address of the user being granted an allowance of another user's funds."
                      },
                      "allowance": {
                        "description": "allowance can be any of basic, periodic, allowed fee allowance.",
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        }
                      }
                    },
                    "title": "Grant is stored in the KVStore to record a grant with full context"
                  },
                  "description": "allowances are allowance's granted for grantee by granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/feegrant/v1beta1/issued/{granter}": {
      "get": {
        "summary": "AllowancesByGranter returns all the grants given by an address",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AllowancesByGranter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "allowances": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "granter": {
                        "type": "string",
                        "description": "granter is the address of the user granting an allowance of their funds."
                      },
                      "grantee": {
                        "type": "string",
                        "description": "grantee is the address of the user being granted an allowance of another user's funds."
                      },
                      "allowance": {
                        "description": "allowance can be any of basic, periodic, allowed fee allowance.",
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        }
                      }
                    },
                    "title": "Grant is stored in the KVStore to record a grant with full context"
                  },
                  "description": "allowances that have been issued by the granter."
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "summary": "AllEvidence queries all evidence.",
        "operationId": "AllEvidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  },
                  "description": "evidence returns all evidences."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{hash}": {
      "get": {
        "summary": "Evidence queries evidence based on evidence hash.",
        "operationId": "Evidence",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash defines the evidence hash of the requested evidence.\n\nSince: cosmos-sdk 0.47",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "evidence_hash",
            "description": "evidence_hash defines the hash of the requested evidence.\nDeprecated: Use hash, a HEX encoded string, instead.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/params/{params_type}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "voting_params": {
                  "description": "voting_params defines the parameters related to voting.",
                  "type": "object",
                  "properties": {
                    "voting_period": {
                      "type": "string",
                      "description": "Duration of the voting period."
                    }
                  }
                },
                "deposit_params": {
                  "description": "deposit_params defines the parameters related to deposit.",
                  "type": "object",
                  "properties": {
                    "min_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "Minimum deposit for a proposal to enter voting period."
                    },
                    "max_deposit_period": {
                      "type": "string",
                      "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                    }
                  }
                },
                "tally_params": {
                  "description": "tally_params defines the parameters related to tally.",
                  "type": "object",
                  "properties": {
                    "quorum": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
                    },
                    "threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                    },
                    "veto_threshold": {
                      "type": "string",
                      "format": "byte",
                      "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "params_type",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposals": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "proposal_id defines the unique id of the proposal."
                      },
                      "content": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "status": {
                        "description": "status defines the proposal status.",
                        "type": "string",
                        "enum": [
                          "PROPOSAL_STATUS_UNSPECIFIED",
                          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                          "PROPOSAL_STATUS_VOTING_PERIOD",
                          "PROPOSAL_STATUS_PASSED",
                          "PROPOSAL_STATUS_REJECTED",
                          "PROPOSAL_STATUS_FAILED"
                        ],
                        "default": "PROPOSAL_STATUS_UNSPECIFIED"
                      },
                      "final_tally_result": {
                        "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                        "type": "object",
                        "properties": {
                          "yes": {
                            "type": "string",
                            "description": "yes is the number of yes votes on a proposal."
                          },
                          "abstain": {
                            "type": "string",
                            "description": "abstain is the number of abstain votes on a proposal."
                          },
                          "no": {
                            "type": "string",
                            "description": "no is the number of no votes on a proposal."
                          },
                          "no_with_veto": {
                            "type": "string",
                            "description": "no_with_veto is the number of no with veto votes on a proposal."
                          }
                        }
                      },
                      "submit_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "submit_time is the time of proposal submission."
                      },
                      "deposit_end_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "deposit_end_time is the end time for deposition."
                      },
                      "total_deposit": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "description": "total_deposit is the total deposit on the proposal."
                      },
                      "voting_start_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "voting_start_time is the starting time to vote on a proposal."
                      },
                      "voting_end_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "voting_end_time is the end time of voting on a proposal."
                      }
                    },
                    "description": "Proposal defines the core field members of a governance proposal."
                  },
                  "description": "proposals defines all the requested governance proposals."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_status",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposal": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "proposal_id defines the unique id of the proposal."
                    },
                    "content": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "status": {
                      "description": "status defines the proposal status.",
                      "type": "string",
                      "enum": [
                        "PROPOSAL_STATUS_UNSPECIFIED",
                        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                        "PROPOSAL_STATUS_VOTING_PERIOD",
                        "PROPOSAL_STATUS_PASSED",
                        "PROPOSAL_STATUS_REJECTED",
                        "PROPOSAL_STATUS_FAILED"
                      ],
                      "default": "PROPOSAL_STATUS_UNSPECIFIED"
                    },
                    "final_tally_result": {
                      "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                      "type": "object",
                      "properties": {
                        "yes": {
                          "type": "string",
                          "description": "yes is the number of yes votes on a proposal."
                        },
                        "abstain": {
                          "type": "string",
                          "description": "abstain is the number of abstain votes on a proposal."
                        },
                        "no": {
                          "type": "string",
                          "description": "no is the number of no votes on a proposal."
                        },
                        "no_with_veto": {
                          "type": "string",
                          "description": "no_with_veto is the number of no with veto votes on a proposal."
                        }
                      }
                    },
                    "submit_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "submit_time is the time of proposal submission."
                    },
                    "deposit_end_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "deposit_end_time is the end time for deposition."
                    },
                    "total_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "total_deposit is the total deposit on the proposal."
                    },
                    "voting_start_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "voting_start_time is the starting time to vote on a proposal."
                    },
                    "voting_end_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "voting_end_time is the end time of voting on a proposal."
                    }
                  },
                  "description": "Proposal defines the core field members of a governance proposal."
                }
              },
              "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposits": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "proposal_id defines the unique id of the proposal."
                      },
                      "depositor": {
                        "type": "string",
                        "description": "depositor defines the deposit addresses from the proposals."
                      },
                      "amount": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "description": "amount to be deposited by depositor."
                      }
                    },
                    "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                  },
                  "description": "deposits defines the requested deposits."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based proposalID, depositAddr.",
        "operationId": "Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposit": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "proposal_id defines the unique id of the proposal."
                    },
                    "depositor": {
                      "type": "string",
                      "description": "depositor defines the deposit addresses from the proposals."
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "amount to be deposited by depositor."
                    }
                  },
                  "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                }
              },
              "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tally": {
                  "description": "tally defines the requested tally.",
                  "type": "object",
                  "properties": {
                    "yes": {
                      "type": "string",
                      "description": "yes is the number of yes votes on a proposal."
                    },
                    "abstain": {
                      "type": "string",
                      "description": "abstain is the number of abstain votes on a proposal."
                    },
                    "no": {
                      "type": "string",
                      "description": "no is the number of no votes on a proposal."
                    },
                    "no_with_veto": {
                      "type": "string",
                      "description": "no_with_veto is the number of no with veto votes on a proposal."
                    }
                  }
                }
              },
              "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "votes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "proposal_id defines the unique id of the proposal."
                      },
                      "voter": {
                        "type": "string",
                        "description": "voter is the voter address of the proposal."
                      },
                      "option": {
                        "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                        "type": "string",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ],
                        "default": "VOTE_OPTION_UNSPECIFIED"
                      },
                      "options": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "option": {
                              "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                              "type": "string",
                              "enum": [
                                "VOTE_OPTION_UNSPECIFIED",
                                "VOTE_OPTION_YES",
                                "VOTE_OPTION_ABSTAIN",
                                "VOTE_OPTION_NO",
                                "VOTE_OPTION_NO_WITH_VETO"
                              ],
                              "default": "VOTE_OPTION_UNSPECIFIED"
                            },
                            "weight": {
                              "type": "string",
                              "description": "weight is the vote weight associated with the vote option."
                            }
                          },
                          "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                        },
                        "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43"
                      }
                    },
                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                  },
                  "description": "votes defines the queried votes."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "vote": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "proposal_id defines the unique id of the proposal."
                    },
                    "voter": {
                      "type": "string",
                      "description": "voter is the voter address of the proposal."
                    },
                    "option": {
                      "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED"
                    },
                    "options": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "option": {
                            "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                            "type": "string",
                            "enum": [
                              "VOTE_OPTION_UNSPECIFIED",
                              "VOTE_OPTION_YES",
                              "VOTE_OPTION_ABSTAIN",
                              "VOTE_OPTION_NO",
                              "VOTE_OPTION_NO_WITH_VETO"
                            ],
                            "default": "VOTE_OPTION_UNSPECIFIED"
                          },
                          "weight": {
                            "type": "string",
                            "description": "weight is the vote weight associated with the vote option."
                          }
                        },
                        "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                      },
                      "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43"
                    }
                  },
                  "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                }
              },
              "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/params/{params_type}": {
      "get": {
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovV1Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "voting_params": {
                  "description": "Deprecated: Prefer to use `params` instead.\nvoting_params defines the parameters related to voting.",
                  "type": "object",
                  "properties": {
                    "voting_period": {
                      "type": "string",
                      "description": "Duration of the voting period."
                    }
                  }
                },
                "deposit_params": {
                  "description": "Deprecated: Prefer to use `params` instead.\ndeposit_params defines the parameters related to deposit.",
                  "type": "object",
                  "properties": {
                    "min_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "Minimum deposit for a proposal to enter voting period."
                    },
                    "max_deposit_period": {
                      "type": "string",
                      "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                    }
                  }
                },
                "tally_params": {
                  "description": "Deprecated: Prefer to use `params` instead.\ntally_params defines the parameters related to tally.",
                  "type": "object",
                  "properties": {
                    "quorum": {
                      "type": "string",
                      "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
                    },
                    "threshold": {
                      "type": "string",
                      "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                    },
                    "veto_threshold": {
                      "type": "string",
                      "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
                    }
                  }
                },
                "params": {
                  "description": "params defines all the paramaters of x/gov module.\n\nSince: cosmos-sdk 0.47",
                  "type": "object",
                  "properties": {
                    "min_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "Minimum deposit for a proposal to enter voting period."
                    },
                    "max_deposit_period": {
                      "type": "string",
                      "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                    },
                    "voting_period": {
                      "type": "string",
                      "description": "Duration of the voting period."
                    },
                    "quorum": {
                      "type": "string",
                      "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
                    },
                    "threshold": {
                      "type": "string",
                      "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                    },
                    "veto_threshold": {
                      "type": "string",
                      "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
                    },
                    "min_initial_deposit_ratio": {
                      "type": "string",
                      "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
                    },
                    "burn_vote_quorum": {
                      "type": "boolean",
                      "title": "burn deposits if a proposal does not meet quorum"
                    },
                    "burn_proposal_deposit_prevote": {
                      "type": "boolean",
                      "title": "burn deposits if the proposal does not enter voting period"
                    },
                    "burn_vote_veto": {
                      "type": "boolean",
                      "title": "burn deposits if quorum with vote type no_veto is met"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "params_type",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals": {
      "get": {
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "GovV1Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposals": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "id defines the unique id of the proposal."
                      },
                      "messages": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "type": "string",
                              "format": "byte",
                              "description": "Must be a valid serialized protocol buffer of the above specified type."
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "description": "messages are the arbitrary messages to be executed if the proposal passes."
                      },
                      "status": {
                        "description": "status defines the proposal status.",
                        "type": "string",
                        "enum": [
                          "PROPOSAL_STATUS_UNSPECIFIED",
                          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                          "PROPOSAL_STATUS_VOTING_PERIOD",
                          "PROPOSAL_STATUS_PASSED",
                          "PROPOSAL_STATUS_REJECTED",
                          "PROPOSAL_STATUS_FAILED"
                        ],
                        "default": "PROPOSAL_STATUS_UNSPECIFIED"
                      },
                      "final_tally_result": {
                        "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                        "type": "object",
                        "properties": {
                          "yes_count": {
                            "type": "string",
                            "description": "yes_count is the number of yes votes on a proposal."
                          },
                          "abstain_count": {
                            "type": "string",
                            "description": "abstain_count is the number of abstain votes on a proposal."
                          },
                          "no_count": {
                            "type": "string",
                            "description": "no_count is the number of no votes on a proposal."
                          },
                          "no_with_veto_count": {
                            "type": "string",
                            "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                          }
                        }
                      },
                      "submit_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "submit_time is the time of proposal submission."
                      },
                      "deposit_end_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "deposit_end_time is the end time for deposition."
                      },
                      "total_deposit": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "description": "total_deposit is the total deposit on the proposal."
                      },
                      "voting_start_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "voting_start_time is the starting time to vote on a proposal."
                      },
                      "voting_end_time": {
                        "type": "string",
                        "format": "date-time",
                        "description": "voting_end_time is the end time of voting on a proposal."
                      },
                      "metadata": {
                        "type": "string",
                        "description": "metadata is any arbitrary metadata attached to the proposal."
                      },
                      "title": {
                        "type": "string",
                        "description": "Since: cosmos-sdk 0.47",
                        "title": "title is the title of the proposal"
                      },
                      "summary": {
                        "type": "string",
                        "description": "Since: cosmos-sdk 0.47",
                        "title": "summary is a short summary of the proposal"
                      },
                      "proposer": {
                        "type": "string",
                        "description": "Since: cosmos-sdk 0.47",
                        "title": "Proposer is the address of the proposal sumbitter"
                      }
                    },
                    "description": "Proposal defines the core field members of a governance proposal."
                  },
                  "description": "proposals defines all the requested governance proposals."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_status",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ],
            "default": "PROPOSAL_STATUS_UNSPECIFIED"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}": {
      "get": {
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "GovV1Proposal",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "proposal": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "id defines the unique id of the proposal."
                    },
                    "messages": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "description": "messages are the arbitrary messages to be executed if the proposal passes."
                    },
                    "status": {
                      "description": "status defines the proposal status.",
                      "type": "string",
                      "enum": [
                        "PROPOSAL_STATUS_UNSPECIFIED",
                        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                        "PROPOSAL_STATUS_VOTING_PERIOD",
                        "PROPOSAL_STATUS_PASSED",
                        "PROPOSAL_STATUS_REJECTED",
                        "PROPOSAL_STATUS_FAILED"
                      ],
                      "default": "PROPOSAL_STATUS_UNSPECIFIED"
                    },
                    "final_tally_result": {
                      "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                      "type": "object",
                      "properties": {
                        "yes_count": {
                          "type": "string",
                          "description": "yes_count is the number of yes votes on a proposal."
                        },
                        "abstain_count": {
                          "type": "string",
                          "description": "abstain_count is the number of abstain votes on a proposal."
                        },
                        "no_count": {
                          "type": "string",
                          "description": "no_count is the number of no votes on a proposal."
                        },
                        "no_with_veto_count": {
                          "type": "string",
                          "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                        }
                      }
                    },
                    "submit_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "submit_time is the time of proposal submission."
                    },
                    "deposit_end_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "deposit_end_time is the end time for deposition."
                    },
                    "total_deposit": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "total_deposit is the total deposit on the proposal."
                    },
                    "voting_start_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "voting_start_time is the starting time to vote on a proposal."
                    },
                    "voting_end_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "voting_end_time is the end time of voting on a proposal."
                    },
                    "metadata": {
                      "type": "string",
                      "description": "metadata is any arbitrary metadata attached to the proposal."
                    },
                    "title": {
                      "type": "string",
                      "description": "Since: cosmos-sdk 0.47",
                      "title": "title is the title of the proposal"
                    },
                    "summary": {
                      "type": "string",
                      "description": "Since: cosmos-sdk 0.47",
                      "title": "summary is a short summary of the proposal"
                    },
                    "proposer": {
                      "type": "string",
                      "description": "Since: cosmos-sdk 0.47",
                      "title": "Proposer is the address of the proposal sumbitter"
                    }
                  },
                  "description": "Proposal defines the core field members of a governance proposal."
                }
              },
              "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/deposits": {
      "get": {
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "GovV1Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposits": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "proposal_id defines the unique id of the proposal."
                      },
                      "depositor": {
                        "type": "string",
                        "description": "depositor defines the deposit addresses from the proposals."
                      },
                      "amount": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        },
                        "description": "amount to be deposited by depositor."
                      }
                    },
                    "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                  },
                  "description": "deposits defines the requested deposits."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "summary": "Deposit queries single deposit information based proposalID, depositAddr.",
        "operationId": "GovV1Deposit",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "deposit": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "proposal_id defines the unique id of the proposal."
                    },
                    "depositor": {
                      "type": "string",
                      "description": "depositor defines the deposit addresses from the proposals."
                    },
                    "amount": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      },
                      "description": "amount to be deposited by depositor."
                    }
                  },
                  "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                }
              },
              "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "depositor",
            "description": "depositor defines the deposit addresses from the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/tally": {
      "get": {
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "GovV1TallyResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tally": {
                  "description": "tally defines the requested tally.",
                  "type": "object",
                  "properties": {
                    "yes_count": {
                      "type": "string",
                      "description": "yes_count is the number of yes votes on a proposal."
                    },
                    "abstain_count": {
                      "type": "string",
                      "description": "abstain_count is the number of abstain votes on a proposal."
                    },
                    "no_count": {
                      "type": "string",
                      "description": "no_count is the number of no votes on a proposal."
                    },
                    "no_with_veto_count": {
                      "type": "string",
                      "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                    }
                  }
                }
              },
              "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/votes": {
      "get": {
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "GovV1Votes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "votes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "proposal_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "proposal_id defines the unique id of the proposal."
                      },
                      "voter": {
                        "type": "string",
                        "description": "voter is the voter address of the proposal."
                      },
                      "options": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "option": {
                              "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                              "type": "string",
                              "enum": [
                                "VOTE_OPTION_UNSPECIFIED",
                                "VOTE_OPTION_YES",
                                "VOTE_OPTION_ABSTAIN",
                                "VOTE_OPTION_NO",
                                "VOTE_OPTION_NO_WITH_VETO"
                              ],
                              "default": "VOTE_OPTION_UNSPECIFIED"
                            },
                            "weight": {
                              "type": "string",
                              "description": "weight is the vote weight associated with the vote option."
                            }
                          },
                          "description": "WeightedVoteOption defines a unit of vote for vote split."
                        },
                        "description": "options is the weighted vote options."
                      },
                      "metadata": {
                        "type": "string",
                        "description": "metadata is any  arbitrary metadata to attached to the vote."
                      }
                    },
                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                  },
                  "description": "votes defines the queried votes."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "GovV1Vote",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "vote": {
                  "type": "object",
                  "properties": {
                    "proposal_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "proposal_id defines the unique id of the proposal."
                    },
                    "voter": {
                      "type": "string",
                      "description": "voter is the voter address of the proposal."
                    },
                    "options": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "option": {
                            "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                            "type": "string",
                            "enum": [
                              "VOTE_OPTION_UNSPECIFIED",
                              "VOTE_OPTION_YES",
                              "VOTE_OPTION_ABSTAIN",
                              "VOTE_OPTION_NO",
                              "VOTE_OPTION_NO_WITH_VETO"
                            ],
                            "default": "VOTE_OPTION_UNSPECIFIED"
                          },
                          "weight": {
                            "type": "string",
                            "description": "weight is the vote weight associated with the vote option."
                          }
                        },
                        "description": "WeightedVoteOption defines a unit of vote for vote split."
                      },
                      "description": "options is the weighted vote options."
                    },
                    "metadata": {
                      "type": "string",
                      "description": "metadata is any  arbitrary metadata to attached to the vote."
                    }
                  },
                  "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                }
              },
              "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "proposal_id",
            "description": "proposal_id defines the unique id of the proposal.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "voter",
            "description": "voter defines the voter address for the proposals.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "summary": "Params queries the parameters of slashing module",
        "operationId": "SlashingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "type": "object",
                  "properties": {
                    "signed_blocks_window": {
                      "type": "string",
                      "format": "int64"
                    },
                    "min_signed_per_window": {
                      "type": "string",
                      "format": "byte"
                    },
                    "downtime_jail_duration": {
                      "type": "string"
                    },
                    "slash_fraction_double_sign": {
                      "type": "string",
                      "format": "byte"
                    },
                    "slash_fraction_downtime": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "Params represents the parameters used for by the slashing module."
                }
              },
              "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "summary": "SigningInfos queries signing info of all validators",
        "operationId": "SigningInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "start_height": {
                        "type": "string",
                        "format": "int64",
                        "title": "Height at which validator was first a candidate OR was unjailed"
                      },
                      "index_offset": {
                        "type": "string",
                        "format": "int64",
                        "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
                      },
                      "jailed_until": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Timestamp until which the validator is jailed due to liveness downtime."
                      },
                      "tombstoned": {
                        "type": "boolean",
                        "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
                      },
                      "missed_blocks_counter": {
                        "type": "string",
                        "format": "int64",
                        "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
                      }
                    },
                    "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
                  },
                  "title": "info is the signing info of all validators"
                },
                "pagination": {
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
      "get": {
        "summary": "SigningInfo queries the signing info of given cons address",
        "operationId": "SigningInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "val_signing_info": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string"
                    },
                    "start_height": {
                      "type": "string",
                      "format": "int64",
                      "title": "Height at which validator was first a candidate OR was unjailed"
                    },
                    "index_offset": {
                      "type": "string",
                      "format": "int64",
                      "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
                    },
                    "jailed_until": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Timestamp until which the validator is jailed due to liveness downtime."
                    },
                    "tombstoned": {
                      "type": "boolean",
                      "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
                    },
                    "missed_blocks_counter": {
                      "type": "string",
                      "format": "int64",
                      "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
                    }
                  },
                  "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                  "title": "val_signing_info is the signing info of requested val cons address"
                }
              },
              "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "cons_address",
            "description": "cons_address is the address to query signing info of",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/tx/v1beta1/decode": {
      "post": {
        "summary": "TxDecode decodes the transaction.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxDecode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxDecodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "tx_bytes": {
                  "type": "string",
                  "format": "byte",
                  "description": "tx_bytes is the raw transaction."
                }
              },
              "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method.\n\nSince: cosmos-sdk 0.47"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/decode/amino": {
      "post": {
        "summary": "TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxDecodeAmino",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amino_json": {
                  "type": "string"
                }
              },
              "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "amino_binary": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/encode": {
      "post": {
        "summary": "TxEncode encodes the transaction.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxEncode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tx_bytes": {
                  "type": "string",
                  "format": "byte",
                  "description": "tx_bytes is the encoded transaction bytes."
                }
              },
              "description": "TxEncodeResponse is the response type for the\nService.TxEncode method.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.TxEncodeRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/encode/amino": {
      "post": {
        "summary": "TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxEncodeAmino",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amino_binary": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "amino_json": {
                  "type": "string"
                }
              },
              "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/simulate": {
      "post": {
        "summary": "Simulate simulates executing a transaction for estimating gas usage.",
        "operationId": "Simulate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "gas_info": {
                  "description": "gas_info is the information about gas used in the simulation.",
                  "type": "object",
                  "properties": {
                    "gas_wanted": {
                      "type": "string",
                      "format": "uint64",
                      "description": "GasWanted is the maximum units of work we allow this tx to perform."
                    },
                    "gas_used": {
                      "type": "string",
                      "format": "uint64",
                      "description": "GasUsed is the amount of gas actually consumed."
                    }
                  }
                },
                "result": {
                  "description": "result is the result of the simulation.",
                  "type": "object",
                  "properties": {
                    "data": {
                      "type": "string",
                      "format": "byte",
                      "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL."
                    },
                    "log": {
                      "type": "string",
                      "description": "Log contains the log information from message or handler execution."
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                },
                                "index": {
                                  "type": "boolean"
                                }
                              },
                              "description": "EventAttribute is a single key-value pair, associated with an event."
                            }
                          }
                        },
                        "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                      },
                      "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
                    },
                    "msg_responses": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46"
                    }
                  }
                }
              },
              "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.SimulateRequest"
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs": {
      "get": {
        "summary": "GetTxsEvent fetches txs by event.",
        "operationId": "GetTxsEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxsEventResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "events",
            "description": "events is the list of transaction event type.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "order_by",
            "description": " - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "ORDER_BY_UNSPECIFIED",
              "ORDER_BY_ASC",
              "ORDER_BY_DESC"
            ],
            "default": "ORDER_BY_UNSPECIFIED"
          },
          {
            "name": "page",
            "description": "page is the page number to query, starts at 1. If not provided, will default to first page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Service"
        ]
      },
      "post": {
        "summary": "BroadcastTx broadcast transaction.",
        "operationId": "BroadcastTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "tx_response": {
                  "type": "object",
                  "properties": {
                    "height": {
                      "type": "string",
                      "format": "int64",
                      "title": "The block height"
                    },
                    "txhash": {
                      "type": "string",
                      "description": "The transaction hash."
                    },
                    "codespace": {
                      "type": "string",
                      "title": "Namespace for the Code"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int64",
                      "description": "Response code."
                    },
                    "data": {
                      "type": "string",
                      "description": "Result bytes, if any."
                    },
                    "raw_log": {
                      "type": "string",
                      "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
                    },
                    "logs": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "msg_index": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "log": {
                            "type": "string"
                          },
                          "events": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string"
                                },
                                "attributes": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "key": {
                                        "type": "string"
                                      },
                                      "value": {
                                        "type": "string"
                                      }
                                    },
                                    "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                                  }
                                }
                              },
                              "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                            },
                            "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                          }
                        },
                        "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                      },
                      "description": "The output of the application's logger (typed). May be non-deterministic."
                    },
                    "info": {
                      "type": "string",
                      "description": "Additional information. May be non-deterministic."
                    },
                    "gas_wanted": {
                      "type": "string",
                      "format": "int64",
                      "description": "Amount of gas requested for transaction."
                    },
                    "gas_used": {
                      "type": "string",
                      "format": "int64",
                      "description": "Amount of gas consumed by transaction."
                    },
                    "tx": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "timestamp": {
                      "type": "string",
                      "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                },
                                "index": {
                                  "type": "boolean"
                                }
                              },
                              "description": "EventAttribute is a single key-value pair, associated with an event."
                            }
                          }
                        },
                        "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                      },
                      "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
                    }
                  },
                  "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
                }
              },
              "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "tx_bytes": {
                  "type": "string",
                  "format": "byte",
                  "description": "tx_bytes is the raw transaction."
                },
                "mode": {
                  "type": "string",
                  "enum": [
                    "BROADCAST_MODE_UNSPECIFIED",
                    "BROADCAST_MODE_BLOCK",
                    "BROADCAST_MODE_SYNC",
                    "BROADCAST_MODE_ASYNC"
                  ],
                  "default": "BROADCAST_MODE_UNSPECIFIED",
                  "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
                }
              },
              "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
            }
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs/block/{height}": {
      "get": {
        "summary": "GetBlockWithTxs fetches a block with decoded txs.",
        "description": "Since: cosmos-sdk 0.45.2",
        "operationId": "GetBlockWithTxs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetBlockWithTxsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "description": "height is the height of the block to query.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/tx/v1beta1/txs/{hash}": {
      "get": {
        "summary": "GetTx fetches a tx by hash.",
        "operationId": "GetTx",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the tx hash to query, encoded as a hex string.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/abci_query": {
      "get": {
        "summary": "ABCIQuery defines a query handler that supports ABCI queries directly to the\napplication, bypassing Tendermint completely. The ABCI query must contain\na valid and supported path, including app, custom, p2p, and store.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "ABCIQuery",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "code": {
                  "type": "integer",
                  "format": "int64"
                },
                "log": {
                  "type": "string"
                },
                "info": {
                  "type": "string"
                },
                "index": {
                  "type": "string",
                  "format": "int64"
                },
                "key": {
                  "type": "string",
                  "format": "byte"
                },
                "value": {
                  "type": "string",
                  "format": "byte"
                },
                "proof_ops": {
                  "type": "object",
                  "properties": {
                    "ops": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "key": {
                            "type": "string",
                            "format": "byte"
                          },
                          "data": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
                      }
                    }
                  },
                  "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "codespace": {
                  "type": "string"
                }
              },
              "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.\n\nNote: This type is a duplicate of the ResponseQuery proto type defined in\nTendermint."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "data",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "path",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "height",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "prove",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/latest": {
      "get": {
        "summary": "GetLatestBlock returns the latest block.",
        "operationId": "GetLatestBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "block": {
                  "title": "Deprecated: please use `sdk_block` instead",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                },
                "sdk_block": {
                  "title": "Since: cosmos-sdk 0.47",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  },
                  "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
                }
              },
              "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
      "get": {
        "summary": "GetBlockByHeight queries block for given height.",
        "operationId": "GetBlockByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "block": {
                  "title": "Deprecated: please use `sdk_block` instead",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                },
                "sdk_block": {
                  "title": "Since: cosmos-sdk 0.47",
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                        }
                      },
                      "description": "Header defines the structure of a Tendermint block header."
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "txs": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "byte"
                          },
                          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                        }
                      },
                      "title": "Data contains the set of transactions included in the block"
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "evidence": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "duplicate_vote_evidence": {
                                "type": "object",
                                "properties": {
                                  "vote_a": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "vote_b": {
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "type": "string",
                                        "enum": [
                                          "SIGNED_MSG_TYPE_UNKNOWN",
                                          "SIGNED_MSG_TYPE_PREVOTE",
                                          "SIGNED_MSG_TYPE_PRECOMMIT",
                                          "SIGNED_MSG_TYPE_PROPOSAL"
                                        ],
                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "validator_address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validator_index": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "signature": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "validator_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                              },
                              "light_client_attack_evidence": {
                                "type": "object",
                                "properties": {
                                  "conflicting_block": {
                                    "type": "object",
                                    "properties": {
                                      "signed_header": {
                                        "type": "object",
                                        "properties": {
                                          "header": {
                                            "type": "object",
                                            "properties": {
                                              "version": {
                                                "title": "basic block info",
                                                "type": "object",
                                                "properties": {
                                                  "block": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  },
                                                  "app": {
                                                    "type": "string",
                                                    "format": "uint64"
                                                  }
                                                },
                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                              },
                                              "chain_id": {
                                                "type": "string"
                                              },
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "time": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "last_block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "last_commit_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes of block data"
                                              },
                                              "data_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "validators_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "hashes from the app output from the prev block"
                                              },
                                              "next_validators_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "consensus_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "app_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "last_results_hash": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "evidence_hash": {
                                                "type": "string",
                                                "format": "byte",
                                                "title": "consensus info"
                                              },
                                              "proposer_address": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "Header defines the structure of a block header."
                                          },
                                          "commit": {
                                            "type": "object",
                                            "properties": {
                                              "height": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "round": {
                                                "type": "integer",
                                                "format": "int32"
                                              },
                                              "block_id": {
                                                "type": "object",
                                                "properties": {
                                                  "hash": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "part_set_header": {
                                                    "type": "object",
                                                    "properties": {
                                                      "total": {
                                                        "type": "integer",
                                                        "format": "int64"
                                                      },
                                                      "hash": {
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    },
                                                    "title": "PartsetHeader"
                                                  }
                                                },
                                                "title": "BlockID"
                                              },
                                              "signatures": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "block_id_flag": {
                                                      "type": "string",
                                                      "enum": [
                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                        "BLOCK_ID_FLAG_ABSENT",
                                                        "BLOCK_ID_FLAG_COMMIT",
                                                        "BLOCK_ID_FLAG_NIL"
                                                      ],
                                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                                    },
                                                    "validator_address": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "timestamp": {
                                                      "type": "string",
                                                      "format": "date-time"
                                                    },
                                                    "signature": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                                }
                                              }
                                            },
                                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                                          }
                                        }
                                      },
                                      "validator_set": {
                                        "type": "object",
                                        "properties": {
                                          "validators": {
                                            "type": "array",
                                            "items": {
                                              "type": "object",
                                              "properties": {
                                                "address": {
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "pub_key": {
                                                  "type": "object",
                                                  "properties": {
                                                    "ed25519": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "secp256k1": {
                                                      "type": "string",
                                                      "format": "byte"
                                                    }
                                                  },
                                                  "title": "PublicKey defines the keys available for use with Validators"
                                                },
                                                "voting_power": {
                                                  "type": "string",
                                                  "format": "int64"
                                                },
                                                "proposer_priority": {
                                                  "type": "string",
                                                  "format": "int64"
                                                }
                                              }
                                            }
                                          },
                                          "proposer": {
                                            "type": "object",
                                            "properties": {
                                              "address": {
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                  "ed25519": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "secp256k1": {
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "title": "PublicKey defines the keys available for use with Validators"
                                              },
                                              "voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              },
                                              "proposer_priority": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          },
                                          "total_voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    }
                                  },
                                  "common_height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "byzantine_validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                },
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                              }
                            }
                          }
                        }
                      }
                    },
                    "last_commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  },
                  "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
                }
              },
              "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/node_info": {
      "get": {
        "summary": "GetNodeInfo queries the current node info.",
        "operationId": "GetNodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "default_node_info": {
                  "type": "object",
                  "properties": {
                    "protocol_version": {
                      "type": "object",
                      "properties": {
                        "p2p": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "block": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "app": {
                          "type": "string",
                          "format": "uint64"
                        }
                      }
                    },
                    "default_node_id": {
                      "type": "string"
                    },
                    "listen_addr": {
                      "type": "string"
                    },
                    "network": {
                      "type": "string"
                    },
                    "version": {
                      "type": "string"
                    },
                    "channels": {
                      "type": "string",
                      "format": "byte"
                    },
                    "moniker": {
                      "type": "string"
                    },
                    "other": {
                      "type": "object",
                      "properties": {
                        "tx_index": {
                          "type": "string"
                        },
                        "rpc_address": {
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "application_version": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "app_name": {
                      "type": "string"
                    },
                    "version": {
                      "type": "string"
                    },
                    "git_commit": {
                      "type": "string"
                    },
                    "build_tags": {
                      "type": "string"
                    },
                    "go_version": {
                      "type": "string"
                    },
                    "build_deps": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "path": {
                            "type": "string",
                            "title": "module path"
                          },
                          "version": {
                            "type": "string",
                            "title": "module version"
                          },
                          "sum": {
                            "type": "string",
                            "title": "checksum"
                          }
                        },
                        "title": "Module is the type for VersionInfo"
                      }
                    },
                    "cosmos_sdk_version": {
                      "type": "string",
                      "title": "Since: cosmos-sdk 0.43"
                    }
                  },
                  "description": "VersionInfo is the type for the GetNodeInfoResponse message."
                }
              },
              "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/syncing": {
      "get": {
        "summary": "GetSyncing queries node syncing.",
        "operationId": "GetSyncing",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "syncing": {
                  "type": "boolean"
                }
              },
              "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
      "get": {
        "summary": "GetLatestValidatorSet queries latest validator-set.",
        "operationId": "GetLatestValidatorSet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string",
                  "format": "int64"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "Validator is the type for the validator-set."
                  }
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
      "get": {
        "summary": "GetValidatorSetByHeight queries validator-set at a given height.",
        "operationId": "GetValidatorSetByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "block_height": {
                  "type": "string",
                  "format": "int64"
                },
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "Validator is the type for the validator-set."
                  }
                },
                "pagination": {
                  "description": "pagination defines an pagination for the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Service"
        ]
      }
    },
    "/exocore/dogfood/v1/operator_opt_out_finish_epoch/{operator_acc_addr}": {
      "get": {
        "summary": "OperatorOptOutFinishEpoch queries the epoch when the operator's opt-out will finish.",
        "operationId": "OperatorOptOutFinishEpoch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "epoch": {
                  "type": "string",
                  "format": "int64",
                  "description": "epoch is the epoch when the operator's opt-out will finish."
                }
              },
              "description": "QueryOperatorOptOutFinishEpochResponse is response type for the\nQuery/OperatorOptOutFinishEpoch RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_acc_addr",
            "description": "operator_acc_addr is the operator account address.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/dogfood/v1/opt_outs_to_finish/{epoch}": {
      "get": {
        "summary": "OptOutsToFinish queries the operators whose opt-outs will finish at the given epoch.",
        "operationId": "OptOutsToFinish",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "list": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "list is the list of account addresses."
                }
              },
              "description": "AccountAddresses represents a list of account addresses. It is used to store the list of\noperator addresses whose operations are maturing at an epoch."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "epoch",
            "description": "epoch is the epoch to query opt-outs for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/dogfood/v1/params": {
      "get": {
        "summary": "Params queries the parameters of the module.",
        "operationId": "DogfoodParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "epochs_until_unbonded": {
                      "type": "integer",
                      "format": "int64",
                      "description": "EpochsUntilUnbonded is the number of epochs after which an unbonding\nis released. Note that it starts from the beginning of the next epoch\nin which the unbonding request was received. At that point, the vote\npower is reduced by the amount of the unbonding operation."
                    },
                    "epoch_identifier": {
                      "type": "string",
                      "description": "EpochIdentifier is the identifier of the epoch (week, hour, day)."
                    },
                    "max_validators": {
                      "type": "integer",
                      "format": "int64",
                      "description": "MaxValidators is the maximum number of validators."
                    },
                    "historical_entries": {
                      "type": "integer",
                      "format": "int64",
                      "description": "HistoricalEntries is the number of historical entries to persist."
                    },
                    "asset_ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "AssetIDs is the ids of the assets which will be accepted by the module.\nIt must be within the list of assets supported by the restaking module.\nThe typical format of these IDs is\nlower(assetAddress) + _ + hex(clientChainLzID)"
                    },
                    "min_self_delegation": {
                      "type": "string",
                      "description": "MinSelfDelegation is the minimum self delegation in USD required to be a validator."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/dogfood/v1/undelegation_maturity_epoch/{record_key}": {
      "get": {
        "summary": "UndelegationMaturityEpoch queries the epoch when the undelegation will mature.",
        "operationId": "UndelegationMaturityEpoch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "epoch": {
                  "type": "string",
                  "format": "int64",
                  "description": "epoch is the epoch when the undelegation will mature."
                }
              },
              "description": "QueryUndelegationMaturityEpochResponse is response type for the\nQuery/UndelegationMaturityEpoch RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "record_key",
            "description": "record_key is the undelegation record key. note that the UndelegationRecordKey used by the\ndelegation module is just a string converted to bytes, which we will reverse here.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/dogfood/v1/undelegations_to_mature/{epoch}": {
      "get": {
        "summary": "UndelegationsToMature queries the undelegations that will mature at the given epoch.",
        "operationId": "UndelegationsToMature",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "list": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "list is the list of undelegation record keys."
                }
              },
              "description": "UndelegationRecordKeys is a collection of undelegation record keys. This is used to store a\nlist of undelegation records to mature in the delegation module at the end of the epoch."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "epoch",
            "description": "epoch is the epoch to query undelegations for.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/dogfood/v1/validator/{cons_addr}": {
      "get": {
        "summary": "QueryValidator queries the validator for the given consensus address.",
        "operationId": "QueryValidator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "format": "byte",
                  "description": "The address, as derived from the consensus key. It has no relation\nwith the operator's account address."
                },
                "power": {
                  "type": "string",
                  "format": "int64",
                  "title": "Last known power"
                },
                "pubkey": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "ExocoreValidator is a validator that is part of the Exocore network. It is\nused to validate and sign blocks."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "cons_addr",
            "description": "cons_addr is the consensus address of the validator being queried. From the perspective of\nthis module, the acc_addr is not relevant and is thus not stored.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/Params": {
      "get": {
        "summary": "Params retrieves the assets module params",
        "operationId": "AssetsParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters for this module.",
                  "type": "object",
                  "properties": {
                    "exocore_lz_app_address": {
                      "type": "string",
                      "description": "exocore_lz_app_address is the address of ExocoreGateway.sol."
                    },
                    "exocore_lz_app_event_topic": {
                      "type": "string",
                      "description": "exocore_lz_app_event_topic is the topic of the exocore lz app event."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueAllClientChainInfo": {
      "get": {
        "summary": "AllClientChainInfo queries all client chain info.",
        "operationId": "QueAllClientChainInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "all_client_chain_infos": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "name of the client chain, like \"Ethereum\"."
                      },
                      "meta_info": {
                        "type": "string",
                        "description": "meta_info about the client chain, like \"Ethereum blockchain\"."
                      },
                      "chain_id": {
                        "type": "string",
                        "format": "uint64",
                        "description": "chain_id of the client chain. Not necessarily the EVM chain id."
                      },
                      "exocore_chain_index": {
                        "type": "string",
                        "format": "uint64",
                        "description": "exocore_chain_index is the index of the client chain within the exosystem."
                      },
                      "finalization_blocks": {
                        "type": "string",
                        "format": "uint64",
                        "description": "finalization_blocks is the number of blocks to wait for finalization."
                      },
                      "layer_zero_chain_id": {
                        "type": "string",
                        "format": "uint64",
                        "title": "layer_zero_chain_id is the chain id of the client chain, according to L0.\nhttps://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids"
                      },
                      "signature_type": {
                        "type": "string",
                        "description": "signature_type is the type of signature used to sign the client chain address."
                      },
                      "address_length": {
                        "type": "integer",
                        "format": "int64",
                        "description": "client_chain_addr is the length of addresses on the client chain."
                      }
                    },
                    "description": "ClientChainInfo defines the client chain information."
                  },
                  "description": "all_client_chain_infos is a list of all client chain info."
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllClientChainInfoResponse is the response for all client chains info."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueAllStakingAssetsInfo": {
      "get": {
        "summary": "AllStakingAssetsInfo queries all staking assets info.",
        "operationId": "QueAllStakingAssetsInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "all_staking_assets_info": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "asset_basic_info": {
                        "description": "asset_basic_info is the basic information of the asset.",
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string",
                            "title": "name of the asset, like \"Tether USD\""
                          },
                          "symbol": {
                            "type": "string",
                            "title": "symbol of the asset, like \"USDT\""
                          },
                          "address": {
                            "type": "string",
                            "title": "address of the asset on the client chain"
                          },
                          "decimals": {
                            "type": "integer",
                            "format": "int64",
                            "description": "decimals used in the asset, typically 6 or 18."
                          },
                          "layer_zero_chain_id": {
                            "type": "string",
                            "format": "uint64",
                            "description": "layer_zero_chain_id is the chain id of the asset, according to L0."
                          },
                          "exocore_chain_index": {
                            "type": "string",
                            "format": "uint64",
                            "description": "exocore_chain_index is the index of the client chain within the exosystem."
                          },
                          "meta_info": {
                            "type": "string",
                            "description": "meta_info about the asset, like \"Tether USD on Ethereum blockchain\"."
                          }
                        }
                      },
                      "staking_total_amount": {
                        "type": "string",
                        "description": "staking_total_amount is the total amount of the asset staked."
                      }
                    },
                    "description": "StakingAssetInfo defines the information for an asset to be used in staking."
                  },
                  "description": "all_staking_assets_info is the response for all staking assets info."
                }
              },
              "description": "QueryAllStakingAssetsInfoResponse is the response for all staking assets info,\nindexed by the asset id."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueClientChainInfoByIndex": {
      "get": {
        "summary": "ClientChainInfoByIndex queries the client chain info by index.",
        "operationId": "QueClientChainInfoByIndex",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "name of the client chain, like \"Ethereum\"."
                },
                "meta_info": {
                  "type": "string",
                  "description": "meta_info about the client chain, like \"Ethereum blockchain\"."
                },
                "chain_id": {
                  "type": "string",
                  "format": "uint64",
                  "description": "chain_id of the client chain. Not necessarily the EVM chain id."
                },
                "exocore_chain_index": {
                  "type": "string",
                  "format": "uint64",
                  "description": "exocore_chain_index is the index of the client chain within the exosystem."
                },
                "finalization_blocks": {
                  "type": "string",
                  "format": "uint64",
                  "description": "finalization_blocks is the number of blocks to wait for finalization."
                },
                "layer_zero_chain_id": {
                  "type": "string",
                  "format": "uint64",
                  "title": "layer_zero_chain_id is the chain id of the client chain, according to L0.\nhttps://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids"
                },
                "signature_type": {
                  "type": "string",
                  "description": "signature_type is the type of signature used to sign the client chain address."
                },
                "address_length": {
                  "type": "integer",
                  "format": "int64",
                  "description": "client_chain_addr is the length of addresses on the client chain."
                }
              },
              "description": "ClientChainInfo defines the client chain information."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "chain_index",
            "description": "chain_index is the index of the chain.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueOperatorAssetInfos": {
      "get": {
        "summary": "OperatorAssetInfos queries the operator asset info.",
        "operationId": "QueOperatorAssetInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "asset_infos": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the id of the asset."
                      },
                      "info": {
                        "description": "info is the asset info.",
                        "type": "object",
                        "properties": {
                          "total_amount": {
                            "type": "string",
                            "description": "total_amount is the total amount of the asset deposited, which excludes the\npending_undelegation_amount. It represent the total delegated amount of asset pool,\nit will be used to calculate the asset amount of a specified staker from its\ndelegated share."
                          },
                          "pending_undelegation_amount": {
                            "type": "string",
                            "description": "pending_undelegation_amount is the amount that is waiting for unbonding."
                          },
                          "total_share": {
                            "type": "string",
                            "description": "total_share is the total share of an asset, in the formula to update the staker's share\nS_j = S * T_j / T, `S` represent it.\nSo when the shares of staker and operator change, it also needs to add `S_j` to update."
                          },
                          "operator_share": {
                            "type": "string",
                            "description": "operator_share is similar to the share of the staker, the calculation and update should\nbe same, the difference is that it represents the share of the operator itself.\nthe field is used to mark operator's own asset share."
                          }
                        }
                      }
                    },
                    "title": "AssetByID is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an operator.\nIt is named AssetByID (since it is indexed by the assetID)"
                  },
                  "description": "asset_infos is the response for the operator asset info, indexed by the asset id."
                }
              },
              "description": "QueryOperatorAssetInfosResponse is the response to the operator asset info query."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueStakerAssetInfos": {
      "get": {
        "summary": "StakerAssetInfos queries the staker asset info.",
        "operationId": "QueStakerAssetInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "asset_infos": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the id of the asset."
                      },
                      "info": {
                        "description": "info is the asset info.",
                        "type": "object",
                        "properties": {
                          "total_deposit_amount": {
                            "type": "string",
                            "description": "total_deposit_amount is the total amount of the asset deposited."
                          },
                          "withdrawable_amount": {
                            "type": "string",
                            "description": "withdrawable_amount is the amount that can be withdrawn."
                          },
                          "pending_undelegation_amount": {
                            "type": "string",
                            "description": "pending_undelegation_amount is the amount that is waiting for undelegation."
                          }
                        }
                      }
                    },
                    "description": "DepositByAsset is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an staker.\nThe info contains the deposit amount, the withdrawable amount\nand the amount currently unbonding.\nIt is named DepositByAsset (since it is indexed by the assetID)\nand not Deposit to prevent conflict with CrossChainOpType."
                  },
                  "description": "asset_infos is the response for the staker asset info, indexed by the asset id."
                }
              },
              "description": "QueryAssetInfoResponse is the response for the staker asset info."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "staker_id",
            "description": "stake_id is the staker id for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueStakerSpecifiedAssetAmount": {
      "get": {
        "summary": "OperatorSpecifiedAssetAmount queries the operator specified asset amount.",
        "operationId": "QueOperatorSpecifiedAssetAmount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "total_amount": {
                  "type": "string",
                  "description": "total_amount is the total amount of the asset deposited, which excludes the\npending_undelegation_amount. It represent the total delegated amount of asset pool,\nit will be used to calculate the asset amount of a specified staker from its\ndelegated share."
                },
                "pending_undelegation_amount": {
                  "type": "string",
                  "description": "pending_undelegation_amount is the amount that is waiting for unbonding."
                },
                "total_share": {
                  "type": "string",
                  "description": "total_share is the total share of an asset, in the formula to update the staker's share\nS_j = S * T_j / T, `S` represent it.\nSo when the shares of staker and operator change, it also needs to add `S_j` to update."
                },
                "operator_share": {
                  "type": "string",
                  "description": "operator_share is similar to the share of the staker, the calculation and update should\nbe same, the difference is that it represents the share of the operator itself.\nthe field is used to mark operator's own asset share."
                }
              },
              "description": "OperatorAssetInfo defines the information for a single asset,\nfor an operator."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "asset_id",
            "description": "asset_id is the asset for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/assets/v1/QueStakingAssetInfo": {
      "get": {
        "summary": "StakingAssetInfo queries the staking asset info.",
        "operationId": "QueStakingAssetInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "asset_basic_info": {
                  "description": "asset_basic_info is the basic information of the asset.",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "title": "name of the asset, like \"Tether USD\""
                    },
                    "symbol": {
                      "type": "string",
                      "title": "symbol of the asset, like \"USDT\""
                    },
                    "address": {
                      "type": "string",
                      "title": "address of the asset on the client chain"
                    },
                    "decimals": {
                      "type": "integer",
                      "format": "int64",
                      "description": "decimals used in the asset, typically 6 or 18."
                    },
                    "layer_zero_chain_id": {
                      "type": "string",
                      "format": "uint64",
                      "description": "layer_zero_chain_id is the chain id of the asset, according to L0."
                    },
                    "exocore_chain_index": {
                      "type": "string",
                      "format": "uint64",
                      "description": "exocore_chain_index is the index of the client chain within the exosystem."
                    },
                    "meta_info": {
                      "type": "string",
                      "description": "meta_info about the asset, like \"Tether USD on Ethereum blockchain\"."
                    }
                  }
                },
                "staking_total_amount": {
                  "type": "string",
                  "description": "staking_total_amount is the total amount of the asset staked."
                }
              },
              "description": "StakingAssetInfo defines the information for an asset to be used in staking."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "asset_id",
            "description": "asset_id is the asset for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/slash/v1/params": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "ExoSlashParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object"
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/index_recent_msg": {
      "get": {
        "summary": "Queries a IndexRecentMsg by index.",
        "operationId": "IndexRecentMsg",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "index_recent_msg": {
                  "title": "index_recent_msg index of cached recent messages",
                  "type": "object",
                  "properties": {
                    "index": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "title": "index list"
                    }
                  }
                }
              },
              "title": "QueryIndexRecentMsgResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/index_recent_params": {
      "get": {
        "summary": "Queries a IndexRecentParams by index.",
        "operationId": "IndexRecentParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "index_recent_params": {
                  "title": "index_recent_params index of cached recent params",
                  "type": "object",
                  "properties": {
                    "index": {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "title": "index list"
                    }
                  }
                }
              },
              "title": "QueryGetIndexRecentParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/latest_price/{token_id}": {
      "get": {
        "summary": "Queries the latest price of a specific token",
        "operationId": "LatestPrice",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "price": {
                  "title": "prices returned prices",
                  "type": "object",
                  "properties": {
                    "price": {
                      "type": "string",
                      "title": "price"
                    },
                    "decimal": {
                      "type": "integer",
                      "format": "int32",
                      "title": "decimal of the corresponding price"
                    },
                    "timestamp": {
                      "type": "string",
                      "title": "timestamp when the price is corresponded"
                    },
                    "round_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "roundid of the price if the source is deteministic"
                    }
                  }
                }
              },
              "title": "QueryGetLatestPriceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "description": "token_id represents which token's price will be retrieved",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/params": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "OracleParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "chains": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string",
                            "title": "eg.\"bitcoin\""
                          },
                          "desc": {
                            "type": "string",
                            "title": "TODO: metadata"
                          }
                        },
                        "title": "Chain represents for the Chain on which token contracts deployed"
                      },
                      "title": "chains represents the blockchains info"
                    },
                    "tokens": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string",
                            "title": "token name"
                          },
                          "chain_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "id refer to chainList's index"
                          },
                          "contract_address": {
                            "type": "string",
                            "title": "if any, like erc20 tokens"
                          },
                          "decimal": {
                            "type": "integer",
                            "format": "int32",
                            "title": "decimal of token price"
                          },
                          "active": {
                            "type": "boolean",
                            "title": "set false when we stop official price oracle service for a specified token"
                          },
                          "asset_id": {
                            "type": "string",
                            "title": "refer to assetID from assets module if exists"
                          }
                        },
                        "title": "Token represents the token info"
                      },
                      "title": "tokens info"
                    },
                    "sources": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "type": "string",
                            "title": "name of price source, like 'chainlink'"
                          },
                          "entry": {
                            "title": "endpoint of corresponding source to fetch price data from",
                            "type": "object",
                            "properties": {
                              "offchain": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                },
                                "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                              },
                              "onchain": {
                                "type": "object",
                                "additionalProperties": {
                                  "type": "string"
                                },
                                "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                              }
                            }
                          },
                          "valid": {
                            "type": "boolean",
                            "title": "set false when the source is out of service or reject to accept this source for official service"
                          },
                          "deterministic": {
                            "type": "boolean",
                            "title": "if this source is deteministic or not"
                          }
                        },
                        "title": "Source represents price data source"
                      },
                      "title": "sources info from where the price data would be fetched"
                    },
                    "rules": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "source_ids": {
                            "type": "array",
                            "items": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                          },
                          "nom": {
                            "title": "n out of total sources are required",
                            "type": "object",
                            "properties": {
                              "source_ids": {
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                              },
                              "minimum": {
                                "type": "string",
                                "format": "uint64",
                                "title": "minimum number from the required sources to be fullfiled"
                              }
                            }
                          }
                        },
                        "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
                      },
                      "title": "rules specified on how to decide the provided price source to be accept"
                    },
                    "token_feeders": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "token_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "refer to params.tokenList, from 1"
                          },
                          "rule_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                          },
                          "start_round_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                          },
                          "start_base_block": {
                            "type": "string",
                            "format": "uint64",
                            "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                          },
                          "interval": {
                            "type": "string",
                            "format": "uint64",
                            "title": "set as count of blocks, for how many blocks interval the price will be update once"
                          },
                          "end_block": {
                            "type": "string",
                            "format": "uint64",
                            "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                          }
                        },
                        "title": "Tokenfeeder represents a price oracle for one token"
                      },
                      "title": "each tokenFeeder represents an active token whose price being updated"
                    },
                    "max_nonce": {
                      "type": "integer",
                      "format": "int32",
                      "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
                    },
                    "threshold_a": {
                      "type": "integer",
                      "format": "int32",
                      "title": "voting power need to reach more than threshold_a/threshold_b"
                    },
                    "threshold_b": {
                      "type": "integer",
                      "format": "int32",
                      "title": "voting power need to reach more than threshold_a/threshold_b"
                    },
                    "mode": {
                      "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
                      "type": "string",
                      "enum": [
                        "CONSENSUS_MODE_UNSPECIFIED",
                        "CONSENSUS_MODE_ASAP"
                      ],
                      "default": "CONSENSUS_MODE_UNSPECIFIED",
                      "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
                    },
                    "max_det_id": {
                      "type": "integer",
                      "format": "int32",
                      "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
                    },
                    "max_size_prices": {
                      "type": "integer",
                      "format": "int32",
                      "title": "for each token, only keep max_size_prices round of prices"
                    },
                    "slashing": {
                      "title": "slashing defines the slashing related params",
                      "type": "object",
                      "properties": {
                        "reported_rounds_window": {
                          "type": "string",
                          "format": "int64",
                          "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                        },
                        "min_reported_per_window": {
                          "type": "string",
                          "format": "byte",
                          "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                        },
                        "oracle_miss_jail_duration": {
                          "type": "string",
                          "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                        },
                        "oracle_malicious_jail_duration": {
                          "type": "string",
                          "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                        },
                        "slash_fraction_miss": {
                          "type": "string",
                          "format": "byte",
                          "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                        },
                        "slash_fraction_malicious": {
                          "type": "string",
                          "format": "byte",
                          "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                        }
                      }
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/prices/{token_id}": {
      "get": {
        "summary": "Queries a list of Prices items.",
        "operationId": "Prices",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "prices": {
                  "title": "prices returned prices",
                  "type": "object",
                  "properties": {
                    "token_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "for which token these prices are"
                    },
                    "next_round_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "next round id of the price to be updated"
                    },
                    "price_list": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "price": {
                            "type": "string",
                            "title": "price"
                          },
                          "decimal": {
                            "type": "integer",
                            "format": "int32",
                            "title": "decimal of the corresponding price"
                          },
                          "timestamp": {
                            "type": "string",
                            "title": "timestamp when the price is corresponded"
                          },
                          "round_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "roundid of the price if the source is deteministic"
                          }
                        },
                        "title": "price with its specified timestamp and roundid(if from deteministic source)"
                      },
                      "title": "price list of all history round prices for the token"
                    }
                  }
                }
              },
              "title": "QueryGetPricesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "token_id",
            "description": "token_id represents which token's price will be retrieved",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/recent_msg": {
      "get": {
        "summary": "RecentMsgAll all RecentMsg items.",
        "operationId": "RecentMsgAll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "recent_msg": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64",
                        "title": "block height these messages from"
                      },
                      "msgs": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "feeder_id": {
                              "type": "string",
                              "format": "uint64",
                              "title": "feeder_id tells of wich feeder this price if corresponding to"
                            },
                            "p_sources": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "source_id": {
                                    "type": "string",
                                    "format": "uint64",
                                    "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
                                  },
                                  "prices": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "price": {
                                          "type": "string",
                                          "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                                        },
                                        "decimal": {
                                          "type": "integer",
                                          "format": "int32",
                                          "title": "decimal of the corresponding price"
                                        },
                                        "timestamp": {
                                          "type": "string",
                                          "title": "timestamp when the price corresponding to"
                                        },
                                        "det_id": {
                                          "type": "string",
                                          "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                                        }
                                      },
                                      "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                                    },
                                    "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
                                  },
                                  "desc": {
                                    "type": "string",
                                    "title": "used for 0-sourceID-customDefinedSource"
                                  }
                                },
                                "title": "price with its corresponding source"
                              },
                              "title": "p_source price with its source info"
                            },
                            "validator": {
                              "type": "string",
                              "title": "validator tells which validator create this price"
                            }
                          },
                          "title": "MsgItem represents the message info of createPrice"
                        },
                        "title": "cached messages"
                      }
                    },
                    "title": "RecentMsg represent the messages to be cached for recent blocks"
                  },
                  "title": "recent_msg represets the cached recent message"
                },
                "pagination": {
                  "title": "info of pagination",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryAllRecentMsgResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/recent_msg/{block}": {
      "get": {
        "summary": "Queries a list of RecentMsg items.",
        "operationId": "RecentMsg",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "recent_msg": {
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64",
                      "title": "block height these messages from"
                    },
                    "msgs": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "feeder_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "feeder_id tells of wich feeder this price if corresponding to"
                          },
                          "p_sources": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "source_id": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
                                },
                                "prices": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "price": {
                                        "type": "string",
                                        "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                                      },
                                      "decimal": {
                                        "type": "integer",
                                        "format": "int32",
                                        "title": "decimal of the corresponding price"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "title": "timestamp when the price corresponding to"
                                      },
                                      "det_id": {
                                        "type": "string",
                                        "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                                      }
                                    },
                                    "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                                  },
                                  "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
                                },
                                "desc": {
                                  "type": "string",
                                  "title": "used for 0-sourceID-customDefinedSource"
                                }
                              },
                              "title": "price with its corresponding source"
                            },
                            "title": "p_source price with its source info"
                          },
                          "validator": {
                            "type": "string",
                            "title": "validator tells which validator create this price"
                          }
                        },
                        "title": "MsgItem represents the message info of createPrice"
                      },
                      "title": "cached messages"
                    }
                  },
                  "title": "RecentMsg represent the messages to be cached for recent blocks"
                }
              },
              "title": "QueryGetRecentMsgResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "block",
            "description": "block represents of which block the cached message query for",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/recent_params": {
      "get": {
        "summary": "RecentParamsAll query all RecentParams.",
        "operationId": "RecentParamsAll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "recent_params": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64",
                        "title": "block height of which the params from"
                      },
                      "params": {
                        "title": "params the module params",
                        "type": "object",
                        "properties": {
                          "chains": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "name": {
                                  "type": "string",
                                  "title": "eg.\"bitcoin\""
                                },
                                "desc": {
                                  "type": "string",
                                  "title": "TODO: metadata"
                                }
                              },
                              "title": "Chain represents for the Chain on which token contracts deployed"
                            },
                            "title": "chains represents the blockchains info"
                          },
                          "tokens": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "name": {
                                  "type": "string",
                                  "title": "token name"
                                },
                                "chain_id": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "id refer to chainList's index"
                                },
                                "contract_address": {
                                  "type": "string",
                                  "title": "if any, like erc20 tokens"
                                },
                                "decimal": {
                                  "type": "integer",
                                  "format": "int32",
                                  "title": "decimal of token price"
                                },
                                "active": {
                                  "type": "boolean",
                                  "title": "set false when we stop official price oracle service for a specified token"
                                },
                                "asset_id": {
                                  "type": "string",
                                  "title": "refer to assetID from assets module if exists"
                                }
                              },
                              "title": "Token represents the token info"
                            },
                            "title": "tokens info"
                          },
                          "sources": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "name": {
                                  "type": "string",
                                  "title": "name of price source, like 'chainlink'"
                                },
                                "entry": {
                                  "title": "endpoint of corresponding source to fetch price data from",
                                  "type": "object",
                                  "properties": {
                                    "offchain": {
                                      "type": "object",
                                      "additionalProperties": {
                                        "type": "string"
                                      },
                                      "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                                    },
                                    "onchain": {
                                      "type": "object",
                                      "additionalProperties": {
                                        "type": "string"
                                      },
                                      "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                                    }
                                  }
                                },
                                "valid": {
                                  "type": "boolean",
                                  "title": "set false when the source is out of service or reject to accept this source for official service"
                                },
                                "deterministic": {
                                  "type": "boolean",
                                  "title": "if this source is deteministic or not"
                                }
                              },
                              "title": "Source represents price data source"
                            },
                            "title": "sources info from where the price data would be fetched"
                          },
                          "rules": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "source_ids": {
                                  "type": "array",
                                  "items": {
                                    "type": "string",
                                    "format": "uint64"
                                  },
                                  "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                                },
                                "nom": {
                                  "title": "n out of total sources are required",
                                  "type": "object",
                                  "properties": {
                                    "source_ids": {
                                      "type": "array",
                                      "items": {
                                        "type": "string",
                                        "format": "uint64"
                                      },
                                      "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                                    },
                                    "minimum": {
                                      "type": "string",
                                      "format": "uint64",
                                      "title": "minimum number from the required sources to be fullfiled"
                                    }
                                  }
                                }
                              },
                              "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
                            },
                            "title": "rules specified on how to decide the provided price source to be accept"
                          },
                          "token_feeders": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "token_id": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "refer to params.tokenList, from 1"
                                },
                                "rule_id": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                                },
                                "start_round_id": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                                },
                                "start_base_block": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                                },
                                "interval": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "set as count of blocks, for how many blocks interval the price will be update once"
                                },
                                "end_block": {
                                  "type": "string",
                                  "format": "uint64",
                                  "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                                }
                              },
                              "title": "Tokenfeeder represents a price oracle for one token"
                            },
                            "title": "each tokenFeeder represents an active token whose price being updated"
                          },
                          "max_nonce": {
                            "type": "integer",
                            "format": "int32",
                            "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
                          },
                          "threshold_a": {
                            "type": "integer",
                            "format": "int32",
                            "title": "voting power need to reach more than threshold_a/threshold_b"
                          },
                          "threshold_b": {
                            "type": "integer",
                            "format": "int32",
                            "title": "voting power need to reach more than threshold_a/threshold_b"
                          },
                          "mode": {
                            "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
                            "type": "string",
                            "enum": [
                              "CONSENSUS_MODE_UNSPECIFIED",
                              "CONSENSUS_MODE_ASAP"
                            ],
                            "default": "CONSENSUS_MODE_UNSPECIFIED",
                            "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
                          },
                          "max_det_id": {
                            "type": "integer",
                            "format": "int32",
                            "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
                          },
                          "max_size_prices": {
                            "type": "integer",
                            "format": "int32",
                            "title": "for each token, only keep max_size_prices round of prices"
                          },
                          "slashing": {
                            "title": "slashing defines the slashing related params",
                            "type": "object",
                            "properties": {
                              "reported_rounds_window": {
                                "type": "string",
                                "format": "int64",
                                "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                              },
                              "min_reported_per_window": {
                                "type": "string",
                                "format": "byte",
                                "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                              },
                              "oracle_miss_jail_duration": {
                                "type": "string",
                                "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                              },
                              "oracle_malicious_jail_duration": {
                                "type": "string",
                                "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                              },
                              "slash_fraction_miss": {
                                "type": "string",
                                "format": "byte",
                                "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                              },
                              "slash_fraction_malicious": {
                                "type": "string",
                                "format": "byte",
                                "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                              }
                            }
                          }
                        },
                        "description": "Params defines the parameters for the module."
                      }
                    },
                    "title": "RecentParams represents the params cached for recent blocks"
                  },
                  "title": "recent_params cached recent params"
                },
                "pagination": {
                  "title": "info of pagination",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  },
                  "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                }
              },
              "title": "QueryAllRecentParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/recent_params/{block}": {
      "get": {
        "summary": "Queries a list of RecentParams items.",
        "operationId": "RecentParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "recent_params": {
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64",
                      "title": "block height of which the params from"
                    },
                    "params": {
                      "title": "params the module params",
                      "type": "object",
                      "properties": {
                        "chains": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "name": {
                                "type": "string",
                                "title": "eg.\"bitcoin\""
                              },
                              "desc": {
                                "type": "string",
                                "title": "TODO: metadata"
                              }
                            },
                            "title": "Chain represents for the Chain on which token contracts deployed"
                          },
                          "title": "chains represents the blockchains info"
                        },
                        "tokens": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "name": {
                                "type": "string",
                                "title": "token name"
                              },
                              "chain_id": {
                                "type": "string",
                                "format": "uint64",
                                "title": "id refer to chainList's index"
                              },
                              "contract_address": {
                                "type": "string",
                                "title": "if any, like erc20 tokens"
                              },
                              "decimal": {
                                "type": "integer",
                                "format": "int32",
                                "title": "decimal of token price"
                              },
                              "active": {
                                "type": "boolean",
                                "title": "set false when we stop official price oracle service for a specified token"
                              },
                              "asset_id": {
                                "type": "string",
                                "title": "refer to assetID from assets module if exists"
                              }
                            },
                            "title": "Token represents the token info"
                          },
                          "title": "tokens info"
                        },
                        "sources": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "name": {
                                "type": "string",
                                "title": "name of price source, like 'chainlink'"
                              },
                              "entry": {
                                "title": "endpoint of corresponding source to fetch price data from",
                                "type": "object",
                                "properties": {
                                  "offchain": {
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    },
                                    "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                                  },
                                  "onchain": {
                                    "type": "object",
                                    "additionalProperties": {
                                      "type": "string"
                                    },
                                    "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                                  }
                                }
                              },
                              "valid": {
                                "type": "boolean",
                                "title": "set false when the source is out of service or reject to accept this source for official service"
                              },
                              "deterministic": {
                                "type": "boolean",
                                "title": "if this source is deteministic or not"
                              }
                            },
                            "title": "Source represents price data source"
                          },
                          "title": "sources info from where the price data would be fetched"
                        },
                        "rules": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "source_ids": {
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                              },
                              "nom": {
                                "title": "n out of total sources are required",
                                "type": "object",
                                "properties": {
                                  "source_ids": {
                                    "type": "array",
                                    "items": {
                                      "type": "string",
                                      "format": "uint64"
                                    },
                                    "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                                  },
                                  "minimum": {
                                    "type": "string",
                                    "format": "uint64",
                                    "title": "minimum number from the required sources to be fullfiled"
                                  }
                                }
                              }
                            },
                            "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
                          },
                          "title": "rules specified on how to decide the provided price source to be accept"
                        },
                        "token_feeders": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "token_id": {
                                "type": "string",
                                "format": "uint64",
                                "title": "refer to params.tokenList, from 1"
                              },
                              "rule_id": {
                                "type": "string",
                                "format": "uint64",
                                "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                              },
                              "start_round_id": {
                                "type": "string",
                                "format": "uint64",
                                "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                              },
                              "start_base_block": {
                                "type": "string",
                                "format": "uint64",
                                "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                              },
                              "interval": {
                                "type": "string",
                                "format": "uint64",
                                "title": "set as count of blocks, for how many blocks interval the price will be update once"
                              },
                              "end_block": {
                                "type": "string",
                                "format": "uint64",
                                "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                              }
                            },
                            "title": "Tokenfeeder represents a price oracle for one token"
                          },
                          "title": "each tokenFeeder represents an active token whose price being updated"
                        },
                        "max_nonce": {
                          "type": "integer",
                          "format": "int32",
                          "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
                        },
                        "threshold_a": {
                          "type": "integer",
                          "format": "int32",
                          "title": "voting power need to reach more than threshold_a/threshold_b"
                        },
                        "threshold_b": {
                          "type": "integer",
                          "format": "int32",
                          "title": "voting power need to reach more than threshold_a/threshold_b"
                        },
                        "mode": {
                          "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
                          "type": "string",
                          "enum": [
                            "CONSENSUS_MODE_UNSPECIFIED",
                            "CONSENSUS_MODE_ASAP"
                          ],
                          "default": "CONSENSUS_MODE_UNSPECIFIED",
                          "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
                        },
                        "max_det_id": {
                          "type": "integer",
                          "format": "int32",
                          "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
                        },
                        "max_size_prices": {
                          "type": "integer",
                          "format": "int32",
                          "title": "for each token, only keep max_size_prices round of prices"
                        },
                        "slashing": {
                          "title": "slashing defines the slashing related params",
                          "type": "object",
                          "properties": {
                            "reported_rounds_window": {
                              "type": "string",
                              "format": "int64",
                              "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                            },
                            "min_reported_per_window": {
                              "type": "string",
                              "format": "byte",
                              "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                            },
                            "oracle_miss_jail_duration": {
                              "type": "string",
                              "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                            },
                            "oracle_malicious_jail_duration": {
                              "type": "string",
                              "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                            },
                            "slash_fraction_miss": {
                              "type": "string",
                              "format": "byte",
                              "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                            },
                            "slash_fraction_malicious": {
                              "type": "string",
                              "format": "byte",
                              "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                            }
                          }
                        }
                      },
                      "description": "Params defines the parameters for the module."
                    }
                  },
                  "title": "RecentParams represents the params cached for recent blocks"
                }
              },
              "title": "QueryGetRecentParamsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "block",
            "description": "block represents of which block the cached params from",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/staker_info/{asset_id}/{staker_addr}": {
      "get": {
        "summary": "StakerInfo shows the details for one staker required by input parsms of the specified asset",
        "operationId": "StakerInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "staker_info": {
                  "title": "all staker infos under the specified asset",
                  "type": "object",
                  "properties": {
                    "staker_addr": {
                      "type": "string",
                      "title": "staker's address"
                    },
                    "staker_index": {
                      "type": "string",
                      "format": "int64",
                      "title": "the index of corresponding staker in staker list"
                    },
                    "validator_pubkey_list": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of validators that this staker corresponding to on beacon chain"
                    },
                    "balance_list": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "round_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "current round of price, this is updated based on tokenFeeder"
                          },
                          "block": {
                            "type": "string",
                            "format": "uint64",
                            "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
                          },
                          "index": {
                            "type": "string",
                            "format": "uint64",
                            "title": "index used to distinguish multiple balanceInfo for one same roundid"
                          },
                          "balance": {
                            "type": "string",
                            "format": "int64",
                            "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
                          },
                          "change": {
                            "title": "change tells the reason balance changed",
                            "type": "string",
                            "enum": [
                              "ACTION_ROUND_UNSPECIFIED",
                              "ACTION_DEPOSIT",
                              "ACTION_WITHDRAW",
                              "ACTION_SLASH_REFUND"
                            ],
                            "default": "ACTION_ROUND_UNSPECIFIED",
                            "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
                          }
                        },
                        "title": "BalanceInfo tells effective-balance for native-restaking asset"
                      },
                      "title": "list of balances to represets the history of this staker"
                    }
                  }
                }
              },
              "title": "QueryStakerInfoResponse is response type for Query/StakerInfo RCP method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "asset_id",
            "description": "asset id for the staker info request for",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "staker_addr",
            "description": "staker_addr is the staker address",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/staker_infos/{asset_id}": {
      "get": {
        "summary": "StakerInfos shows the details for all stakers of the specified assets under native-restaking context",
        "operationId": "StakerInfos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "staker_infos": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "staker_addr": {
                        "type": "string",
                        "title": "staker's address"
                      },
                      "staker_index": {
                        "type": "string",
                        "format": "int64",
                        "title": "the index of corresponding staker in staker list"
                      },
                      "validator_pubkey_list": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        },
                        "title": "list of validators that this staker corresponding to on beacon chain"
                      },
                      "balance_list": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "round_id": {
                              "type": "string",
                              "format": "uint64",
                              "title": "current round of price, this is updated based on tokenFeeder"
                            },
                            "block": {
                              "type": "string",
                              "format": "uint64",
                              "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
                            },
                            "index": {
                              "type": "string",
                              "format": "uint64",
                              "title": "index used to distinguish multiple balanceInfo for one same roundid"
                            },
                            "balance": {
                              "type": "string",
                              "format": "int64",
                              "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
                            },
                            "change": {
                              "title": "change tells the reason balance changed",
                              "type": "string",
                              "enum": [
                                "ACTION_ROUND_UNSPECIFIED",
                                "ACTION_DEPOSIT",
                                "ACTION_WITHDRAW",
                                "ACTION_SLASH_REFUND"
                              ],
                              "default": "ACTION_ROUND_UNSPECIFIED",
                              "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
                            }
                          },
                          "title": "BalanceInfo tells effective-balance for native-restaking asset"
                        },
                        "title": "list of balances to represets the history of this staker"
                      }
                    },
                    "title": "StakerInfo represents all related information for a staker of native-restaking"
                  },
                  "title": "all staker infos under the specified asset"
                }
              },
              "title": "QueryStakerInfosResponse is response type for Query/StakerInfo RCP method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "asset_id",
            "description": "asset id for the staker info request for",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/staker_list": {
      "get": {
        "summary": "StakerList shows all stakers related to the specified asset under native-restaking context",
        "operationId": "StakerList",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "staker_list": {
                  "title": "staker list including all stakers of request asset",
                  "type": "object",
                  "properties": {
                    "staker_addrs": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "staker's address"
                    }
                  }
                }
              },
              "title": "QueryStakerListResponse is response type for Query/StakerList RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "asset_id",
            "description": "id of assets for the staker list request for.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/token_indexes": {
      "get": {
        "summary": "TokenIndexes shows the map tells token and its index for further usage",
        "operationId": "TokenIndexes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "token_indexes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "token": {
                        "type": "string",
                        "title": "token name"
                      },
                      "index": {
                        "type": "string",
                        "format": "uint64",
                        "title": "the index registered in params.Token"
                      }
                    },
                    "title": "TokenIndex is the pair of tokenName and its index defined in params"
                  },
                  "title": "token_indexes includes all the token-index mapping"
                }
              },
              "title": "QueryTokenIndexesResponse is response type for Query/TokenIndexes RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/oracle/v1/validator_update_block": {
      "get": {
        "summary": "Queries a ValidatorUpdateBlock by index.",
        "operationId": "ValidatorUpdateBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator_update_block": {
                  "title": "ValidatorUpdateBlock tells the latest block on which the valdiator set was updated",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64",
                      "title": "block height on which the validator set changed"
                    }
                  }
                }
              },
              "title": "QueryGetValidatorUpdateBlockResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/exomint/v1/Params": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "ExomintParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "mint_denom": {
                      "type": "string",
                      "title": "mint_denom is the denomination of the minted coin"
                    },
                    "epoch_reward": {
                      "type": "string",
                      "description": "epoch_reward is the reward minted by the module, per epoch. note that\nthis is in addition to any other fees that are collected, or rewards\nthat are minted."
                    },
                    "epoch_identifier": {
                      "type": "string",
                      "description": "epoch_identifier is the epoch identifier used to determine when to mint\nthe reward."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/feedistribution/v1/params": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "FeeDistributionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object",
                  "properties": {
                    "epoch_identifier": {
                      "type": "string",
                      "title": "epoch_identifier for fee distribution"
                    },
                    "community_tax": {
                      "type": "string",
                      "title": "community_tax is the tax defined for allocation"
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/GetDelegationInfo": {
      "get": {
        "summary": "DelegationInfo queries the delegation information for {stakerID, assetID}.",
        "operationId": "QueryDelegationInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "delegation_infos": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "properties": {
                      "undelegatable_share": {
                        "type": "string",
                        "description": "undelegatable_share is the share that can be undelegated.\nIt's to reduce the state updating when slash occurs.\nS_j = S * T_j / T, `S` and `T` is the current asset share and amount of operator,\nand the T_j represents the change in staker's asset amount when some external\noperations occur, such as: delegation, undelegation and slashing.\nS_j represents the change in the staker's asset share,\nso the updated share should be added by it.\nA special case is the initial delegation, when T = 0 and S = 0, so T_j / T is undefined.\nFor the initial delegation, delegator j who delegates T_j tokens receive S_j = T_j shares."
                      },
                      "wait_undelegation_amount": {
                        "type": "string",
                        "description": "wait_undelegation_amount is the amount that is waiting to be unbonded."
                      }
                    },
                    "description": "DelegationAmounts is the delegation amount response for a single delegation."
                  },
                  "description": "delegation_infos is the delegation information for each operator."
                }
              },
              "description": "QueryDelegationInfoResponse is the response for delegations by staker id and\nasset id."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "staker_id",
            "description": "staker_id is the staker id.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "asset_id",
            "description": "asset_id is the asset id.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QueryAssociatedOperatorByStaker": {
      "get": {
        "summary": "QueryAssociatedOperatorByStaker queries the associated operator for the specified staker",
        "operationId": "QueryAssociatedOperatorByStaker",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "operator": {
                  "type": "string",
                  "title": "operator is the returned operator owner of the specified staker"
                }
              },
              "title": "QueryAssociatedOperatorByStakerResponse is the response to QueryAssociatedOperatorByStakerReq"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "staker_id",
            "description": "stake_id is the staker id for which the query is made.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QueryAssociatedStakersByOperator/{operator}": {
      "get": {
        "summary": "QueryAssociatedStakersByOperator queries the associated stakers for the specified operator",
        "operationId": "QueryAssociatedStakersByOperator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "stakers": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "stakers is the returned stakers associated to the specified operator"
                }
              },
              "title": "QueryAssociatedStakersByOperatorResponse is the response to QueryAssociatedStakersByOperatorReq"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator",
            "description": "operator is the operator address for which the query is made.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QuerySingleDelegationInfo": {
      "get": {
        "summary": "SingleDelegationInfo queries the single delegation information for\n{chain, staker, asset, operator}.",
        "operationId": "QuerySingleDelegationInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "undelegatable_share": {
                  "type": "string",
                  "description": "undelegatable_share is the share that can be undelegated.\nIt's to reduce the state updating when slash occurs.\nS_j = S * T_j / T, `S` and `T` is the current asset share and amount of operator,\nand the T_j represents the change in staker's asset amount when some external\noperations occur, such as: delegation, undelegation and slashing.\nS_j represents the change in the staker's asset share,\nso the updated share should be added by it.\nA special case is the initial delegation, when T = 0 and S = 0, so T_j / T is undefined.\nFor the initial delegation, delegator j who delegates T_j tokens receive S_j = T_j shares."
                },
                "wait_undelegation_amount": {
                  "type": "string",
                  "description": "wait_undelegation_amount is the amount that is waiting to be unbonded."
                }
              },
              "description": "DelegationAmounts is the delegation amount response for a single delegation."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "staker_id",
            "description": "staker_id is the staker id.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "asset_id",
            "description": "asset_id is the asset id.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QueryUndelegationHoldCount/{record_key}": {
      "get": {
        "summary": "QueryUndelegationHoldCount queries the undelegation hold count.",
        "operationId": "QueryUndelegationHoldCount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "hold_count": {
                  "type": "string",
                  "format": "uint64",
                  "description": "hold_count is the number of undelegations that are on hold."
                }
              },
              "description": "UndelegationHoldCountResponse is the response for the undelegation hold count."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "record_key",
            "description": "record_key is the record key of the undelegation record.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QueryUndelegations": {
      "get": {
        "summary": "QueryUndelegations queries all undelegations for\n{staker, asset}.",
        "operationId": "QueryUndelegations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "undelegations": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "staker_id": {
                        "type": "string",
                        "description": "staker_id is the staker id."
                      },
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the asset id."
                      },
                      "operator_addr": {
                        "type": "string",
                        "description": "operator_addr is the operator address."
                      },
                      "tx_hash": {
                        "type": "string",
                        "description": "tx_hash is the transaction hash on the client chain."
                      },
                      "is_pending": {
                        "type": "boolean",
                        "description": "is_pending is the flag to indicate if the undelegation is pending."
                      },
                      "block_number": {
                        "type": "string",
                        "format": "uint64",
                        "description": "block_number is the block number on Exocore."
                      },
                      "complete_block_number": {
                        "type": "string",
                        "format": "uint64",
                        "description": "complete_block_number is the block number on Exocore at which the undelegation\nshould be completed."
                      },
                      "lz_tx_nonce": {
                        "type": "string",
                        "format": "uint64",
                        "description": "lz_tx_nonce is the nonce of the transaction on the client chain."
                      },
                      "amount": {
                        "type": "string",
                        "description": "amount is the amount of the asset to be undelegated."
                      },
                      "actual_completed_amount": {
                        "type": "string",
                        "description": "actual_completed_amount is the actual amount of the asset that has been\nundelegated so far. it may be lower than the amount in the case of slashing."
                      }
                    },
                    "description": "UndelegationRecord is the undelegation record, keyed by a RecordKey."
                  },
                  "title": "UndelegationRecord is the returned undelegations"
                }
              },
              "description": "UndelegationRecordList is the response to query undelegations."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "staker_id",
            "description": "staker_id is the staker id.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "asset_id",
            "description": "asset_id is the asset id.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/delegation/v1/QueryUndelegationsByHeight": {
      "get": {
        "summary": "QueryUndelegationsByHeight queries all undelegations waiting to be completed by\n{height}.",
        "operationId": "QueryUndelegationsByHeight",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "undelegations": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "staker_id": {
                        "type": "string",
                        "description": "staker_id is the staker id."
                      },
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the asset id."
                      },
                      "operator_addr": {
                        "type": "string",
                        "description": "operator_addr is the operator address."
                      },
                      "tx_hash": {
                        "type": "string",
                        "description": "tx_hash is the transaction hash on the client chain."
                      },
                      "is_pending": {
                        "type": "boolean",
                        "description": "is_pending is the flag to indicate if the undelegation is pending."
                      },
                      "block_number": {
                        "type": "string",
                        "format": "uint64",
                        "description": "block_number is the block number on Exocore."
                      },
                      "complete_block_number": {
                        "type": "string",
                        "format": "uint64",
                        "description": "complete_block_number is the block number on Exocore at which the undelegation\nshould be completed."
                      },
                      "lz_tx_nonce": {
                        "type": "string",
                        "format": "uint64",
                        "description": "lz_tx_nonce is the nonce of the transaction on the client chain."
                      },
                      "amount": {
                        "type": "string",
                        "description": "amount is the amount of the asset to be undelegated."
                      },
                      "actual_completed_amount": {
                        "type": "string",
                        "description": "actual_completed_amount is the actual amount of the asset that has been\nundelegated so far. it may be lower than the amount in the case of slashing."
                      }
                    },
                    "description": "UndelegationRecord is the undelegation record, keyed by a RecordKey."
                  },
                  "title": "UndelegationRecord is the returned undelegations"
                }
              },
              "description": "UndelegationRecordList is the response to query undelegations."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "block_height",
            "description": "block_height is the block height to query.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/avs/v1/GetAVSTaskInfoReq": {
      "get": {
        "summary": "TaskInfo queries the task information.",
        "operationId": "QueryAVSTaskInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "task_contract_address": {
                  "type": "string",
                  "title": "contract address of avstask"
                },
                "name": {
                  "type": "string",
                  "title": "name of task"
                },
                "hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "data which is supplied by the contract, usually ABI-encoded"
                },
                "task_id": {
                  "type": "string",
                  "format": "uint64",
                  "title": "task_id of task"
                },
                "task_response_period": {
                  "type": "string",
                  "format": "uint64",
                  "title": "Deadline for task response"
                },
                "task_statistical_period": {
                  "type": "string",
                  "format": "uint64",
                  "title": "Statistical period: threshold calculation, signature verification,\nnosig quantity statistics, operator submits messages corresponding to signatures"
                },
                "task_challenge_period": {
                  "type": "string",
                  "format": "uint64",
                  "title": "challenge period for  task"
                },
                "threshold_percentage": {
                  "type": "string",
                  "format": "uint64",
                  "title": "Signature threshold percentage"
                },
                "starting_epoch": {
                  "type": "string",
                  "format": "uint64",
                  "title": "Effective current epoch, accounting for current_epoch + 1\nand current_epoch is the integer identifier of the epoch module"
                },
                "actual_threshold": {
                  "type": "string",
                  "format": "uint64",
                  "title": "actual_threshold is the Actual threshold"
                },
                "opt_in_operators": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "opt_in_count when creating a task, the actual opt-in operator counts at this moment"
                },
                "signed_operators": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "signed_count is Actual number of signatures already signed"
                },
                "no_signed_operators": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "no_signed_count is the final number of unsigned operators"
                },
                "err_signed_operators": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "err_signed_count is the number of operators with final incorrect signatures"
                },
                "task_total_power": {
                  "type": "string",
                  "description": "task_total_power is the USD value owned by the avs task itself."
                },
                "operator_active_power": {
                  "title": "operator_active_power_list is a power list of operators opt-in to the current task",
                  "type": "object",
                  "properties": {
                    "operator_power_list": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_addr": {
                            "type": "string",
                            "description": "operator_addr is the operator  address."
                          },
                          "active_power": {
                            "type": "string",
                            "description": "active_power is the USD value owned by the operator itself."
                          }
                        },
                        "description": "OperatorActivePowerInfo is the operator power info."
                      },
                      "description": "operator_power_list is a power list of operators."
                    }
                  }
                }
              },
              "description": "TaskContractInfo is the task info."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "task_addr",
            "description": "task_addr is the task contract address,its type should be a sdk.AccAddress.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "task_id",
            "description": "task_id is the task identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/avs/v1/QueryAVSAddrByChainID/{chain}": {
      "get": {
        "summary": "QueryAVSAddrByChainID queries the avs address by chain id",
        "operationId": "QueryAVSAddrByChainID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "avs_address": {
                  "type": "string",
                  "title": "avs_address is the hex address of avs"
                }
              },
              "title": "QueryAVSAddrByChainIDResponse is the response of avs address by chain id"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "chain",
            "description": "chain is the chain id of the chain, with or without the version suffix.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/avs/v1/QueryAVSInfo": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "QueryAVSInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "title": "basic information of avs",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "title": "name of avs as an arbitrary string"
                    },
                    "avs_address": {
                      "type": "string",
                      "title": "avs_address is the address of avs as a hex string"
                    },
                    "min_stake_amount": {
                      "type": "string",
                      "format": "uint64",
                      "title": "min_stake_amount is the minimum stake amount required for a task to start"
                    },
                    "task_addr": {
                      "type": "string",
                      "title": "task_addr is the address of task as a hex string"
                    },
                    "slash_addr": {
                      "type": "string",
                      "title": "slash_addr is the hex address of the slashing contract for the AVS"
                    },
                    "reward_addr": {
                      "type": "string",
                      "title": "reward_addr is the hex address of the reward contract for the AVS"
                    },
                    "avs_owner_address": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "avs_owner_address are the bech32 addresses of the owners of the avs"
                    },
                    "asset_ids": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "asset_ids is a list of asset_ids that the AVS accepts"
                    },
                    "avs_unbonding_period": {
                      "type": "string",
                      "format": "uint64",
                      "title": "avs_unbonding_period is the number of epochs that an operator must wait to unbond"
                    },
                    "min_self_delegation": {
                      "type": "string",
                      "format": "uint64",
                      "title": "min_self_delegation is the minimum self delegation required for an operator to join the AVS"
                    },
                    "epoch_identifier": {
                      "type": "string",
                      "title": "epoch_identifier is the identifier from the epochs module"
                    },
                    "min_opt_in_operators": {
                      "type": "string",
                      "format": "uint64",
                      "title": "min_opt_in_operators is the minimum number of operators required for a task"
                    },
                    "min_total_stake_amount": {
                      "type": "string",
                      "format": "uint64",
                      "title": "min_total_stake_amount is the minimum total stake amount required for a task"
                    },
                    "starting_epoch": {
                      "type": "string",
                      "format": "uint64",
                      "title": "starting_epoch is the epoch at which the AVS starts"
                    },
                    "chain_id": {
                      "type": "string",
                      "title": "chain_id is an optional parameter to specify the chain_id of the AVS, if any"
                    },
                    "avs_reward": {
                      "type": "string",
                      "title": "avs_reward defines the proportion of reward"
                    },
                    "avs_slash": {
                      "type": "string",
                      "title": "avs_slash defines the proportion of slash"
                    },
                    "asset_reward_amount_epoch_basis": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string",
                        "format": "int64"
                      },
                      "description": "asset_reward_commission_epoch_basis is the avs reward distribution based on asset per eopch end."
                    }
                  }
                }
              },
              "title": "QueryAVSInfoResponse is the response of avs related information"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs_address",
            "description": "avs_address is the address of avs.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/avs/v1/QueryChallengeInfo": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "QueryChallengeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "challenge_addr": {
                  "type": "string",
                  "description": "challenge_addr is the challenge address,its type should be a common.HexAddress."
                }
              },
              "title": "QueryChallengeInfoResponse is the response of avs related information"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "task_addr",
            "description": "task_addr is the task contract address,its type should be a sdk.AccAddress.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "task_id",
            "description": "task_id is the task identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address,its type should be a sdk.AccAddress.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/avs/v1/QuerySubmitTaskResult": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "QuerySubmitTaskResult",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "info": {
                  "description": "info is the taskResult.",
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "title": "operator_address operator address"
                    },
                    "task_response_hash": {
                      "type": "string",
                      "description": "task_response_hash is the task_response msg hash."
                    },
                    "task_response": {
                      "type": "string",
                      "format": "byte",
                      "description": "task_response is the task response data."
                    },
                    "bls_signature": {
                      "type": "string",
                      "format": "byte",
                      "description": "bls_signature is the operator bls sig info."
                    },
                    "task_contract_address": {
                      "type": "string",
                      "title": "task_contract_address is contract address of task"
                    },
                    "task_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "task_id is the  task id"
                    },
                    "phase": {
                      "title": "phase this field is used to solve the problem of task results being copied by other operators.\nIt is a two-phase submission with two values, 1 and 2",
                      "type": "string",
                      "enum": [
                        "PHASE_UNSPECIFIED",
                        "PHASE_PREPARE",
                        "PHASE_DO_COMMIT"
                      ],
                      "default": "PHASE_UNSPECIFIED",
                      "description": "- PHASE_UNSPECIFIED: Default value when phase is not specified\n - PHASE_PREPARE: First phase where operators prepare and submit their initial responses\n - PHASE_DO_COMMIT: Second phase where operators commit their prepared responses"
                    }
                  }
                }
              },
              "title": "QuerySubmitTaskResultResponse is the response of avs related information"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "task_addr",
            "description": "task_addr is the task contract address,its type should be a sdk.AccAddress.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "task_id",
            "description": "task_id is the task identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address,its type should be a sdk.AccAddress.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/all_operator_cons_addrs/{chain}": {
      "get": {
        "summary": "QueryAllOperatorConsAddrsByChainID queries all operators and their consensus addresses\nfor a specific chain ID",
        "operationId": "QueryAllOperatorConsAddrsByChainID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "operator_cons_addrs": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_acc_addr": {
                        "type": "string",
                        "description": "operator_acc_addr is the operator account address."
                      },
                      "cons_addr": {
                        "type": "string",
                        "description": "cons_addr is the consensus address corresponding to the consensus public key\ncurrently in use by the operator."
                      },
                      "opting_out": {
                        "type": "boolean",
                        "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
                      }
                    },
                    "description": "OperatorConsAddrPair holds the operator address and the corresponding consensus address."
                  },
                  "description": "operator_cons_addrs is a list of operator account addresses and the consensus addresses."
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllOperatorConsAddrsByChainIDResponse is the response that includes a list of all operators\nand their consensus addresses for a specified chain ID."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "chain",
            "description": "chain for which the cons addrs are being queried. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/all_operator_cons_keys/{chain}": {
      "get": {
        "summary": "QueryAllOperatorConsKeysByChainID queries all operators and their consensus public keys\nfor a specific chain ID",
        "operationId": "QueryAllOperatorConsKeysByChainID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "operator_cons_keys": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_acc_addr": {
                        "type": "string",
                        "description": "operator_acc_addr is the operator account address."
                      },
                      "public_key": {
                        "description": "public_key is the consensus public key of the operator.",
                        "type": "object",
                        "properties": {
                          "ed25519": {
                            "type": "string",
                            "format": "byte"
                          },
                          "secp256k1": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "title": "PublicKey defines the keys available for use with Validators"
                      },
                      "opting_out": {
                        "type": "boolean",
                        "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
                      }
                    },
                    "description": "OperatorConsKeyPair holds the operator address and the consensus public key currently in\nuse by the operator."
                  },
                  "description": "operator_cons_keys is a list of operator addresses and their consensus public keys."
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllOperatorConsKeysByChainIDResponse is the response that includes a list of all operators\nand their consensus keys for a specified chain ID."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "chain",
            "description": "chain for which the cons keys are being queried. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/all_operators": {
      "get": {
        "summary": "QueryAllOperators queries all operators.",
        "operationId": "QueryAllOperators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "operator_acc_addrs": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "operators is a list of all operators."
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "description": "QueryAllOperatorsResponse is the response containing all operator account addresses."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/all_snapshot/{avs}": {
      "get": {
        "summary": "QueryAllSnapshot queries all voting power snapshot for the specified AVS",
        "operationId": "QueryAllSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "snapshots": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "snapshot_key_height": {
                        "type": "string",
                        "format": "int64",
                        "description": "snapshot_key_height when it is used in QuerySpecifiedSnapshot, it's the latest\nheight with a snapshot key found based on the input height; this height is typically\nthe start height of the epoch in which the input height is located.\nwhen it is used in QueryAllSnapshot, it's the height in the current snapshot key."
                      },
                      "snapshot": {
                        "description": "snapshot when it is used in QuerySpecifiedSnapshot, it is the final retrieved information\ncontaining the voting power set.\nwhen it is used in QueryAllSnapshot, It is the snapshot stored under `snapshot_key_height`,\nand its voting power set may be nil.",
                        "type": "object",
                        "properties": {
                          "total_voting_power": {
                            "type": "string",
                            "title": "total_voting_power is the total voting power of specified AVS"
                          },
                          "operator_voting_powers": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "operator_addr": {
                                  "type": "string",
                                  "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "title": "voting_power is the active voting power for the above operator address"
                                }
                              },
                              "title": "OperatorVotingPower represents the voting power for the specified operator address"
                            },
                            "title": "operator_voting_powers records the active voting power of all operators\nfor the specified AVS"
                          },
                          "last_changed_height": {
                            "type": "string",
                            "format": "int64",
                            "description": "last_changed_height is used to indicate the height of most recent change when\nthe operator_voting_powers is nil, which can help to fall back to the correct epoch height."
                          },
                          "epoch_identifier": {
                            "type": "string",
                            "title": "epoch_identifier record the epoch info"
                          },
                          "epoch_number": {
                            "type": "string",
                            "format": "int64",
                            "title": "epoch_number indicates which epoch this snapshot serve for"
                          }
                        }
                      }
                    },
                    "title": "VotingPowerSnapshotKeyHeight is used in the response of QuerySpecifiedSnapshot\nand QueryAllSnapshot"
                  },
                  "description": "snapshots is a list of all snapshots for the specified AVS."
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryAllSnapshotResponse is the response to obtain all voting power snapshot\nfor the specified AVS"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs",
            "description": "avs address",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/avs_usd_value": {
      "get": {
        "summary": "QueryAVSUSDValue queries the USD value for the AVS",
        "operationId": "QueryAVSUSDValue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "amount": {
                  "type": "string",
                  "description": "amount is the USD value of the asset, as an sdk.LegacyDec."
                }
              },
              "description": "DecValueField is a field that holds a value of sdk.LegacyDec type."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs_address",
            "description": "avs_address is the AVS address opted-in by the operator.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/operator_cons_addr/{operator_acc_addr}/{chain}": {
      "get": {
        "summary": "QueryOperatorConsAddressForChainID queries the consensus address for the operator.",
        "operationId": "QueryOperatorConsAddressForChainID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "cons_addr": {
                  "type": "string",
                  "description": "cons_addr is the consensus address corresponding to the consensus public key\ncurrently in use by the operator."
                },
                "opting_out": {
                  "type": "boolean",
                  "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
                }
              },
              "description": "QueryOperatorConsAddressResponse is the response for QueryOperatorConsAddressRequest."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_acc_addr",
            "description": "operator_acc_addr is the operator account address.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "chain",
            "description": "chain is the id of the chain served by the operator. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/operator_cons_key/{operator_acc_addr}/{chain}": {
      "get": {
        "summary": "QueryOperatorConsKeyForChainID queries the consensus public key for the operator",
        "operationId": "QueryOperatorConsKeyForChainID",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "public_key": {
                  "description": "public_key is the consensus public key of the operator.",
                  "type": "object",
                  "properties": {
                    "ed25519": {
                      "type": "string",
                      "format": "byte"
                    },
                    "secp256k1": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PublicKey defines the keys available for use with Validators"
                },
                "opting_out": {
                  "type": "boolean",
                  "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
                }
              },
              "description": "QueryOperatorConsKeyResponse is the response for QueryOperatorConsKeyRequest."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_acc_addr",
            "description": "operator_acc_addr is the operator account address.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "chain",
            "description": "chain is the id of the chain served by the operator. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/operator_info/{operator_addr}": {
      "get": {
        "summary": "QueryOperatorInfo queries the operator information.",
        "operationId": "QueryOperatorInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "earnings_addr": {
                  "type": "string",
                  "description": "earnings_addr is the earnings address."
                },
                "approve_addr": {
                  "type": "string",
                  "description": "approve_addr is the approve address."
                },
                "operator_meta_info": {
                  "type": "string",
                  "description": "operator_meta_info is the operator meta info."
                },
                "client_chain_earnings_addr": {
                  "description": "client_chain_earning_addr_list is the client chain earning address list.",
                  "type": "object",
                  "properties": {
                    "earning_info_list": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "lz_client_chain_id": {
                            "type": "string",
                            "format": "uint64",
                            "description": "lz_client_chain_id is the layer0 client chain id."
                          },
                          "client_chain_earning_addr": {
                            "type": "string",
                            "description": "client_chain_earning_addr is the client chain earning address."
                          }
                        },
                        "description": "ClientChainEarningAddrInfo is the client chain earning address info."
                      },
                      "description": "earning_info_list is the contents of ClientChainEarningAddrList."
                    }
                  }
                },
                "commission": {
                  "description": "commission defines the commission parameters. it includes the time at which the commission\nwas last updated.",
                  "type": "object",
                  "properties": {
                    "commission_rates": {
                      "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                      "type": "object",
                      "properties": {
                        "rate": {
                          "type": "string",
                          "description": "rate is the commission rate charged to delegators, as a fraction."
                        },
                        "max_rate": {
                          "type": "string",
                          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                        },
                        "max_change_rate": {
                          "type": "string",
                          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                        }
                      }
                    },
                    "update_time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "update_time is the last time the commission rate was changed."
                    }
                  }
                }
              },
              "description": "OperatorInfo is the operator info."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_addr",
            "description": "operator_addr is the operator address,its type should be a sdk.AccAddress",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/operator_slash_info/{operator_and_avs.operator_addr}/{operator_and_avs.avs_address}": {
      "get": {
        "summary": "QueryOperatorSlashInfo queries the slash information for the specified operator and AVS",
        "operationId": "QueryOperatorSlashInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "all_slash_info": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "slash_id": {
                        "type": "string",
                        "description": "slash_id is stored as the key of the slash information,\nso it will be parsed and padding here."
                      },
                      "info": {
                        "description": "info is the specified detailed information for the slashing event.",
                        "type": "object",
                        "properties": {
                          "slash_contract": {
                            "type": "string",
                            "title": "slash_contract is the address of slash contract"
                          },
                          "submitted_height": {
                            "type": "string",
                            "format": "int64",
                            "title": "submitted_height is the exocore block height at which the slash event is submitted"
                          },
                          "event_height": {
                            "type": "string",
                            "format": "int64",
                            "title": "event_height is the exocore block height at which the slash event occurs"
                          },
                          "is_vetoed": {
                            "type": "boolean",
                            "title": "is_vetoed is a flag to indicate if this slash is vetoed"
                          },
                          "slash_proportion": {
                            "type": "string",
                            "title": "slash_proportion is the proportion of assets that need to be slashed"
                          },
                          "slash_type": {
                            "type": "integer",
                            "format": "int64",
                            "description": "slash_type indicates the slash type of specified AVS."
                          },
                          "execution_info": {
                            "title": "SlashExecutionInfo stores the slashed execution information",
                            "type": "object",
                            "properties": {
                              "slash_proportion": {
                                "type": "string",
                                "title": "slash_proportion is the new calculated proportion when execute the slash"
                              },
                              "slash_value": {
                                "type": "string",
                                "title": "slash_value is the usd value of all slashed assets"
                              },
                              "slash_undelegations": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "staker_id": {
                                      "type": "string",
                                      "description": "staker_id is the staker id."
                                    },
                                    "asset_id": {
                                      "type": "string",
                                      "description": "asset_id is the asset id."
                                    },
                                    "amount": {
                                      "type": "string",
                                      "description": "amount is the slashed amount from the undelegation."
                                    }
                                  },
                                  "title": "SlashFromUndelegation records the slash detail from the undelegation"
                                },
                                "title": "SlashUndelegations records all slash info related to the undelegation"
                              },
                              "slash_assets_pool": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "asset_id": {
                                      "type": "string",
                                      "description": "asset_id is the asset id."
                                    },
                                    "amount": {
                                      "type": "string",
                                      "description": "amount is the slashed amount from the assets pool."
                                    }
                                  },
                                  "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
                                },
                                "title": "SlashFromAssetsPool records all slash info related to the assets pool"
                              },
                              "undelegation_filter_height": {
                                "type": "string",
                                "format": "int64",
                                "title": "undelegation_filter_height records the height before which undelegations are not slashed"
                              }
                            }
                          }
                        },
                        "title": "OperatorSlashInfo is the slash info of operator"
                      }
                    },
                    "title": "OperatorSlashInfoByID includes the slash information and the slashID"
                  },
                  "title": "all_slash_info is a list of the slash information for the specified operator and AVS"
                },
                "pagination": {
                  "description": "pagination related response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryOperatorSlashInfoResponse is the response for GetOperatorSlashInfoRequest"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_and_avs.operator_addr",
            "description": "operator_addr should be the string type of sdk.AccAddress",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "operator_and_avs.avs_address",
            "description": "avs_address is the address of the AVS - either an 0x address or a chainID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/operator_usd_value/{operator_and_avs.operator_addr}/{operator_and_avs.avs_address}": {
      "get": {
        "summary": "QueryOperatorUSDValue queries the opted-in USD value for the operator",
        "operationId": "QueryOperatorUSDValue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "usd_values": {
                  "title": "usd_info includes the self and total staking for the operator and AVS",
                  "type": "object",
                  "properties": {
                    "self_usd_value": {
                      "type": "string",
                      "description": "self_usd_value is the USD value owned by the operator itself."
                    },
                    "total_usd_value": {
                      "type": "string",
                      "title": "total_usd_value is the total opted-in USD value for the specified operator and AVS"
                    },
                    "active_usd_value": {
                      "type": "string",
                      "description": "active_usd_value is the active opted-in USD value for the specified operator and AVS\nthis field will be zero if the operator's self staking isn't sufficient. Of course, it will\nbe equal to total_usd_value if the operator's self staking meets the AVS requirement."
                    }
                  }
                }
              },
              "description": "QueryOperatorUSDValueResponse is the response to obtain the USD value for operator."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_and_avs.operator_addr",
            "description": "operator_addr should be the string type of sdk.AccAddress",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "operator_and_avs.avs_address",
            "description": "avs_address is the address of the AVS - either an 0x address or a chainID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/opt/avs_list/{operator}": {
      "get": {
        "summary": "QueryAllAVSsByOperator queries avs list.",
        "operationId": "QueryAllAVSsByOperator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "avs_list": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "avs_list is a list of avs addresses  ."
                }
              },
              "description": "QueryAllAVSsByOperatorResponse is the response that includes a list of all operators\nand their consensus keys for a specified chain ID."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator",
            "description": "operator address.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/opt/operator_list/{avs}": {
      "get": {
        "summary": "QueryAllOperatorsWithOptInAVS queries  operator list by avs.",
        "operationId": "QueryAllOperatorsWithOptInAVS",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "operator_list": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "operator_list is a list of operator addresses."
                }
              },
              "description": "QueryAllOperatorsWithOptInAVSResponse is the response that includes a list of all avs\n  for a specified operator address."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs",
            "description": "avs address",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/opt_info/{operator_and_avs.operator_addr}/{operator_and_avs.avs_address}": {
      "get": {
        "summary": "QueryOptInfo queries specified opted information.",
        "operationId": "QueryOptInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "slash_contract": {
                  "type": "string",
                  "title": "slash_contract is the slash contract address of AVS opted-in by the operator"
                },
                "opted_in_height": {
                  "type": "string",
                  "format": "uint64",
                  "title": "opted_in_height is the exocore block height at which the operator opted in"
                },
                "opted_out_height": {
                  "type": "string",
                  "format": "uint64",
                  "title": "opted_out_height is the exocore block height at which the operator opted out"
                },
                "jailed": {
                  "type": "boolean",
                  "description": "jailed defined whether the operator has been jailed from bonded status or not."
                }
              },
              "title": "OptedInfo is the opted information about operator"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "operator_and_avs.operator_addr",
            "description": "operator_addr should be the string type of sdk.AccAddress",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "operator_and_avs.avs_address",
            "description": "avs_address is the address of the AVS - either an 0x address or a chainID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/snapshot/{avs}/{height}": {
      "get": {
        "summary": "QuerySpecifiedSnapshot queries the voting power snapshot of specified AVS and height",
        "operationId": "QuerySpecifiedSnapshot",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "snapshot_key_height": {
                  "type": "string",
                  "format": "int64",
                  "description": "snapshot_key_height when it is used in QuerySpecifiedSnapshot, it's the latest\nheight with a snapshot key found based on the input height; this height is typically\nthe start height of the epoch in which the input height is located.\nwhen it is used in QueryAllSnapshot, it's the height in the current snapshot key."
                },
                "snapshot": {
                  "description": "snapshot when it is used in QuerySpecifiedSnapshot, it is the final retrieved information\ncontaining the voting power set.\nwhen it is used in QueryAllSnapshot, It is the snapshot stored under `snapshot_key_height`,\nand its voting power set may be nil.",
                  "type": "object",
                  "properties": {
                    "total_voting_power": {
                      "type": "string",
                      "title": "total_voting_power is the total voting power of specified AVS"
                    },
                    "operator_voting_powers": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_addr": {
                            "type": "string",
                            "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
                          },
                          "voting_power": {
                            "type": "string",
                            "title": "voting_power is the active voting power for the above operator address"
                          }
                        },
                        "title": "OperatorVotingPower represents the voting power for the specified operator address"
                      },
                      "title": "operator_voting_powers records the active voting power of all operators\nfor the specified AVS"
                    },
                    "last_changed_height": {
                      "type": "string",
                      "format": "int64",
                      "description": "last_changed_height is used to indicate the height of most recent change when\nthe operator_voting_powers is nil, which can help to fall back to the correct epoch height."
                    },
                    "epoch_identifier": {
                      "type": "string",
                      "title": "epoch_identifier record the epoch info"
                    },
                    "epoch_number": {
                      "type": "string",
                      "format": "int64",
                      "title": "epoch_number indicates which epoch this snapshot serve for"
                    }
                  }
                }
              },
              "title": "VotingPowerSnapshotKeyHeight is used in the response of QuerySpecifiedSnapshot\nand QueryAllSnapshot"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs",
            "description": "avs address",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "height",
            "description": "height is used to specify the snapshot height you want to query.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/snapshot_helper/{avs}": {
      "get": {
        "summary": "QuerySnapshotHelper queries the snapshot helper of the AVS",
        "operationId": "QuerySnapshotHelper",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "last_changed_height": {
                  "type": "string",
                  "format": "int64",
                  "description": "last_changed_height indicates the height of the most recent change.\nIt is used to set the `last_changed_height` field in `VotingPowerSnapshot`."
                },
                "has_opt_out": {
                  "type": "boolean",
                  "description": "has_opt_out is used to indicate whether there has been any opt-out operation from\nthe most recently saved snapshot to the current height. This is because,\nwhen an opt-out operation occurs, the related AVS validator information changes,\nand the snapshot needs to be updated.\nCurrently, a boolean variable is used instead of an operator list\nbecause the snapshot is set by default to store all operator information related to AVS.\nTherefore, as long as any operator has opted out, the snapshot needs to be updated.\nIf we later introduce a limit on the maximum number of validators in AVS,\nsimilar to the MaxValidatorNumber in Dogfood, this may need to be changed to an operator list\nto track all operators that have opted out, thereby assisting with the correct snapshot update."
                }
              },
              "title": "SnapshotHelper is used to record the helper information for voting power snapshot update"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "avs",
            "description": "avs address",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/validator/{validator_acc_addr}/{chain}": {
      "get": {
        "summary": "Validator queries validator info for given validator address.",
        "operationId": "Validator",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validator": {
                  "description": "validator defines the validator info.",
                  "type": "object",
                  "properties": {
                    "operator_earnings_addr": {
                      "type": "string",
                      "description": "earnoperator_earnings_addrings_addr is the earnings address."
                    },
                    "operator_approve_addr": {
                      "type": "string",
                      "description": "operator_approve_addr is the approve address."
                    },
                    "operator_meta_info": {
                      "type": "string",
                      "description": "operator_meta_info is the operator meta info."
                    },
                    "cons_address": {
                      "type": "string",
                      "description": "ConsAddress defines a wrapper around bytes meant to present a consensus node.\nWhen marshaled to a string or JSON, it uses Bech32."
                    },
                    "consensus_pubkey": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                      "title": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any"
                    },
                    "jailed": {
                      "type": "boolean",
                      "title": "jailed defined whether the validator has been jailed from bonded status or not"
                    },
                    "status": {
                      "title": "status is the validator status (bonded/unbonding/unbonded)",
                      "type": "string",
                      "enum": [
                        "BOND_STATUS_UNSPECIFIED",
                        "BOND_STATUS_UNBONDED",
                        "BOND_STATUS_UNBONDING",
                        "BOND_STATUS_BONDED"
                      ],
                      "default": "BOND_STATUS_UNSPECIFIED",
                      "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
                    },
                    "voting_power": {
                      "type": "string",
                      "title": "voting_power define the validator voting power"
                    },
                    "delegator_shares": {
                      "type": "string",
                      "title": "delegator_shares defines total shares issued to a validator's delegators"
                    },
                    "commission": {
                      "description": "commission defines the commission parameters.",
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string",
                              "description": "rate is the commission rate charged to delegators, as a fraction."
                            },
                            "max_rate": {
                              "type": "string",
                              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                            },
                            "max_change_rate": {
                              "type": "string",
                              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                            }
                          }
                        },
                        "update_time": {
                          "type": "string",
                          "format": "date-time",
                          "description": "update_time is the last time the commission rate was changed."
                        }
                      }
                    },
                    "delegator_tokens": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "asset_id": {
                            "type": "string",
                            "title": "asset_id is the asset for which the query is made"
                          },
                          "symbol": {
                            "type": "string",
                            "title": "symbol of the asset, like \"USDT\""
                          },
                          "name": {
                            "type": "string",
                            "title": "name of the asset, like \"Tether USD\""
                          },
                          "self_amount": {
                            "type": "string",
                            "title": "self_amount is the self amount of the asset which delegation"
                          },
                          "total_amount": {
                            "type": "string",
                            "title": "total_amount is the total amount of the asset which delegation"
                          },
                          "self_usd_value": {
                            "type": "string",
                            "title": "self_usd_value is the self delegation USD value for the validator"
                          },
                          "total_usd_value": {
                            "type": "string",
                            "title": "total_usd_value is the total delegation USD value for the validator"
                          }
                        },
                        "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
                      },
                      "title": "delegator_tokens is the list of asset infos"
                    }
                  },
                  "title": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate"
                }
              },
              "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "validator_acc_addr",
            "description": "validator_acc_addr defines the validator address to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "chain",
            "description": "chain is the id of the chain served by the operator. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/operator/v1/validators/{chain}": {
      "get": {
        "summary": "Validators queries all validators that match the given status.\nWhen called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Validators",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "operator_earnings_addr": {
                        "type": "string",
                        "description": "earnoperator_earnings_addrings_addr is the earnings address."
                      },
                      "operator_approve_addr": {
                        "type": "string",
                        "description": "operator_approve_addr is the approve address."
                      },
                      "operator_meta_info": {
                        "type": "string",
                        "description": "operator_meta_info is the operator meta info."
                      },
                      "cons_address": {
                        "type": "string",
                        "description": "ConsAddress defines a wrapper around bytes meant to present a consensus node.\nWhen marshaled to a string or JSON, it uses Bech32."
                      },
                      "consensus_pubkey": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "type": "string",
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "title": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any"
                      },
                      "jailed": {
                        "type": "boolean",
                        "title": "jailed defined whether the validator has been jailed from bonded status or not"
                      },
                      "status": {
                        "title": "status is the validator status (bonded/unbonding/unbonded)",
                        "type": "string",
                        "enum": [
                          "BOND_STATUS_UNSPECIFIED",
                          "BOND_STATUS_UNBONDED",
                          "BOND_STATUS_UNBONDING",
                          "BOND_STATUS_BONDED"
                        ],
                        "default": "BOND_STATUS_UNSPECIFIED",
                        "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
                      },
                      "voting_power": {
                        "type": "string",
                        "title": "voting_power define the validator voting power"
                      },
                      "delegator_shares": {
                        "type": "string",
                        "title": "delegator_shares defines total shares issued to a validator's delegators"
                      },
                      "commission": {
                        "description": "commission defines the commission parameters.",
                        "type": "object",
                        "properties": {
                          "commission_rates": {
                            "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                            "type": "object",
                            "properties": {
                              "rate": {
                                "type": "string",
                                "description": "rate is the commission rate charged to delegators, as a fraction."
                              },
                              "max_rate": {
                                "type": "string",
                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                              },
                              "max_change_rate": {
                                "type": "string",
                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                              }
                            }
                          },
                          "update_time": {
                            "type": "string",
                            "format": "date-time",
                            "description": "update_time is the last time the commission rate was changed."
                          }
                        }
                      },
                      "delegator_tokens": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "asset_id": {
                              "type": "string",
                              "title": "asset_id is the asset for which the query is made"
                            },
                            "symbol": {
                              "type": "string",
                              "title": "symbol of the asset, like \"USDT\""
                            },
                            "name": {
                              "type": "string",
                              "title": "name of the asset, like \"Tether USD\""
                            },
                            "self_amount": {
                              "type": "string",
                              "title": "self_amount is the self amount of the asset which delegation"
                            },
                            "total_amount": {
                              "type": "string",
                              "title": "total_amount is the total amount of the asset which delegation"
                            },
                            "self_usd_value": {
                              "type": "string",
                              "title": "self_usd_value is the self delegation USD value for the validator"
                            },
                            "total_usd_value": {
                              "type": "string",
                              "title": "total_usd_value is the total delegation USD value for the validator"
                            }
                          },
                          "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
                        },
                        "title": "delegator_tokens is the list of asset infos"
                      }
                    },
                    "title": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate"
                  },
                  "description": "validators contains all the queried validators."
                },
                "pagination": {
                  "description": "pagination defines the pagination in the response.",
                  "type": "object",
                  "properties": {
                    "next_key": {
                      "type": "string",
                      "format": "byte",
                      "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
                    },
                    "total": {
                      "type": "string",
                      "format": "uint64",
                      "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
                    }
                  }
                }
              },
              "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "chain",
            "description": "chain is the id of the chain served by the operator. here chain_id is not used since the\nLinter complains about capitalization, which can be set with a gogoproto.custom_name but\nthat is not compatible with google.api.http.get in the Query service below.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pagination.key",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "pagination.offset",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.limit",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "pagination.count_total",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "pagination.reverse",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
      "get": {
        "summary": "AppliedPlan queries a previously applied upgrade plan by its name.",
        "operationId": "AppliedPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64",
                  "description": "height is the block height at which the plan was applied."
                }
              },
              "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "name is the name of the applied plan to query for.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/authority": {
      "get": {
        "summary": "Returns the account with authority to conduct upgrades",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "Authority",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string"
                }
              },
              "description": "Since: cosmos-sdk 0.46",
              "title": "QueryAuthorityResponse is the response type for Query/Authority"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/current_plan": {
      "get": {
        "summary": "CurrentPlan queries the current upgrade plan.",
        "operationId": "CurrentPlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "plan": {
                  "description": "plan is the current upgrade plan.",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
                    },
                    "time": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
                    },
                    "height": {
                      "type": "string",
                      "format": "int64",
                      "description": "The height at which the upgrade must be performed."
                    },
                    "info": {
                      "type": "string",
                      "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
                    },
                    "upgraded_client_state": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "type": "string",
                          "format": "byte",
                          "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  }
                }
              },
              "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/upgrade/v1beta1/module_versions": {
      "get": {
        "summary": "ModuleVersions queries the list of module versions from state.",
        "description": "Since: cosmos-sdk 0.43",
        "operationId": "ModuleVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "module_versions": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "title": "name of the app module"
                      },
                      "version": {
                        "type": "string",
                        "format": "uint64",
                        "title": "consensus version of the app module"
                      }
                    },
                    "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
                  },
                  "description": "module_versions is a list of module names with their consensus versions."
                }
              },
              "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "type": "string",
                        "format": "byte",
                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "module_name",
            "description": "module_name is a field to query a specific module\nconsensus version from state. Leaving this empty will\nfetch the full list of module versions from state.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Query"
        ]
      }
    },
    "/ibc/apps/interchain_accounts/host/v1/params": {
      "get": {
        "summary": "Params queries all parameters of the ICA host submodule.",
        "operationId": "InterchainAccountsHostParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params defines the parameters of the module.",
                  "type": "object",
                  "properties": {
                    "host_enabled": {
                      "type": "boolean",
                      "description": "host_enabled enables or disables the host submodule."
                    },
                    "allow_messages": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/cosmos/consensus/v1/params": {
      "get": {
        "summary": "Params queries the parameters of x/consensus_param module.",
        "operationId": "ConsensusParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params are the tendermint consensus params stored in the consensus module.\nPlease note that `params.version` is not populated in this response, it is\ntracked separately in the x/upgrade module.",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "object",
                      "properties": {
                        "max_bytes": {
                          "type": "string",
                          "format": "int64",
                          "title": "Max block size, in bytes.\nNote: must be greater than 0"
                        },
                        "max_gas": {
                          "type": "string",
                          "format": "int64",
                          "title": "Max gas per block.\nNote: must be greater or equal to -1"
                        }
                      },
                      "description": "BlockParams contains limits on the block size."
                    },
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "max_age_num_blocks": {
                          "type": "string",
                          "format": "int64",
                          "description": "Max age of evidence, in blocks.\n\nThe basic formula for calculating this is: MaxAgeDuration / {average block\ntime}."
                        },
                        "max_age_duration": {
                          "type": "string",
                          "description": "Max age of evidence, in time.\n\nIt should correspond with an app's \"unbonding period\" or other similar\nmechanism for handling [Nothing-At-Stake\nattacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed)."
                        },
                        "max_bytes": {
                          "type": "string",
                          "format": "int64",
                          "title": "This sets the maximum size of total evidence in bytes that can be committed in a single block.\nand should fall comfortably under the max block bytes.\nDefault is 1048576 or 1MB"
                        }
                      },
                      "description": "EvidenceParams determine how we handle evidence of malfeasance."
                    },
                    "validator": {
                      "type": "object",
                      "properties": {
                        "pub_key_types": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "description": "ValidatorParams restrict the public key types validators can use.\nNOTE: uses ABCI pubkey naming, not Amino names."
                    },
                    "version": {
                      "type": "object",
                      "properties": {
                        "app": {
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "VersionParams contains the ABCI application version."
                    }
                  }
                }
              },
              "description": "QueryParamsResponse defines the response type for querying x/consensus parameters."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    },
    "/exocore/reward/v1/params": {
      "get": {
        "summary": "Parameters queries the parameters of the module.",
        "operationId": "RewardParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "params holds all the parameters of this module.",
                  "type": "object"
                }
              },
              "description": "QueryParamsResponse is response type for the Query/Params RPC method."
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "format": "int32"
                },
                "message": {
                  "type": "string"
                },
                "details": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Query"
        ]
      }
    }
  },
  "definitions": {
    "cosmos.base.query.v1beta1.PageRequest": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "format": "byte",
          "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set."
        },
        "offset": {
          "type": "string",
          "format": "uint64",
          "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set."
        },
        "limit": {
          "type": "string",
          "format": "uint64",
          "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app."
        },
        "count_total": {
          "type": "boolean",
          "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set."
        },
        "reverse": {
          "type": "boolean",
          "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
      "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:"
    },
    "cosmos.base.query.v1beta1.PageResponse": {
      "type": "object",
      "properties": {
        "next_key": {
          "type": "string",
          "format": "byte",
          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
        }
      },
      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
    },
    "exocore.epochs.v1.EpochInfo": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string",
          "description": "identifier is the unique identifier of the epoch, typically, the measure\nof time used to define the epoch."
        },
        "start_time": {
          "type": "string",
          "format": "date-time",
          "description": "start_time of the epoch. it may be in the future, in which case, the epoch\nis not yet active."
        },
        "duration": {
          "type": "string",
          "description": "duration is the time in between epoch i and epoch i+1. for an epoch to\nbe meaningful, the duration should be more than the block time of the chain."
        },
        "current_epoch": {
          "type": "string",
          "format": "int64",
          "description": "current_epoch is the number of the currently ongoing epoch, identified by the\nidentifier. the first epoch starts during the first block whose block time\nis greater than or equal to the start_time of the epoch."
        },
        "current_epoch_start_time": {
          "type": "string",
          "format": "date-time",
          "description": "current_epoch_start_time is the start time of the current time interval, which\nis (current_epoch_start_time, current_epoch_start_time + duration]. when we say\nthat the timer has \"ticked\", it means that the interval's components are increased\nby the duration. note, however, that only one tick can occur in any given block.\n\nthe above constraint results in a deviation from the \"ideal\" tick time / the wall\nclock time. this is particularly obvious when a chain goes down.\nsay, at t = 13, the interval is (10, 10 + 5 = 15].\nat t = 14, it is unchanged even in a new block, since 10 < t <= 15\nat t = 15, it is unchanged even in a new block, since 10 < t <= 15\nat t = 16, it increases to (15, 20]. but then assume that the chain goes down\nand comes back up at t = 35, producing 1 block each second after that as well.\nat t = 35, the interval increases by 1 tick to (15, 20] (at the block end).\nat t = 36, it increases to (20, 25].\nat t = 37, it increases to (25, 30].\nat t = 38, it increases to (30, 35].\nat t = 39, it increases to (35, 40].\nat t = 40, it is unchanged even in a new block, since 35 < t <= 40.\nat t = 41, it increases to (40, 45]."
        },
        "epoch_counting_started": {
          "type": "boolean",
          "description": "epoch_counting_started is true if the epoch counting has started for this identifier.\nit is independent of the epoch number or the time; it just indicates that at least\none epoch for this identifier has started counting."
        },
        "current_epoch_start_height": {
          "type": "string",
          "format": "int64",
          "description": "current_epoch_start_height is the block height at which the current epoch started,\nor the height at which the timer last \"ticked\"."
        }
      },
      "description": "EpochInfo defines an epoch and its metadata. An epoch is a period of time\nthat is used to define a time frame for a system."
    },
    "exocore.epochs.v1.QueryCurrentEpochResponse": {
      "type": "object",
      "properties": {
        "current_epoch": {
          "type": "string",
          "format": "int64",
          "title": "current_epoch is the number of the current epoch"
        }
      },
      "description": "QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC\nmethod."
    },
    "exocore.epochs.v1.QueryEpochsInfoResponse": {
      "type": "object",
      "properties": {
        "epochs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string",
                "description": "identifier is the unique identifier of the epoch, typically, the measure\nof time used to define the epoch."
              },
              "start_time": {
                "type": "string",
                "format": "date-time",
                "description": "start_time of the epoch. it may be in the future, in which case, the epoch\nis not yet active."
              },
              "duration": {
                "type": "string",
                "description": "duration is the time in between epoch i and epoch i+1. for an epoch to\nbe meaningful, the duration should be more than the block time of the chain."
              },
              "current_epoch": {
                "type": "string",
                "format": "int64",
                "description": "current_epoch is the number of the currently ongoing epoch, identified by the\nidentifier. the first epoch starts during the first block whose block time\nis greater than or equal to the start_time of the epoch."
              },
              "current_epoch_start_time": {
                "type": "string",
                "format": "date-time",
                "description": "current_epoch_start_time is the start time of the current time interval, which\nis (current_epoch_start_time, current_epoch_start_time + duration]. when we say\nthat the timer has \"ticked\", it means that the interval's components are increased\nby the duration. note, however, that only one tick can occur in any given block.\n\nthe above constraint results in a deviation from the \"ideal\" tick time / the wall\nclock time. this is particularly obvious when a chain goes down.\nsay, at t = 13, the interval is (10, 10 + 5 = 15].\nat t = 14, it is unchanged even in a new block, since 10 < t <= 15\nat t = 15, it is unchanged even in a new block, since 10 < t <= 15\nat t = 16, it increases to (15, 20]. but then assume that the chain goes down\nand comes back up at t = 35, producing 1 block each second after that as well.\nat t = 35, the interval increases by 1 tick to (15, 20] (at the block end).\nat t = 36, it increases to (20, 25].\nat t = 37, it increases to (25, 30].\nat t = 38, it increases to (30, 35].\nat t = 39, it increases to (35, 40].\nat t = 40, it is unchanged even in a new block, since 35 < t <= 40.\nat t = 41, it increases to (40, 45]."
              },
              "epoch_counting_started": {
                "type": "boolean",
                "description": "epoch_counting_started is true if the epoch counting has started for this identifier.\nit is independent of the epoch number or the time; it just indicates that at least\none epoch for this identifier has started counting."
              },
              "current_epoch_start_height": {
                "type": "string",
                "format": "int64",
                "description": "current_epoch_start_height is the block height at which the current epoch started,\nor the height at which the timer last \"ticked\"."
              }
            },
            "description": "EpochInfo defines an epoch and its metadata. An epoch is a period of time\nthat is used to define a time frame for a system."
          },
          "description": "epochs is a slice of all EpochInfos returned by the query."
        },
        "block_time": {
          "type": "string",
          "format": "date-time",
          "description": "block_time is the block time of the query block ctx."
        },
        "pagination": {
          "description": "pagination defines the pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC\nmethod."
    },
    "google.protobuf.Any": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "grpc.gateway.runtime.Error": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string"
        },
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        }
      }
    },
    "evmos.erc20.v1.Owner": {
      "type": "string",
      "enum": [
        "OWNER_UNSPECIFIED",
        "OWNER_MODULE",
        "OWNER_EXTERNAL"
      ],
      "default": "OWNER_UNSPECIFIED",
      "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
    },
    "evmos.erc20.v1.Params": {
      "type": "object",
      "properties": {
        "enable_erc20": {
          "type": "boolean",
          "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
        },
        "enable_evm_hook": {
          "type": "boolean",
          "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
        }
      },
      "title": "Params defines the erc20 module params"
    },
    "evmos.erc20.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "title": "params are the erc20 module parameters",
          "type": "object",
          "properties": {
            "enable_erc20": {
              "type": "boolean",
              "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
            },
            "enable_evm_hook": {
              "type": "boolean",
              "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
    },
    "evmos.erc20.v1.QueryTokenPairResponse": {
      "type": "object",
      "properties": {
        "token_pair": {
          "type": "object",
          "properties": {
            "erc20_address": {
              "type": "string",
              "title": "erc20_address is the hex address of ERC20 contract token"
            },
            "denom": {
              "type": "string",
              "title": "denom defines the cosmos base denomination to be mapped to"
            },
            "enabled": {
              "type": "boolean",
              "title": "enabled defines the token mapping enable status"
            },
            "contract_owner": {
              "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
              "type": "string",
              "enum": [
                "OWNER_UNSPECIFIED",
                "OWNER_MODULE",
                "OWNER_EXTERNAL"
              ],
              "default": "OWNER_UNSPECIFIED",
              "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
            }
          },
          "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address.",
          "title": "token_pairs returns the info about a registered token pair for the erc20 module"
        }
      },
      "description": "QueryTokenPairResponse is the response type for the Query/TokenPair RPC\nmethod."
    },
    "evmos.erc20.v1.QueryTokenPairsResponse": {
      "type": "object",
      "properties": {
        "token_pairs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "erc20_address": {
                "type": "string",
                "title": "erc20_address is the hex address of ERC20 contract token"
              },
              "denom": {
                "type": "string",
                "title": "denom defines the cosmos base denomination to be mapped to"
              },
              "enabled": {
                "type": "boolean",
                "title": "enabled defines the token mapping enable status"
              },
              "contract_owner": {
                "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                "type": "string",
                "enum": [
                  "OWNER_UNSPECIFIED",
                  "OWNER_MODULE",
                  "OWNER_EXTERNAL"
                ],
                "default": "OWNER_UNSPECIFIED",
                "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
              }
            },
            "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
          },
          "title": "token_pairs is a slice of registered token pairs for the erc20 module"
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC\nmethod."
    },
    "evmos.erc20.v1.TokenPair": {
      "type": "object",
      "properties": {
        "erc20_address": {
          "type": "string",
          "title": "erc20_address is the hex address of ERC20 contract token"
        },
        "denom": {
          "type": "string",
          "title": "denom defines the cosmos base denomination to be mapped to"
        },
        "enabled": {
          "type": "boolean",
          "title": "enabled defines the token mapping enable status"
        },
        "contract_owner": {
          "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
          "type": "string",
          "enum": [
            "OWNER_UNSPECIFIED",
            "OWNER_MODULE",
            "OWNER_EXTERNAL"
          ],
          "default": "OWNER_UNSPECIFIED",
          "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account."
        }
      },
      "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
    },
    "ethermint.evm.v1.ChainConfig": {
      "type": "object",
      "properties": {
        "homestead_block": {
          "type": "string",
          "title": "homestead_block switch (nil no fork, 0 = already homestead)"
        },
        "dao_fork_block": {
          "type": "string",
          "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
        },
        "dao_fork_support": {
          "type": "boolean",
          "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork"
        },
        "eip150_block": {
          "type": "string",
          "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
        },
        "eip150_hash": {
          "type": "string",
          "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)"
        },
        "eip155_block": {
          "type": "string",
          "title": "eip155_block: EIP155Block HF block"
        },
        "eip158_block": {
          "type": "string",
          "title": "eip158_block: EIP158 HF block"
        },
        "byzantium_block": {
          "type": "string",
          "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)"
        },
        "constantinople_block": {
          "type": "string",
          "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)"
        },
        "petersburg_block": {
          "type": "string",
          "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
        },
        "istanbul_block": {
          "type": "string",
          "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)"
        },
        "muir_glacier_block": {
          "type": "string",
          "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)"
        },
        "berlin_block": {
          "type": "string",
          "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
        },
        "london_block": {
          "type": "string",
          "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
        },
        "arrow_glacier_block": {
          "type": "string",
          "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)"
        },
        "gray_glacier_block": {
          "type": "string",
          "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)"
        },
        "merge_netsplit_block": {
          "type": "string",
          "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter"
        },
        "shanghai_block": {
          "type": "string",
          "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
        },
        "cancun_block": {
          "type": "string",
          "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
        }
      },
      "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
    },
    "ethermint.evm.v1.EstimateGasResponse": {
      "type": "object",
      "properties": {
        "gas": {
          "type": "string",
          "format": "uint64",
          "title": "gas returns the estimated gas"
        }
      },
      "title": "EstimateGasResponse defines EstimateGas response"
    },
    "ethermint.evm.v1.Log": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "title": "address of the contract that generated the event"
        },
        "topics": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "topics is a list of topics provided by the contract."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data which is supplied by the contract, usually ABI-encoded"
        },
        "block_number": {
          "type": "string",
          "format": "uint64",
          "title": "block_number of the block in which the transaction was included"
        },
        "tx_hash": {
          "type": "string",
          "title": "tx_hash is the transaction hash"
        },
        "tx_index": {
          "type": "string",
          "format": "uint64",
          "title": "tx_index of the transaction in the block"
        },
        "block_hash": {
          "type": "string",
          "title": "block_hash of the block in which the transaction was included"
        },
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "index of the log in the block"
        },
        "removed": {
          "type": "boolean",
          "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
        }
      },
      "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
    },
    "ethermint.evm.v1.MsgEthereumTx": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "data is inner transaction data of the Ethereum transaction"
        },
        "size": {
          "type": "number",
          "format": "double",
          "title": "size is the encoded storage size of the transaction (DEPRECATED)"
        },
        "hash": {
          "type": "string",
          "title": "hash of the transaction in hex format"
        },
        "from": {
          "type": "string",
          "title": "from is the ethereum signer address in hex format. This address value is checked\nagainst the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve"
        }
      },
      "description": "MsgEthereumTx encapsulates an Ethereum transaction as an SDK message."
    },
    "ethermint.evm.v1.MsgEthereumTxResponse": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "title": "hash of the ethereum transaction in hex format. This hash differs from the\nTendermint sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference"
        },
        "logs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "title": "address of the contract that generated the event"
              },
              "topics": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "topics is a list of topics provided by the contract."
              },
              "data": {
                "type": "string",
                "format": "byte",
                "title": "data which is supplied by the contract, usually ABI-encoded"
              },
              "block_number": {
                "type": "string",
                "format": "uint64",
                "title": "block_number of the block in which the transaction was included"
              },
              "tx_hash": {
                "type": "string",
                "title": "tx_hash is the transaction hash"
              },
              "tx_index": {
                "type": "string",
                "format": "uint64",
                "title": "tx_index of the transaction in the block"
              },
              "block_hash": {
                "type": "string",
                "title": "block_hash of the block in which the transaction was included"
              },
              "index": {
                "type": "string",
                "format": "uint64",
                "title": "index of the log in the block"
              },
              "removed": {
                "type": "boolean",
                "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
              }
            },
            "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
          },
          "description": "logs contains the transaction hash and the proto-compatible ethereum\nlogs."
        },
        "ret": {
          "type": "string",
          "format": "byte",
          "title": "ret is the returned data from evm function (result or data supplied with revert\nopcode)"
        },
        "vm_error": {
          "type": "string",
          "title": "vm_error is the error returned by vm execution"
        },
        "gas_used": {
          "type": "string",
          "format": "uint64",
          "title": "gas_used specifies how much gas was consumed by the transaction"
        }
      },
      "description": "MsgEthereumTxResponse defines the Msg/EthereumTx response type."
    },
    "ethermint.evm.v1.Params": {
      "type": "object",
      "properties": {
        "evm_denom": {
          "type": "string",
          "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
        },
        "enable_create": {
          "type": "boolean",
          "title": "enable_create toggles state transitions that use the vm.Create function"
        },
        "enable_call": {
          "type": "boolean",
          "title": "enable_call toggles state transitions that use the vm.Call function"
        },
        "extra_eips": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "int64"
          },
          "title": "extra_eips defines the additional EIPs for the vm.Config"
        },
        "chain_config": {
          "title": "chain_config defines the EVM chain configuration parameters",
          "type": "object",
          "properties": {
            "homestead_block": {
              "type": "string",
              "title": "homestead_block switch (nil no fork, 0 = already homestead)"
            },
            "dao_fork_block": {
              "type": "string",
              "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
            },
            "dao_fork_support": {
              "type": "boolean",
              "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork"
            },
            "eip150_block": {
              "type": "string",
              "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
            },
            "eip150_hash": {
              "type": "string",
              "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)"
            },
            "eip155_block": {
              "type": "string",
              "title": "eip155_block: EIP155Block HF block"
            },
            "eip158_block": {
              "type": "string",
              "title": "eip158_block: EIP158 HF block"
            },
            "byzantium_block": {
              "type": "string",
              "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)"
            },
            "constantinople_block": {
              "type": "string",
              "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)"
            },
            "petersburg_block": {
              "type": "string",
              "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
            },
            "istanbul_block": {
              "type": "string",
              "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)"
            },
            "muir_glacier_block": {
              "type": "string",
              "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)"
            },
            "berlin_block": {
              "type": "string",
              "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
            },
            "london_block": {
              "type": "string",
              "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
            },
            "arrow_glacier_block": {
              "type": "string",
              "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)"
            },
            "gray_glacier_block": {
              "type": "string",
              "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)"
            },
            "merge_netsplit_block": {
              "type": "string",
              "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter"
            },
            "shanghai_block": {
              "type": "string",
              "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
            },
            "cancun_block": {
              "type": "string",
              "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
            }
          },
          "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
        },
        "allow_unprotected_txs": {
          "type": "boolean",
          "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
        },
        "active_precompiles": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active"
        }
      },
      "title": "Params defines the EVM module parameters"
    },
    "ethermint.evm.v1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "string",
          "description": "balance is the balance of the EVM denomination."
        },
        "code_hash": {
          "type": "string",
          "description": "code_hash is the hex-formatted code bytes from the EOA."
        },
        "nonce": {
          "type": "string",
          "format": "uint64",
          "description": "nonce is the account's sequence number."
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "ethermint.evm.v1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "string",
          "description": "balance is the balance of the EVM denomination."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "ethermint.evm.v1.QueryBaseFeeResponse": {
      "type": "object",
      "properties": {
        "base_fee": {
          "type": "string",
          "title": "base_fee is the EIP1559 base fee"
        }
      },
      "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
    },
    "ethermint.evm.v1.QueryCodeResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "string",
          "format": "byte",
          "description": "code represents the code bytes from an ethereum address."
        }
      },
      "description": "QueryCodeResponse is the response type for the Query/Code RPC\nmethod."
    },
    "ethermint.evm.v1.QueryCosmosAccountResponse": {
      "type": "object",
      "properties": {
        "cosmos_address": {
          "type": "string",
          "description": "cosmos_address is the cosmos address of the account."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the account's sequence number."
        },
        "account_number": {
          "type": "string",
          "format": "uint64",
          "title": "account_number is the account number"
        }
      },
      "description": "QueryCosmosAccountResponse is the response type for the Query/CosmosAccount\nRPC method."
    },
    "ethermint.evm.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params define the evm module parameters.",
          "type": "object",
          "properties": {
            "evm_denom": {
              "type": "string",
              "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
            },
            "enable_create": {
              "type": "boolean",
              "title": "enable_create toggles state transitions that use the vm.Create function"
            },
            "enable_call": {
              "type": "boolean",
              "title": "enable_call toggles state transitions that use the vm.Call function"
            },
            "extra_eips": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "int64"
              },
              "title": "extra_eips defines the additional EIPs for the vm.Config"
            },
            "chain_config": {
              "title": "chain_config defines the EVM chain configuration parameters",
              "type": "object",
              "properties": {
                "homestead_block": {
                  "type": "string",
                  "title": "homestead_block switch (nil no fork, 0 = already homestead)"
                },
                "dao_fork_block": {
                  "type": "string",
                  "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
                },
                "dao_fork_support": {
                  "type": "boolean",
                  "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork"
                },
                "eip150_block": {
                  "type": "string",
                  "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
                },
                "eip150_hash": {
                  "type": "string",
                  "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)"
                },
                "eip155_block": {
                  "type": "string",
                  "title": "eip155_block: EIP155Block HF block"
                },
                "eip158_block": {
                  "type": "string",
                  "title": "eip158_block: EIP158 HF block"
                },
                "byzantium_block": {
                  "type": "string",
                  "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)"
                },
                "constantinople_block": {
                  "type": "string",
                  "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)"
                },
                "petersburg_block": {
                  "type": "string",
                  "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
                },
                "istanbul_block": {
                  "type": "string",
                  "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)"
                },
                "muir_glacier_block": {
                  "type": "string",
                  "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)"
                },
                "berlin_block": {
                  "type": "string",
                  "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
                },
                "london_block": {
                  "type": "string",
                  "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
                },
                "arrow_glacier_block": {
                  "type": "string",
                  "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)"
                },
                "gray_glacier_block": {
                  "type": "string",
                  "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)"
                },
                "merge_netsplit_block": {
                  "type": "string",
                  "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter"
                },
                "shanghai_block": {
                  "type": "string",
                  "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
                },
                "cancun_block": {
                  "type": "string",
                  "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
                }
              },
              "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
            },
            "allow_unprotected_txs": {
              "type": "boolean",
              "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
            },
            "active_precompiles": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active"
            }
          },
          "title": "Params defines the EVM module parameters"
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
    },
    "ethermint.evm.v1.QueryStorageResponse": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "value defines the storage state value hash associated with the given key."
        }
      },
      "description": "QueryStorageResponse is the response type for the Query/Storage RPC\nmethod."
    },
    "ethermint.evm.v1.QueryTraceBlockResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data is the response serialized in bytes"
        }
      },
      "title": "QueryTraceBlockResponse defines TraceBlock response"
    },
    "ethermint.evm.v1.QueryTraceTxResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "title": "data is the response serialized in bytes"
        }
      },
      "title": "QueryTraceTxResponse defines TraceTx response"
    },
    "ethermint.evm.v1.QueryValidatorAccountResponse": {
      "type": "object",
      "properties": {
        "account_address": {
          "type": "string",
          "description": "account_address is the cosmos address of the account in bech32 format."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the account's sequence number."
        },
        "account_number": {
          "type": "string",
          "format": "uint64",
          "title": "account_number is the account number"
        }
      },
      "description": "QueryValidatorAccountResponse is the response type for the\nQuery/ValidatorAccount RPC method."
    },
    "ethermint.evm.v1.TraceConfig": {
      "type": "object",
      "properties": {
        "tracer": {
          "type": "string",
          "title": "tracer is a custom javascript tracer"
        },
        "timeout": {
          "type": "string",
          "title": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls"
        },
        "reexec": {
          "type": "string",
          "format": "uint64",
          "title": "reexec defines the number of blocks the tracer is willing to go back"
        },
        "disable_stack": {
          "type": "boolean",
          "title": "disable_stack switches stack capture"
        },
        "disable_storage": {
          "type": "boolean",
          "title": "disable_storage switches storage capture"
        },
        "debug": {
          "type": "boolean",
          "title": "debug can be used to print output during capture end"
        },
        "limit": {
          "type": "integer",
          "format": "int32",
          "title": "limit defines the maximum length of output, but zero means unlimited"
        },
        "overrides": {
          "title": "overrides can be used to execute a trace using future fork rules",
          "type": "object",
          "properties": {
            "homestead_block": {
              "type": "string",
              "title": "homestead_block switch (nil no fork, 0 = already homestead)"
            },
            "dao_fork_block": {
              "type": "string",
              "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)"
            },
            "dao_fork_support": {
              "type": "boolean",
              "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork"
            },
            "eip150_block": {
              "type": "string",
              "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)"
            },
            "eip150_hash": {
              "type": "string",
              "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)"
            },
            "eip155_block": {
              "type": "string",
              "title": "eip155_block: EIP155Block HF block"
            },
            "eip158_block": {
              "type": "string",
              "title": "eip158_block: EIP158 HF block"
            },
            "byzantium_block": {
              "type": "string",
              "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)"
            },
            "constantinople_block": {
              "type": "string",
              "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)"
            },
            "petersburg_block": {
              "type": "string",
              "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)"
            },
            "istanbul_block": {
              "type": "string",
              "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)"
            },
            "muir_glacier_block": {
              "type": "string",
              "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)"
            },
            "berlin_block": {
              "type": "string",
              "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)"
            },
            "london_block": {
              "type": "string",
              "title": "london_block: London switch block (nil = no fork, 0 = already on london)"
            },
            "arrow_glacier_block": {
              "type": "string",
              "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)"
            },
            "gray_glacier_block": {
              "type": "string",
              "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)"
            },
            "merge_netsplit_block": {
              "type": "string",
              "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter"
            },
            "shanghai_block": {
              "type": "string",
              "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)"
            },
            "cancun_block": {
              "type": "string",
              "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)"
            }
          },
          "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
        },
        "enable_memory": {
          "type": "boolean",
          "title": "enable_memory switches memory capture"
        },
        "enable_return_data": {
          "type": "boolean",
          "title": "enable_return_data switches the capture of return data"
        },
        "tracer_json_config": {
          "type": "string",
          "title": "tracer_json_config configures the tracer using a JSON string"
        }
      },
      "description": "TraceConfig holds extra parameters to trace functions."
    },
    "ethermint.feemarket.v1.Params": {
      "type": "object",
      "properties": {
        "no_base_fee": {
          "type": "boolean",
          "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)"
        },
        "base_fee_change_denominator": {
          "type": "integer",
          "format": "int64",
          "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks."
        },
        "elasticity_multiplier": {
          "type": "integer",
          "format": "int64",
          "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave."
        },
        "enable_height": {
          "type": "string",
          "format": "int64",
          "description": "enable_height defines at which block height the base fee calculation is enabled."
        },
        "base_fee": {
          "type": "string",
          "description": "base_fee for EIP-1559 blocks."
        },
        "min_gas_price": {
          "type": "string",
          "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions"
        },
        "min_gas_multiplier": {
          "type": "string",
          "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit"
        }
      },
      "title": "Params defines the EVM module parameters"
    },
    "ethermint.feemarket.v1.QueryBaseFeeResponse": {
      "type": "object",
      "properties": {
        "base_fee": {
          "type": "string",
          "title": "base_fee is the EIP1559 base fee"
        }
      },
      "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
    },
    "ethermint.feemarket.v1.QueryBlockGasResponse": {
      "type": "object",
      "properties": {
        "gas": {
          "type": "string",
          "format": "int64",
          "title": "gas is the returned block gas"
        }
      },
      "description": "QueryBlockGasResponse returns block gas used for a given height."
    },
    "ethermint.feemarket.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params define the evm module parameters.",
          "type": "object",
          "properties": {
            "no_base_fee": {
              "type": "boolean",
              "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)"
            },
            "base_fee_change_denominator": {
              "type": "integer",
              "format": "int64",
              "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks."
            },
            "elasticity_multiplier": {
              "type": "integer",
              "format": "int64",
              "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave."
            },
            "enable_height": {
              "type": "string",
              "format": "int64",
              "description": "enable_height defines at which block height the base fee calculation is enabled."
            },
            "base_fee": {
              "type": "string",
              "description": "base_fee for EIP-1559 blocks."
            },
            "min_gas_price": {
              "type": "string",
              "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions"
            },
            "min_gas_multiplier": {
              "type": "string",
              "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit"
            }
          },
          "title": "Params defines the EVM module parameters"
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
    },
    "cosmos.base.v1beta1.Coin": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "amount": {
          "type": "string"
        }
      },
      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
    },
    "ibc.applications.transfer.v1.DenomTrace": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
        },
        "base_denom": {
          "type": "string",
          "description": "base denomination of the relayed fungible token."
        }
      },
      "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
    },
    "ibc.applications.transfer.v1.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "boolean",
          "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
        },
        "receive_enabled": {
          "type": "boolean",
          "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
        }
      },
      "description": "Params defines the set of IBC transfer parameters.\nNOTE: To prevent a single token from being transferred, set the\nTransfersEnabled parameter to true and then set the bank module's SendEnabled\nparameter for the denomination to false."
    },
    "ibc.applications.transfer.v1.QueryDenomHashResponse": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "description": "hash (in hex format) of the denomination trace information."
        }
      },
      "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod."
    },
    "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
      "type": "object",
      "properties": {
        "denom_trace": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
            },
            "base_denom": {
              "type": "string",
              "description": "base denomination of the relayed fungible token."
            }
          },
          "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
        }
      },
      "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
    },
    "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
      "type": "object",
      "properties": {
        "denom_traces": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
              },
              "base_denom": {
                "type": "string",
                "description": "base denomination of the relayed fungible token."
              }
            },
            "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
          },
          "description": "denom_traces returns all denominations trace information."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
    },
    "ibc.applications.transfer.v1.QueryEscrowAddressResponse": {
      "type": "object",
      "properties": {
        "escrow_address": {
          "type": "string",
          "title": "the escrow account address"
        }
      },
      "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method."
    },
    "ibc.applications.transfer.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "boolean",
              "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
            },
            "receive_enabled": {
              "type": "boolean",
              "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method."
    },
    "ibc.core.client.v1.ConsensusStateWithHeight": {
      "type": "object",
      "properties": {
        "height": {
          "title": "consensus state height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        },
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state"
        }
      },
      "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
    },
    "ibc.core.client.v1.Height": {
      "type": "object",
      "properties": {
        "revision_number": {
          "type": "string",
          "format": "uint64",
          "title": "the revision that the client is currently on"
        },
        "revision_height": {
          "type": "string",
          "format": "uint64",
          "title": "the height within the given revision"
        }
      },
      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
      "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
    },
    "ibc.core.client.v1.IdentifiedClientState": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client identifier"
        },
        "client_state": {
          "title": "client state",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
    },
    "ibc.core.client.v1.Params": {
      "type": "object",
      "properties": {
        "allowed_clients": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list."
        }
      },
      "description": "Params defines the set of IBC light client parameters."
    },
    "ibc.core.client.v1.QueryClientParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "allowed_clients": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list."
            }
          }
        }
      },
      "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
    },
    "ibc.core.client.v1.QueryClientStateResponse": {
      "type": "object",
      "properties": {
        "client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "client state associated with the request identifier"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.core.client.v1.QueryClientStatesResponse": {
      "type": "object",
      "properties": {
        "client_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "title": "client identifier"
              },
              "client_state": {
                "title": "client state",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              }
            },
            "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
          },
          "description": "list of stored ClientStates of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
    },
    "ibc.core.client.v1.QueryClientStatusResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      },
      "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
    },
    "ibc.core.client.v1.QueryConsensusStateHeightsResponse": {
      "type": "object",
      "properties": {
        "consensus_state_heights": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "revision_number": {
                "type": "string",
                "format": "uint64",
                "title": "the revision that the client is currently on"
              },
              "revision_height": {
                "type": "string",
                "format": "uint64",
                "title": "the height within the given revision"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
            "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
          },
          "title": "consensus state heights"
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method"
    },
    "ibc.core.client.v1.QueryConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the client identifier at the given height"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset",
          "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients"
        }
      },
      "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method"
    },
    "ibc.core.client.v1.QueryConsensusStatesResponse": {
      "type": "object",
      "properties": {
        "consensus_states": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "height": {
                "title": "consensus state height",
                "type": "object",
                "properties": {
                  "revision_number": {
                    "type": "string",
                    "format": "uint64",
                    "title": "the revision that the client is currently on"
                  },
                  "revision_height": {
                    "type": "string",
                    "format": "uint64",
                    "title": "the height within the given revision"
                  }
                },
                "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
              },
              "consensus_state": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                "title": "consensus state"
              }
            },
            "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
          },
          "title": "consensus states associated with the identifier"
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method"
    },
    "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "client state associated with the request identifier"
        }
      },
      "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
    },
    "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "Consensus state associated with the request identifier"
        }
      },
      "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
    },
    "ibc.core.commitment.v1.MerklePrefix": {
      "type": "object",
      "properties": {
        "key_prefix": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
    },
    "ibc.core.connection.v1.ConnectionEnd": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string",
                "title": "unique version identifier"
              },
              "features": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of features compatible with the specified identifier"
              }
            },
            "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
          },
          "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "description": "commitment merkle prefix of the counterparty chain.",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
            }
          }
        },
        "delay_period": {
          "type": "string",
          "format": "uint64",
          "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
        }
      },
      "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
    },
    "ibc.core.connection.v1.Counterparty": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "description": "identifies the client on the counterparty chain associated with a given\nconnection."
        },
        "connection_id": {
          "type": "string",
          "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
        },
        "prefix": {
          "description": "commitment merkle prefix of the counterparty chain.",
          "type": "object",
          "properties": {
            "key_prefix": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
        }
      },
      "description": "Counterparty defines the counterparty chain associated with a connection end."
    },
    "ibc.core.connection.v1.IdentifiedConnection": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "connection identifier."
        },
        "client_id": {
          "type": "string",
          "description": "client associated with this connection."
        },
        "versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "identifier": {
                "type": "string",
                "title": "unique version identifier"
              },
              "features": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of features compatible with the specified identifier"
              }
            },
            "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
          },
          "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
        },
        "state": {
          "description": "current state of the connection end.",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED"
        },
        "counterparty": {
          "description": "counterparty chain associated with this connection.",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
            },
            "connection_id": {
              "type": "string",
              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
            },
            "prefix": {
              "description": "commitment merkle prefix of the counterparty chain.",
              "type": "object",
              "properties": {
                "key_prefix": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
            }
          }
        },
        "delay_period": {
          "type": "string",
          "format": "uint64",
          "description": "delay period associated with this connection."
        }
      },
      "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
    },
    "ibc.core.connection.v1.Params": {
      "type": "object",
      "properties": {
        "max_expected_time_per_block": {
          "type": "string",
          "format": "uint64",
          "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block."
        }
      },
      "description": "Params defines the set of Connection parameters."
    },
    "ibc.core.connection.v1.QueryClientConnectionsResponse": {
      "type": "object",
      "properties": {
        "connection_paths": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "slice of all the connection paths associated with a client."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was generated",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
              "title": "client state"
            }
          },
          "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the channel"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method"
    },
    "ibc.core.connection.v1.QueryConnectionParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "max_expected_time_per_block": {
              "type": "string",
              "format": "uint64",
              "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block."
            }
          }
        }
      },
      "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method."
    },
    "ibc.core.connection.v1.QueryConnectionResponse": {
      "type": "object",
      "properties": {
        "connection": {
          "title": "connection associated with the request identifier",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "description": "client associated with this connection."
            },
            "versions": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "identifier": {
                    "type": "string",
                    "title": "unique version identifier"
                  },
                  "features": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "title": "list of features compatible with the specified identifier"
                  }
                },
                "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
              },
              "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection."
            },
            "state": {
              "description": "current state of the connection end.",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED"
            },
            "counterparty": {
              "description": "counterparty chain associated with this connection.",
              "type": "object",
              "properties": {
                "client_id": {
                  "type": "string",
                  "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                },
                "connection_id": {
                  "type": "string",
                  "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                },
                "prefix": {
                  "description": "commitment merkle prefix of the counterparty chain.",
                  "type": "object",
                  "properties": {
                    "key_prefix": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                }
              }
            },
            "delay_period": {
              "type": "string",
              "format": "uint64",
              "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients."
            }
          },
          "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
    },
    "ibc.core.connection.v1.QueryConnectionsResponse": {
      "type": "object",
      "properties": {
        "connections": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "connection identifier."
              },
              "client_id": {
                "type": "string",
                "description": "client associated with this connection."
              },
              "versions": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "identifier": {
                      "type": "string",
                      "title": "unique version identifier"
                    },
                    "features": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "list of features compatible with the specified identifier"
                    }
                  },
                  "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                },
                "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection"
              },
              "state": {
                "description": "current state of the connection end.",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED"
              },
              "counterparty": {
                "description": "counterparty chain associated with this connection.",
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                  },
                  "connection_id": {
                    "type": "string",
                    "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                  },
                  "prefix": {
                    "description": "commitment merkle prefix of the counterparty chain.",
                    "type": "object",
                    "properties": {
                      "key_prefix": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))"
                  }
                }
              },
              "delay_period": {
                "type": "string",
                "format": "uint64",
                "description": "delay period associated with this connection."
              }
            },
            "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
          },
          "description": "list of stored connections of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
    },
    "ibc.core.connection.v1.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a connection is in one of the following states:\nINIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A connection end has just started the opening handshake.\n - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\nchain.\n - STATE_OPEN: A connection end has completed the handshake."
    },
    "ibc.core.connection.v1.Version": {
      "type": "object",
      "properties": {
        "identifier": {
          "type": "string",
          "title": "unique version identifier"
        },
        "features": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of features compatible with the specified identifier"
        }
      },
      "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
    },
    "ibc.core.channel.v1.Channel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        }
      },
      "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
    },
    "ibc.core.channel.v1.Counterparty": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "port on the counterparty chain which owns the other end of the channel."
        },
        "channel_id": {
          "type": "string",
          "title": "channel end on the counterparty chain"
        }
      },
      "title": "Counterparty defines a channel end counterparty"
    },
    "ibc.core.channel.v1.IdentifiedChannel": {
      "type": "object",
      "properties": {
        "state": {
          "title": "current state of the channel end",
          "type": "string",
          "enum": [
            "STATE_UNINITIALIZED_UNSPECIFIED",
            "STATE_INIT",
            "STATE_TRYOPEN",
            "STATE_OPEN",
            "STATE_CLOSED"
          ],
          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
        },
        "ordering": {
          "title": "whether the channel is ordered or unordered",
          "type": "string",
          "enum": [
            "ORDER_NONE_UNSPECIFIED",
            "ORDER_UNORDERED",
            "ORDER_ORDERED"
          ],
          "default": "ORDER_NONE_UNSPECIFIED",
          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
        },
        "counterparty": {
          "title": "counterparty channel end",
          "type": "object",
          "properties": {
            "port_id": {
              "type": "string",
              "description": "port on the counterparty chain which owns the other end of the channel."
            },
            "channel_id": {
              "type": "string",
              "title": "channel end on the counterparty chain"
            }
          }
        },
        "connection_hops": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
        },
        "version": {
          "type": "string",
          "title": "opaque channel version, which is agreed upon during the handshake"
        },
        "port_id": {
          "type": "string",
          "title": "port identifier"
        },
        "channel_id": {
          "type": "string",
          "title": "channel identifier"
        }
      },
      "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
    },
    "ibc.core.channel.v1.Order": {
      "type": "string",
      "enum": [
        "ORDER_NONE_UNSPECIFIED",
        "ORDER_UNORDERED",
        "ORDER_ORDERED"
      ],
      "default": "ORDER_NONE_UNSPECIFIED",
      "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
      "title": "Order defines if a channel is ORDERED or UNORDERED"
    },
    "ibc.core.channel.v1.PacketState": {
      "type": "object",
      "properties": {
        "port_id": {
          "type": "string",
          "description": "channel port identifier."
        },
        "channel_id": {
          "type": "string",
          "description": "channel unique identifier."
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "packet sequence."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "embedded data that represents packet state."
        }
      },
      "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
    },
    "ibc.core.channel.v1.QueryChannelClientStateResponse": {
      "type": "object",
      "properties": {
        "identified_client_state": {
          "title": "client state associated with the channel",
          "type": "object",
          "properties": {
            "client_id": {
              "type": "string",
              "title": "client identifier"
            },
            "client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
              "title": "client state"
            }
          },
          "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
      "type": "object",
      "properties": {
        "consensus_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus state associated with the channel"
        },
        "client_id": {
          "type": "string",
          "title": "client ID associated with the consensus state"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method"
    },
    "ibc.core.channel.v1.QueryChannelResponse": {
      "type": "object",
      "properties": {
        "channel": {
          "title": "channel associated with the request identifiers",
          "type": "object",
          "properties": {
            "state": {
              "title": "current state of the channel end",
              "type": "string",
              "enum": [
                "STATE_UNINITIALIZED_UNSPECIFIED",
                "STATE_INIT",
                "STATE_TRYOPEN",
                "STATE_OPEN",
                "STATE_CLOSED"
              ],
              "default": "STATE_UNINITIALIZED_UNSPECIFIED",
              "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
            },
            "ordering": {
              "title": "whether the channel is ordered or unordered",
              "type": "string",
              "enum": [
                "ORDER_NONE_UNSPECIFIED",
                "ORDER_UNORDERED",
                "ORDER_ORDERED"
              ],
              "default": "ORDER_NONE_UNSPECIFIED",
              "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
            },
            "counterparty": {
              "title": "counterparty channel end",
              "type": "object",
              "properties": {
                "port_id": {
                  "type": "string",
                  "description": "port on the counterparty chain which owns the other end of the channel."
                },
                "channel_id": {
                  "type": "string",
                  "title": "channel end on the counterparty chain"
                }
              }
            },
            "connection_hops": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
            },
            "version": {
              "type": "string",
              "title": "opaque channel version, which is agreed upon during the handshake"
            }
          },
          "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
    },
    "ibc.core.channel.v1.QueryChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of stored channels of the chain."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
    },
    "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
      "type": "object",
      "properties": {
        "channels": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ],
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ],
                "default": "ORDER_NONE_UNSPECIFIED",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent"
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "type": "string",
                    "title": "channel end on the counterparty chain"
                  }
                }
              },
              "connection_hops": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel"
              },
              "version": {
                "type": "string",
                "title": "opaque channel version, which is agreed upon during the handshake"
              },
              "port_id": {
                "type": "string",
                "title": "port identifier"
              },
              "channel_id": {
                "type": "string",
                "title": "channel identifier"
              }
            },
            "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
          },
          "description": "list of channels associated with a connection."
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method"
    },
    "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
      "type": "object",
      "properties": {
        "next_sequence_receive": {
          "type": "string",
          "format": "uint64",
          "title": "next sequence receive number"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method"
    },
    "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
      "type": "object",
      "properties": {
        "acknowledgement": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved"
    },
    "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
      "type": "object",
      "properties": {
        "acknowledgements": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "channel port identifier."
              },
              "channel_id": {
                "type": "string",
                "description": "channel unique identifier."
              },
              "sequence": {
                "type": "string",
                "format": "uint64",
                "description": "packet sequence."
              },
              "data": {
                "type": "string",
                "format": "byte",
                "description": "embedded data that represents packet state."
              }
            },
            "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
          }
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method"
    },
    "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
      "type": "object",
      "properties": {
        "commitment": {
          "type": "string",
          "format": "byte",
          "title": "packet associated with the request fields"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved"
    },
    "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
      "type": "object",
      "properties": {
        "commitments": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "channel port identifier."
              },
              "channel_id": {
                "type": "string",
                "description": "channel unique identifier."
              },
              "sequence": {
                "type": "string",
                "format": "uint64",
                "description": "packet sequence."
              },
              "data": {
                "type": "string",
                "format": "byte",
                "description": "embedded data that represents packet state."
              }
            },
            "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
          }
        },
        "pagination": {
          "title": "pagination response",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method"
    },
    "ibc.core.channel.v1.QueryPacketReceiptResponse": {
      "type": "object",
      "properties": {
        "received": {
          "type": "boolean",
          "title": "success flag for if receipt exists"
        },
        "proof": {
          "type": "string",
          "format": "byte",
          "title": "merkle proof of existence"
        },
        "proof_height": {
          "title": "height at which the proof was retrieved",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved"
    },
    "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unreceived acknowledgement sequences"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method"
    },
    "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "list of unreceived packet sequences"
        },
        "height": {
          "title": "query block height",
          "type": "object",
          "properties": {
            "revision_number": {
              "type": "string",
              "format": "uint64",
              "title": "the revision that the client is currently on"
            },
            "revision_height": {
              "type": "string",
              "format": "uint64",
              "title": "the height within the given revision"
            }
          },
          "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
        }
      },
      "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method"
    },
    "ibc.core.channel.v1.State": {
      "type": "string",
      "enum": [
        "STATE_UNINITIALIZED_UNSPECIFIED",
        "STATE_INIT",
        "STATE_TRYOPEN",
        "STATE_OPEN",
        "STATE_CLOSED"
      ],
      "default": "STATE_UNINITIALIZED_UNSPECIFIED",
      "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets."
    },
    "cosmos.auth.v1beta1.AddressBytesToStringResponse": {
      "type": "object",
      "properties": {
        "address_string": {
          "type": "string"
        }
      },
      "description": "AddressBytesToStringResponse is the response type for AddressString rpc method.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.auth.v1beta1.AddressStringToBytesResponse": {
      "type": "object",
      "properties": {
        "address_bytes": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.auth.v1beta1.BaseAccount": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "account_number": {
          "type": "string",
          "format": "uint64"
        },
        "sequence": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "BaseAccount defines a base account type. It contains all the necessary fields\nfor basic account functionality. Any custom account type should extend this\ntype for additional functionality (e.g. vesting)."
    },
    "cosmos.auth.v1beta1.Bech32PrefixResponse": {
      "type": "object",
      "properties": {
        "bech32_prefix": {
          "type": "string"
        }
      },
      "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.auth.v1beta1.Params": {
      "type": "object",
      "properties": {
        "max_memo_characters": {
          "type": "string",
          "format": "uint64"
        },
        "tx_sig_limit": {
          "type": "string",
          "format": "uint64"
        },
        "tx_size_cost_per_byte": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_ed25519": {
          "type": "string",
          "format": "uint64"
        },
        "sig_verify_cost_secp256k1": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Params defines the parameters for the auth module."
    },
    "cosmos.auth.v1beta1.QueryAccountAddressByIDResponse": {
      "type": "object",
      "properties": {
        "account_address": {
          "type": "string"
        }
      },
      "description": "Since: cosmos-sdk 0.46.2",
      "title": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method"
    },
    "cosmos.auth.v1beta1.QueryAccountInfoResponse": {
      "type": "object",
      "properties": {
        "info": {
          "description": "info is the account info which is represented by BaseAccount.",
          "type": "object",
          "properties": {
            "address": {
              "type": "string"
            },
            "pub_key": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "account_number": {
              "type": "string",
              "format": "uint64"
            },
            "sequence": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryAccountInfoResponse is the Query/AccountInfo response type.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      "type": "object",
      "properties": {
        "account": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
    },
    "cosmos.auth.v1beta1.QueryAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "accounts are the existing accounts"
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.auth.v1beta1.QueryModuleAccountByNameResponse": {
      "type": "object",
      "properties": {
        "account": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."
    },
    "cosmos.auth.v1beta1.QueryModuleAccountsResponse": {
      "type": "object",
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        }
      },
      "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "max_memo_characters": {
              "type": "string",
              "format": "uint64"
            },
            "tx_sig_limit": {
              "type": "string",
              "format": "uint64"
            },
            "tx_size_cost_per_byte": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_ed25519": {
              "type": "string",
              "format": "uint64"
            },
            "sig_verify_cost_secp256k1": {
              "type": "string",
              "format": "uint64"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.authz.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "authorization": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "expiration": {
          "type": "string",
          "format": "date-time",
          "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)"
        }
      },
      "description": "Grant gives permissions to execute\nthe provide method with expiration time."
    },
    "cosmos.authz.v1beta1.GrantAuthorization": {
      "type": "object",
      "properties": {
        "granter": {
          "type": "string"
        },
        "grantee": {
          "type": "string"
        },
        "authorization": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "expiration": {
          "type": "string",
          "format": "date-time"
        }
      },
      "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
    },
    "cosmos.authz.v1beta1.QueryGranteeGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "granter": {
                "type": "string"
              },
              "grantee": {
                "type": "string"
              },
              "authorization": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "expiration": {
                "type": "string",
                "format": "date-time"
              }
            },
            "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
          },
          "description": "grants is a list of grants granted to the grantee."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."
    },
    "cosmos.authz.v1beta1.QueryGranterGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "granter": {
                "type": "string"
              },
              "grantee": {
                "type": "string"
              },
              "authorization": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "expiration": {
                "type": "string",
                "format": "date-time"
              }
            },
            "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto"
          },
          "description": "grants is a list of grants granted by the granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."
    },
    "cosmos.authz.v1beta1.QueryGrantsResponse": {
      "type": "object",
      "properties": {
        "grants": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "authorization": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "expiration": {
                "type": "string",
                "format": "date-time",
                "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)"
              }
            },
            "description": "Grant gives permissions to execute\nthe provide method with expiration time."
          },
          "description": "authorizations is a list of grants granted for grantee by granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
    },
    "cosmos.bank.v1beta1.DenomOwner": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "description": "address defines the address that owns a particular denomination."
        },
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.bank.v1beta1.DenomUnit": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string",
          "description": "denom represents the string name of the given denom unit (e.g uatom)."
        },
        "exponent": {
          "type": "integer",
          "format": "int64",
          "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
        },
        "aliases": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "aliases is a list of string aliases for the given denom"
        }
      },
      "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
    },
    "cosmos.bank.v1beta1.Metadata": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "denom_units": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string",
                "description": "denom represents the string name of the given denom unit (e.g uatom)."
              },
              "exponent": {
                "type": "integer",
                "format": "int64",
                "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
              },
              "aliases": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "aliases is a list of string aliases for the given denom"
              }
            },
            "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
          },
          "title": "denom_units represents the list of DenomUnit's for a given coin"
        },
        "base": {
          "type": "string",
          "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
        },
        "display": {
          "type": "string",
          "description": "display indicates the suggested denom that should be\ndisplayed in clients."
        },
        "name": {
          "type": "string",
          "description": "Since: cosmos-sdk 0.43",
          "title": "name defines the name of the token (eg: Cosmos Atom)"
        },
        "symbol": {
          "type": "string",
          "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
        },
        "uri": {
          "type": "string",
          "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
        },
        "uri_hash": {
          "type": "string",
          "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
        }
      },
      "description": "Metadata represents a struct that describes\na basic token."
    },
    "cosmos.bank.v1beta1.Params": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "enabled": {
                "type": "boolean"
              }
            },
            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
          },
          "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
        },
        "default_send_enabled": {
          "type": "boolean"
        }
      },
      "description": "Params defines the parameters for the bank module."
    },
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "balances is the balances of all the coins."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
    },
    "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string"
            },
            "denom_units": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string",
                    "description": "denom represents the string name of the given denom unit (e.g uatom)."
                  },
                  "exponent": {
                    "type": "integer",
                    "format": "int64",
                    "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                  },
                  "aliases": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "title": "aliases is a list of string aliases for the given denom"
                  }
                },
                "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
              },
              "title": "denom_units represents the list of DenomUnit's for a given coin"
            },
            "base": {
              "type": "string",
              "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
            },
            "display": {
              "type": "string",
              "description": "display indicates the suggested denom that should be\ndisplayed in clients."
            },
            "name": {
              "type": "string",
              "description": "Since: cosmos-sdk 0.43",
              "title": "name defines the name of the token (eg: Cosmos Atom)"
            },
            "symbol": {
              "type": "string",
              "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
            },
            "uri": {
              "type": "string",
              "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
            },
            "uri_hash": {
              "type": "string",
              "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "description": "Metadata represents a struct that describes\na basic token."
        }
      },
      "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryDenomOwnersResponse": {
      "type": "object",
      "properties": {
        "denom_owners": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "description": "address defines the address that owns a particular denomination."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
      "type": "object",
      "properties": {
        "metadatas": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string"
              },
              "denom_units": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "description": "denom represents the string name of the given denom unit (e.g uatom)."
                    },
                    "exponent": {
                      "type": "integer",
                      "format": "int64",
                      "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom)."
                    },
                    "aliases": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "title": "aliases is a list of string aliases for the given denom"
                    }
                  },
                  "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                },
                "title": "denom_units represents the list of DenomUnit's for a given coin"
              },
              "base": {
                "type": "string",
                "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
              },
              "display": {
                "type": "string",
                "description": "display indicates the suggested denom that should be\ndisplayed in clients."
              },
              "name": {
                "type": "string",
                "description": "Since: cosmos-sdk 0.43",
                "title": "name defines the name of the token (eg: Cosmos Atom)"
              },
              "symbol": {
                "type": "string",
                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
              },
              "uri": {
                "type": "string",
                "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
              },
              "uri_hash": {
                "type": "string",
                "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
              }
            },
            "description": "Metadata represents a struct that describes\na basic token."
          },
          "description": "metadata provides the client information for all the registered tokens."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
    },
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "send_enabled": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "enabled": {
                    "type": "boolean"
                  }
                },
                "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
              },
              "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."
            },
            "default_send_enabled": {
              "type": "boolean"
            }
          },
          "description": "Params defines the parameters for the bank module."
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
    },
    "cosmos.bank.v1beta1.QuerySendEnabledResponse": {
      "type": "object",
      "properties": {
        "send_enabled": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "enabled": {
                "type": "boolean"
              }
            },
            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
          }
        },
        "pagination": {
          "description": "pagination defines the pagination in the response. This field is only\npopulated if the denoms field in the request is empty.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse": {
      "type": "object",
      "properties": {
        "balance": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for\nquerying an account's spendable balance for a specific denom.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.bank.v1beta1.QuerySpendableBalancesResponse": {
      "type": "object",
      "properties": {
        "balances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "balances is the spendable balances of all the coins."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying\nan account's spendable balances.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "object",
          "properties": {
            "denom": {
              "type": "string"
            },
            "amount": {
              "type": "string"
            }
          },
          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
        }
      },
      "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
    },
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      "type": "object",
      "properties": {
        "supply": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "supply is the supply of the coins"
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod"
    },
    "cosmos.bank.v1beta1.SendEnabled": {
      "type": "object",
      "properties": {
        "denom": {
          "type": "string"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
    },
    "cosmos.feegrant.v1beta1.Grant": {
      "type": "object",
      "properties": {
        "granter": {
          "type": "string",
          "description": "granter is the address of the user granting an allowance of their funds."
        },
        "grantee": {
          "type": "string",
          "description": "grantee is the address of the user being granted an allowance of another user's funds."
        },
        "allowance": {
          "description": "allowance can be any of basic, periodic, allowed fee allowance.",
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          }
        }
      },
      "title": "Grant is stored in the KVStore to record a grant with full context"
    },
    "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
      "type": "object",
      "properties": {
        "allowance": {
          "description": "allowance is a allowance granted for grantee by granter.",
          "type": "object",
          "properties": {
            "granter": {
              "type": "string",
              "description": "granter is the address of the user granting an allowance of their funds."
            },
            "grantee": {
              "type": "string",
              "description": "grantee is the address of the user being granted an allowance of another user's funds."
            },
            "allowance": {
              "description": "allowance can be any of basic, periodic, allowed fee allowance.",
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              }
            }
          },
          "title": "Grant is stored in the KVStore to record a grant with full context"
        }
      },
      "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
    },
    "cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse": {
      "type": "object",
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "granter": {
                "type": "string",
                "description": "granter is the address of the user granting an allowance of their funds."
              },
              "grantee": {
                "type": "string",
                "description": "grantee is the address of the user being granted an allowance of another user's funds."
              },
              "allowance": {
                "description": "allowance can be any of basic, periodic, allowed fee allowance.",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                }
              }
            },
            "title": "Grant is stored in the KVStore to record a grant with full context"
          },
          "description": "allowances that have been issued by the granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
      "type": "object",
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "granter": {
                "type": "string",
                "description": "granter is the address of the user granting an allowance of their funds."
              },
              "grantee": {
                "type": "string",
                "description": "grantee is the address of the user being granted an allowance of another user's funds."
              },
              "allowance": {
                "description": "allowance can be any of basic, periodic, allowed fee allowance.",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                }
              }
            },
            "title": "Grant is stored in the KVStore to record a grant with full context"
          },
          "description": "allowances are allowance's granted for grantee by granter."
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
    },
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "evidence returns all evidences."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
    },
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
    },
    "cosmos.gov.v1beta1.Deposit": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "amount to be deposited by depositor."
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
    },
    "cosmos.gov.v1beta1.DepositParams": {
      "type": "object",
      "properties": {
        "min_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "max_deposit_period": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1beta1.Proposal": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "content": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "status": {
          "description": "status defines the proposal status.",
          "type": "string",
          "enum": [
            "PROPOSAL_STATUS_UNSPECIFIED",
            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
            "PROPOSAL_STATUS_VOTING_PERIOD",
            "PROPOSAL_STATUS_PASSED",
            "PROPOSAL_STATUS_REJECTED",
            "PROPOSAL_STATUS_FAILED"
          ],
          "default": "PROPOSAL_STATUS_UNSPECIFIED"
        },
        "final_tally_result": {
          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
          "type": "object",
          "properties": {
            "yes": {
              "type": "string",
              "description": "yes is the number of yes votes on a proposal."
            },
            "abstain": {
              "type": "string",
              "description": "abstain is the number of abstain votes on a proposal."
            },
            "no": {
              "type": "string",
              "description": "no is the number of no votes on a proposal."
            },
            "no_with_veto": {
              "type": "string",
              "description": "no_with_veto is the number of no with veto votes on a proposal."
            }
          }
        },
        "submit_time": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is the time of proposal submission."
        },
        "deposit_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "deposit_end_time is the end time for deposition."
        },
        "total_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "total_deposit is the total deposit on the proposal."
        },
        "voting_start_time": {
          "type": "string",
          "format": "date-time",
          "description": "voting_start_time is the starting time to vote on a proposal."
        },
        "voting_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "voting_end_time is the end time of voting on a proposal."
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1beta1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
    },
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64",
              "description": "proposal_id defines the unique id of the proposal."
            },
            "depositor": {
              "type": "string",
              "description": "depositor defines the deposit addresses from the proposals."
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "amount to be deposited by depositor."
            }
          },
          "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64",
                "description": "proposal_id defines the unique id of the proposal."
              },
              "depositor": {
                "type": "string",
                "description": "depositor defines the deposit addresses from the proposals."
              },
              "amount": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "description": "amount to be deposited by depositor."
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
          },
          "description": "deposits defines the requested deposits."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "voting_params": {
          "description": "voting_params defines the parameters related to voting.",
          "type": "object",
          "properties": {
            "voting_period": {
              "type": "string",
              "description": "Duration of the voting period."
            }
          }
        },
        "deposit_params": {
          "description": "deposit_params defines the parameters related to deposit.",
          "type": "object",
          "properties": {
            "min_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "Minimum deposit for a proposal to enter voting period."
            },
            "max_deposit_period": {
              "type": "string",
              "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
            }
          }
        },
        "tally_params": {
          "description": "tally_params defines the parameters related to tally.",
          "type": "object",
          "properties": {
            "quorum": {
              "type": "string",
              "format": "byte",
              "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
            },
            "threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
            },
            "veto_threshold": {
              "type": "string",
              "format": "byte",
              "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64",
              "description": "proposal_id defines the unique id of the proposal."
            },
            "content": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "status": {
              "description": "status defines the proposal status.",
              "type": "string",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ],
              "default": "PROPOSAL_STATUS_UNSPECIFIED"
            },
            "final_tally_result": {
              "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
              "type": "object",
              "properties": {
                "yes": {
                  "type": "string",
                  "description": "yes is the number of yes votes on a proposal."
                },
                "abstain": {
                  "type": "string",
                  "description": "abstain is the number of abstain votes on a proposal."
                },
                "no": {
                  "type": "string",
                  "description": "no is the number of no votes on a proposal."
                },
                "no_with_veto": {
                  "type": "string",
                  "description": "no_with_veto is the number of no with veto votes on a proposal."
                }
              }
            },
            "submit_time": {
              "type": "string",
              "format": "date-time",
              "description": "submit_time is the time of proposal submission."
            },
            "deposit_end_time": {
              "type": "string",
              "format": "date-time",
              "description": "deposit_end_time is the end time for deposition."
            },
            "total_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "total_deposit is the total deposit on the proposal."
            },
            "voting_start_time": {
              "type": "string",
              "format": "date-time",
              "description": "voting_start_time is the starting time to vote on a proposal."
            },
            "voting_end_time": {
              "type": "string",
              "format": "date-time",
              "description": "voting_end_time is the end time of voting on a proposal."
            }
          },
          "description": "Proposal defines the core field members of a governance proposal."
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64",
                "description": "proposal_id defines the unique id of the proposal."
              },
              "content": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "status": {
                "description": "status defines the proposal status.",
                "type": "string",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ],
                "default": "PROPOSAL_STATUS_UNSPECIFIED"
              },
              "final_tally_result": {
                "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                "type": "object",
                "properties": {
                  "yes": {
                    "type": "string",
                    "description": "yes is the number of yes votes on a proposal."
                  },
                  "abstain": {
                    "type": "string",
                    "description": "abstain is the number of abstain votes on a proposal."
                  },
                  "no": {
                    "type": "string",
                    "description": "no is the number of no votes on a proposal."
                  },
                  "no_with_veto": {
                    "type": "string",
                    "description": "no_with_veto is the number of no with veto votes on a proposal."
                  }
                }
              },
              "submit_time": {
                "type": "string",
                "format": "date-time",
                "description": "submit_time is the time of proposal submission."
              },
              "deposit_end_time": {
                "type": "string",
                "format": "date-time",
                "description": "deposit_end_time is the end time for deposition."
              },
              "total_deposit": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "description": "total_deposit is the total deposit on the proposal."
              },
              "voting_start_time": {
                "type": "string",
                "format": "date-time",
                "description": "voting_start_time is the starting time to vote on a proposal."
              },
              "voting_end_time": {
                "type": "string",
                "format": "date-time",
                "description": "voting_end_time is the end time of voting on a proposal."
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          },
          "description": "proposals defines all the requested governance proposals."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
    },
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "description": "tally defines the requested tally.",
          "type": "object",
          "properties": {
            "yes": {
              "type": "string",
              "description": "yes is the number of yes votes on a proposal."
            },
            "abstain": {
              "type": "string",
              "description": "abstain is the number of abstain votes on a proposal."
            },
            "no": {
              "type": "string",
              "description": "no is the number of no votes on a proposal."
            },
            "no_with_veto": {
              "type": "string",
              "description": "no_with_veto is the number of no with veto votes on a proposal."
            }
          }
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64",
              "description": "proposal_id defines the unique id of the proposal."
            },
            "voter": {
              "type": "string",
              "description": "voter is the voter address of the proposal."
            },
            "option": {
              "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
              "type": "string",
              "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                "VOTE_OPTION_YES",
                "VOTE_OPTION_ABSTAIN",
                "VOTE_OPTION_NO",
                "VOTE_OPTION_NO_WITH_VETO"
              ],
              "default": "VOTE_OPTION_UNSPECIFIED"
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "option": {
                    "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                    "type": "string",
                    "enum": [
                      "VOTE_OPTION_UNSPECIFIED",
                      "VOTE_OPTION_YES",
                      "VOTE_OPTION_ABSTAIN",
                      "VOTE_OPTION_NO",
                      "VOTE_OPTION_NO_WITH_VETO"
                    ],
                    "default": "VOTE_OPTION_UNSPECIFIED"
                  },
                  "weight": {
                    "type": "string",
                    "description": "weight is the vote weight associated with the vote option."
                  }
                },
                "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
              },
              "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43"
            }
          },
          "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64",
                "description": "proposal_id defines the unique id of the proposal."
              },
              "voter": {
                "type": "string",
                "description": "voter is the voter address of the proposal."
              },
              "option": {
                "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED"
              },
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "option": {
                      "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED"
                    },
                    "weight": {
                      "type": "string",
                      "description": "weight is the vote weight associated with the vote option."
                    }
                  },
                  "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                },
                "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43"
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          },
          "description": "votes defines the queried votes."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1beta1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "format": "byte",
          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
        },
        "threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "veto_threshold": {
          "type": "string",
          "format": "byte",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1beta1.TallyResult": {
      "type": "object",
      "properties": {
        "yes": {
          "type": "string",
          "description": "yes is the number of yes votes on a proposal."
        },
        "abstain": {
          "type": "string",
          "description": "abstain is the number of abstain votes on a proposal."
        },
        "no": {
          "type": "string",
          "description": "no is the number of no votes on a proposal."
        },
        "no_with_veto": {
          "type": "string",
          "description": "no_with_veto is the number of no with veto votes on a proposal."
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1beta1.Vote": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address of the proposal."
        },
        "option": {
          "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED"
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "option": {
                "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED"
              },
              "weight": {
                "type": "string",
                "description": "weight is the vote weight associated with the vote option."
              }
            },
            "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
          },
          "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1beta1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1beta1.VotingParams": {
      "type": "object",
      "properties": {
        "voting_period": {
          "type": "string",
          "description": "Duration of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      "type": "object",
      "properties": {
        "option": {
          "description": "option defines the valid vote options, it must not contain duplicate vote options.",
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED"
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.gov.v1.Deposit": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "depositor": {
          "type": "string",
          "description": "depositor defines the deposit addresses from the proposals."
        },
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "amount to be deposited by depositor."
        }
      },
      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
    },
    "cosmos.gov.v1.DepositParams": {
      "type": "object",
      "properties": {
        "min_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "max_deposit_period": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        }
      },
      "description": "DepositParams defines the params for deposits on governance proposals."
    },
    "cosmos.gov.v1.Params": {
      "type": "object",
      "properties": {
        "min_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "Minimum deposit for a proposal to enter voting period."
        },
        "max_deposit_period": {
          "type": "string",
          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
        },
        "voting_period": {
          "type": "string",
          "description": "Duration of the voting period."
        },
        "quorum": {
          "type": "string",
          "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
        },
        "threshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "veto_threshold": {
          "type": "string",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
        },
        "min_initial_deposit_ratio": {
          "type": "string",
          "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
        },
        "burn_vote_quorum": {
          "type": "boolean",
          "title": "burn deposits if a proposal does not meet quorum"
        },
        "burn_proposal_deposit_prevote": {
          "type": "boolean",
          "title": "burn deposits if the proposal does not enter voting period"
        },
        "burn_vote_veto": {
          "type": "boolean",
          "title": "burn deposits if quorum with vote type no_veto is met"
        }
      },
      "description": "Params defines the parameters for the x/gov module.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.gov.v1.Proposal": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uint64",
          "description": "id defines the unique id of the proposal."
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "messages are the arbitrary messages to be executed if the proposal passes."
        },
        "status": {
          "description": "status defines the proposal status.",
          "type": "string",
          "enum": [
            "PROPOSAL_STATUS_UNSPECIFIED",
            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
            "PROPOSAL_STATUS_VOTING_PERIOD",
            "PROPOSAL_STATUS_PASSED",
            "PROPOSAL_STATUS_REJECTED",
            "PROPOSAL_STATUS_FAILED"
          ],
          "default": "PROPOSAL_STATUS_UNSPECIFIED"
        },
        "final_tally_result": {
          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
          "type": "object",
          "properties": {
            "yes_count": {
              "type": "string",
              "description": "yes_count is the number of yes votes on a proposal."
            },
            "abstain_count": {
              "type": "string",
              "description": "abstain_count is the number of abstain votes on a proposal."
            },
            "no_count": {
              "type": "string",
              "description": "no_count is the number of no votes on a proposal."
            },
            "no_with_veto_count": {
              "type": "string",
              "description": "no_with_veto_count is the number of no with veto votes on a proposal."
            }
          }
        },
        "submit_time": {
          "type": "string",
          "format": "date-time",
          "description": "submit_time is the time of proposal submission."
        },
        "deposit_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "deposit_end_time is the end time for deposition."
        },
        "total_deposit": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "description": "total_deposit is the total deposit on the proposal."
        },
        "voting_start_time": {
          "type": "string",
          "format": "date-time",
          "description": "voting_start_time is the starting time to vote on a proposal."
        },
        "voting_end_time": {
          "type": "string",
          "format": "date-time",
          "description": "voting_end_time is the end time of voting on a proposal."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any arbitrary metadata attached to the proposal."
        },
        "title": {
          "type": "string",
          "description": "Since: cosmos-sdk 0.47",
          "title": "title is the title of the proposal"
        },
        "summary": {
          "type": "string",
          "description": "Since: cosmos-sdk 0.47",
          "title": "summary is a short summary of the proposal"
        },
        "proposer": {
          "type": "string",
          "description": "Since: cosmos-sdk 0.47",
          "title": "Proposer is the address of the proposal sumbitter"
        }
      },
      "description": "Proposal defines the core field members of a governance proposal."
    },
    "cosmos.gov.v1.ProposalStatus": {
      "type": "string",
      "enum": [
        "PROPOSAL_STATUS_UNSPECIFIED",
        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
        "PROPOSAL_STATUS_VOTING_PERIOD",
        "PROPOSAL_STATUS_PASSED",
        "PROPOSAL_STATUS_REJECTED",
        "PROPOSAL_STATUS_FAILED"
      ],
      "default": "PROPOSAL_STATUS_UNSPECIFIED",
      "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed."
    },
    "cosmos.gov.v1.QueryDepositResponse": {
      "type": "object",
      "properties": {
        "deposit": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64",
              "description": "proposal_id defines the unique id of the proposal."
            },
            "depositor": {
              "type": "string",
              "description": "depositor defines the deposit addresses from the proposals."
            },
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "amount to be deposited by depositor."
            }
          },
          "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
        }
      },
      "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
    },
    "cosmos.gov.v1.QueryDepositsResponse": {
      "type": "object",
      "properties": {
        "deposits": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64",
                "description": "proposal_id defines the unique id of the proposal."
              },
              "depositor": {
                "type": "string",
                "description": "depositor defines the deposit addresses from the proposals."
              },
              "amount": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "description": "amount to be deposited by depositor."
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
          },
          "description": "deposits defines the requested deposits."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
    },
    "cosmos.gov.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "voting_params": {
          "description": "Deprecated: Prefer to use `params` instead.\nvoting_params defines the parameters related to voting.",
          "type": "object",
          "properties": {
            "voting_period": {
              "type": "string",
              "description": "Duration of the voting period."
            }
          }
        },
        "deposit_params": {
          "description": "Deprecated: Prefer to use `params` instead.\ndeposit_params defines the parameters related to deposit.",
          "type": "object",
          "properties": {
            "min_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "Minimum deposit for a proposal to enter voting period."
            },
            "max_deposit_period": {
              "type": "string",
              "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
            }
          }
        },
        "tally_params": {
          "description": "Deprecated: Prefer to use `params` instead.\ntally_params defines the parameters related to tally.",
          "type": "object",
          "properties": {
            "quorum": {
              "type": "string",
              "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
            },
            "threshold": {
              "type": "string",
              "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
            },
            "veto_threshold": {
              "type": "string",
              "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
            }
          }
        },
        "params": {
          "description": "params defines all the paramaters of x/gov module.\n\nSince: cosmos-sdk 0.47",
          "type": "object",
          "properties": {
            "min_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "Minimum deposit for a proposal to enter voting period."
            },
            "max_deposit_period": {
              "type": "string",
              "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
            },
            "voting_period": {
              "type": "string",
              "description": "Duration of the voting period."
            },
            "quorum": {
              "type": "string",
              "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
            },
            "threshold": {
              "type": "string",
              "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
            },
            "veto_threshold": {
              "type": "string",
              "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
            },
            "min_initial_deposit_ratio": {
              "type": "string",
              "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
            },
            "burn_vote_quorum": {
              "type": "boolean",
              "title": "burn deposits if a proposal does not meet quorum"
            },
            "burn_proposal_deposit_prevote": {
              "type": "boolean",
              "title": "burn deposits if the proposal does not enter voting period"
            },
            "burn_vote_veto": {
              "type": "boolean",
              "title": "burn deposits if quorum with vote type no_veto is met"
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.gov.v1.QueryProposalResponse": {
      "type": "object",
      "properties": {
        "proposal": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uint64",
              "description": "id defines the unique id of the proposal."
            },
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "description": "messages are the arbitrary messages to be executed if the proposal passes."
            },
            "status": {
              "description": "status defines the proposal status.",
              "type": "string",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ],
              "default": "PROPOSAL_STATUS_UNSPECIFIED"
            },
            "final_tally_result": {
              "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
              "type": "object",
              "properties": {
                "yes_count": {
                  "type": "string",
                  "description": "yes_count is the number of yes votes on a proposal."
                },
                "abstain_count": {
                  "type": "string",
                  "description": "abstain_count is the number of abstain votes on a proposal."
                },
                "no_count": {
                  "type": "string",
                  "description": "no_count is the number of no votes on a proposal."
                },
                "no_with_veto_count": {
                  "type": "string",
                  "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                }
              }
            },
            "submit_time": {
              "type": "string",
              "format": "date-time",
              "description": "submit_time is the time of proposal submission."
            },
            "deposit_end_time": {
              "type": "string",
              "format": "date-time",
              "description": "deposit_end_time is the end time for deposition."
            },
            "total_deposit": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "description": "total_deposit is the total deposit on the proposal."
            },
            "voting_start_time": {
              "type": "string",
              "format": "date-time",
              "description": "voting_start_time is the starting time to vote on a proposal."
            },
            "voting_end_time": {
              "type": "string",
              "format": "date-time",
              "description": "voting_end_time is the end time of voting on a proposal."
            },
            "metadata": {
              "type": "string",
              "description": "metadata is any arbitrary metadata attached to the proposal."
            },
            "title": {
              "type": "string",
              "description": "Since: cosmos-sdk 0.47",
              "title": "title is the title of the proposal"
            },
            "summary": {
              "type": "string",
              "description": "Since: cosmos-sdk 0.47",
              "title": "summary is a short summary of the proposal"
            },
            "proposer": {
              "type": "string",
              "description": "Since: cosmos-sdk 0.47",
              "title": "Proposer is the address of the proposal sumbitter"
            }
          },
          "description": "Proposal defines the core field members of a governance proposal."
        }
      },
      "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
    },
    "cosmos.gov.v1.QueryProposalsResponse": {
      "type": "object",
      "properties": {
        "proposals": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uint64",
                "description": "id defines the unique id of the proposal."
              },
              "messages": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "type": "string",
                      "format": "byte",
                      "description": "Must be a valid serialized protocol buffer of the above specified type."
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "description": "messages are the arbitrary messages to be executed if the proposal passes."
              },
              "status": {
                "description": "status defines the proposal status.",
                "type": "string",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ],
                "default": "PROPOSAL_STATUS_UNSPECIFIED"
              },
              "final_tally_result": {
                "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended.",
                "type": "object",
                "properties": {
                  "yes_count": {
                    "type": "string",
                    "description": "yes_count is the number of yes votes on a proposal."
                  },
                  "abstain_count": {
                    "type": "string",
                    "description": "abstain_count is the number of abstain votes on a proposal."
                  },
                  "no_count": {
                    "type": "string",
                    "description": "no_count is the number of no votes on a proposal."
                  },
                  "no_with_veto_count": {
                    "type": "string",
                    "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                  }
                }
              },
              "submit_time": {
                "type": "string",
                "format": "date-time",
                "description": "submit_time is the time of proposal submission."
              },
              "deposit_end_time": {
                "type": "string",
                "format": "date-time",
                "description": "deposit_end_time is the end time for deposition."
              },
              "total_deposit": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                },
                "description": "total_deposit is the total deposit on the proposal."
              },
              "voting_start_time": {
                "type": "string",
                "format": "date-time",
                "description": "voting_start_time is the starting time to vote on a proposal."
              },
              "voting_end_time": {
                "type": "string",
                "format": "date-time",
                "description": "voting_end_time is the end time of voting on a proposal."
              },
              "metadata": {
                "type": "string",
                "description": "metadata is any arbitrary metadata attached to the proposal."
              },
              "title": {
                "type": "string",
                "description": "Since: cosmos-sdk 0.47",
                "title": "title is the title of the proposal"
              },
              "summary": {
                "type": "string",
                "description": "Since: cosmos-sdk 0.47",
                "title": "summary is a short summary of the proposal"
              },
              "proposer": {
                "type": "string",
                "description": "Since: cosmos-sdk 0.47",
                "title": "Proposer is the address of the proposal sumbitter"
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          },
          "description": "proposals defines all the requested governance proposals."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
    },
    "cosmos.gov.v1.QueryTallyResultResponse": {
      "type": "object",
      "properties": {
        "tally": {
          "description": "tally defines the requested tally.",
          "type": "object",
          "properties": {
            "yes_count": {
              "type": "string",
              "description": "yes_count is the number of yes votes on a proposal."
            },
            "abstain_count": {
              "type": "string",
              "description": "abstain_count is the number of abstain votes on a proposal."
            },
            "no_count": {
              "type": "string",
              "description": "no_count is the number of no votes on a proposal."
            },
            "no_with_veto_count": {
              "type": "string",
              "description": "no_with_veto_count is the number of no with veto votes on a proposal."
            }
          }
        }
      },
      "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
    },
    "cosmos.gov.v1.QueryVoteResponse": {
      "type": "object",
      "properties": {
        "vote": {
          "type": "object",
          "properties": {
            "proposal_id": {
              "type": "string",
              "format": "uint64",
              "description": "proposal_id defines the unique id of the proposal."
            },
            "voter": {
              "type": "string",
              "description": "voter is the voter address of the proposal."
            },
            "options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "option": {
                    "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                    "type": "string",
                    "enum": [
                      "VOTE_OPTION_UNSPECIFIED",
                      "VOTE_OPTION_YES",
                      "VOTE_OPTION_ABSTAIN",
                      "VOTE_OPTION_NO",
                      "VOTE_OPTION_NO_WITH_VETO"
                    ],
                    "default": "VOTE_OPTION_UNSPECIFIED"
                  },
                  "weight": {
                    "type": "string",
                    "description": "weight is the vote weight associated with the vote option."
                  }
                },
                "description": "WeightedVoteOption defines a unit of vote for vote split."
              },
              "description": "options is the weighted vote options."
            },
            "metadata": {
              "type": "string",
              "description": "metadata is any  arbitrary metadata to attached to the vote."
            }
          },
          "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
        }
      },
      "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
    },
    "cosmos.gov.v1.QueryVotesResponse": {
      "type": "object",
      "properties": {
        "votes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "format": "uint64",
                "description": "proposal_id defines the unique id of the proposal."
              },
              "voter": {
                "type": "string",
                "description": "voter is the voter address of the proposal."
              },
              "options": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "option": {
                      "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                      "type": "string",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ],
                      "default": "VOTE_OPTION_UNSPECIFIED"
                    },
                    "weight": {
                      "type": "string",
                      "description": "weight is the vote weight associated with the vote option."
                    }
                  },
                  "description": "WeightedVoteOption defines a unit of vote for vote split."
                },
                "description": "options is the weighted vote options."
              },
              "metadata": {
                "type": "string",
                "description": "metadata is any  arbitrary metadata to attached to the vote."
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          },
          "description": "votes defines the queried votes."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
    },
    "cosmos.gov.v1.TallyParams": {
      "type": "object",
      "properties": {
        "quorum": {
          "type": "string",
          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
        },
        "threshold": {
          "type": "string",
          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
        },
        "veto_threshold": {
          "type": "string",
          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
        }
      },
      "description": "TallyParams defines the params for tallying votes on governance proposals."
    },
    "cosmos.gov.v1.TallyResult": {
      "type": "object",
      "properties": {
        "yes_count": {
          "type": "string",
          "description": "yes_count is the number of yes votes on a proposal."
        },
        "abstain_count": {
          "type": "string",
          "description": "abstain_count is the number of abstain votes on a proposal."
        },
        "no_count": {
          "type": "string",
          "description": "no_count is the number of no votes on a proposal."
        },
        "no_with_veto_count": {
          "type": "string",
          "description": "no_with_veto_count is the number of no with veto votes on a proposal."
        }
      },
      "description": "TallyResult defines a standard tally for a governance proposal."
    },
    "cosmos.gov.v1.Vote": {
      "type": "object",
      "properties": {
        "proposal_id": {
          "type": "string",
          "format": "uint64",
          "description": "proposal_id defines the unique id of the proposal."
        },
        "voter": {
          "type": "string",
          "description": "voter is the voter address of the proposal."
        },
        "options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "option": {
                "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                "type": "string",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ],
                "default": "VOTE_OPTION_UNSPECIFIED"
              },
              "weight": {
                "type": "string",
                "description": "weight is the vote weight associated with the vote option."
              }
            },
            "description": "WeightedVoteOption defines a unit of vote for vote split."
          },
          "description": "options is the weighted vote options."
        },
        "metadata": {
          "type": "string",
          "description": "metadata is any  arbitrary metadata to attached to the vote."
        }
      },
      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
    },
    "cosmos.gov.v1.VoteOption": {
      "type": "string",
      "enum": [
        "VOTE_OPTION_UNSPECIFIED",
        "VOTE_OPTION_YES",
        "VOTE_OPTION_ABSTAIN",
        "VOTE_OPTION_NO",
        "VOTE_OPTION_NO_WITH_VETO"
      ],
      "default": "VOTE_OPTION_UNSPECIFIED",
      "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."
    },
    "cosmos.gov.v1.VotingParams": {
      "type": "object",
      "properties": {
        "voting_period": {
          "type": "string",
          "description": "Duration of the voting period."
        }
      },
      "description": "VotingParams defines the params for voting on governance proposals."
    },
    "cosmos.gov.v1.WeightedVoteOption": {
      "type": "object",
      "properties": {
        "option": {
          "description": "option defines the valid vote options, it must not contain duplicate vote options.",
          "type": "string",
          "enum": [
            "VOTE_OPTION_UNSPECIFIED",
            "VOTE_OPTION_YES",
            "VOTE_OPTION_ABSTAIN",
            "VOTE_OPTION_NO",
            "VOTE_OPTION_NO_WITH_VETO"
          ],
          "default": "VOTE_OPTION_UNSPECIFIED"
        },
        "weight": {
          "type": "string",
          "description": "weight is the vote weight associated with the vote option."
        }
      },
      "description": "WeightedVoteOption defines a unit of vote for vote split."
    },
    "cosmos.slashing.v1beta1.Params": {
      "type": "object",
      "properties": {
        "signed_blocks_window": {
          "type": "string",
          "format": "int64"
        },
        "min_signed_per_window": {
          "type": "string",
          "format": "byte"
        },
        "downtime_jail_duration": {
          "type": "string"
        },
        "slash_fraction_double_sign": {
          "type": "string",
          "format": "byte"
        },
        "slash_fraction_downtime": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Params represents the parameters used for by the slashing module."
    },
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "type": "object",
          "properties": {
            "signed_blocks_window": {
              "type": "string",
              "format": "int64"
            },
            "min_signed_per_window": {
              "type": "string",
              "format": "byte"
            },
            "downtime_jail_duration": {
              "type": "string"
            },
            "slash_fraction_double_sign": {
              "type": "string",
              "format": "byte"
            },
            "slash_fraction_downtime": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Params represents the parameters used for by the slashing module."
        }
      },
      "title": "QueryParamsResponse is the response type for the Query/Params RPC method"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      "type": "object",
      "properties": {
        "val_signing_info": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string"
            },
            "start_height": {
              "type": "string",
              "format": "int64",
              "title": "Height at which validator was first a candidate OR was unjailed"
            },
            "index_offset": {
              "type": "string",
              "format": "int64",
              "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
            },
            "jailed_until": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp until which the validator is jailed due to liveness downtime."
            },
            "tombstoned": {
              "type": "boolean",
              "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
            },
            "missed_blocks_counter": {
              "type": "string",
              "format": "int64",
              "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
            }
          },
          "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
          "title": "val_signing_info is the signing info of requested val cons address"
        }
      },
      "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      "type": "object",
      "properties": {
        "info": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "start_height": {
                "type": "string",
                "format": "int64",
                "title": "Height at which validator was first a candidate OR was unjailed"
              },
              "index_offset": {
                "type": "string",
                "format": "int64",
                "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
              },
              "jailed_until": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp until which the validator is jailed due to liveness downtime."
              },
              "tombstoned": {
                "type": "boolean",
                "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
              },
              "missed_blocks_counter": {
                "type": "string",
                "format": "int64",
                "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
              }
            },
            "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
          },
          "title": "info is the signing info of all validators"
        },
        "pagination": {
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod"
    },
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "start_height": {
          "type": "string",
          "format": "int64",
          "title": "Height at which validator was first a candidate OR was unjailed"
        },
        "index_offset": {
          "type": "string",
          "format": "int64",
          "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."
        },
        "jailed_until": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp until which the validator is jailed due to liveness downtime."
        },
        "tombstoned": {
          "type": "boolean",
          "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor."
        },
        "missed_blocks_counter": {
          "type": "string",
          "format": "int64",
          "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."
        }
      },
      "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
    },
    "cosmos.base.abci.v1beta1.ABCIMessageLog": {
      "type": "object",
      "properties": {
        "msg_index": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string"
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    }
                  },
                  "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                }
              }
            },
            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
          },
          "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
        }
      },
      "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
    },
    "cosmos.base.abci.v1beta1.Attribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.GasInfo": {
      "type": "object",
      "properties": {
        "gas_wanted": {
          "type": "string",
          "format": "uint64",
          "description": "GasWanted is the maximum units of work we allow this tx to perform."
        },
        "gas_used": {
          "type": "string",
          "format": "uint64",
          "description": "GasUsed is the amount of gas actually consumed."
        }
      },
      "description": "GasInfo defines tx execution gas context."
    },
    "cosmos.base.abci.v1beta1.Result": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL."
        },
        "log": {
          "type": "string",
          "description": "Log contains the log information from message or handler execution."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    },
                    "index": {
                      "type": "boolean"
                    }
                  },
                  "description": "EventAttribute is a single key-value pair, associated with an event."
                }
              }
            },
            "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
          },
          "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
        },
        "msg_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46"
        }
      },
      "description": "Result is the union of ResponseFormat and ResponseCheckTx."
    },
    "cosmos.base.abci.v1beta1.StringEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
          }
        }
      },
      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
    },
    "cosmos.base.abci.v1beta1.TxResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "title": "The block height"
        },
        "txhash": {
          "type": "string",
          "description": "The transaction hash."
        },
        "codespace": {
          "type": "string",
          "title": "Namespace for the Code"
        },
        "code": {
          "type": "integer",
          "format": "int64",
          "description": "Response code."
        },
        "data": {
          "type": "string",
          "description": "Result bytes, if any."
        },
        "raw_log": {
          "type": "string",
          "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
        },
        "logs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "msg_index": {
                "type": "integer",
                "format": "int64"
              },
              "log": {
                "type": "string"
              },
              "events": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          }
                        },
                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                      }
                    }
                  },
                  "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                },
                "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
              }
            },
            "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
          },
          "description": "The output of the application's logger (typed). May be non-deterministic."
        },
        "info": {
          "type": "string",
          "description": "Additional information. May be non-deterministic."
        },
        "gas_wanted": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas requested for transaction."
        },
        "gas_used": {
          "type": "string",
          "format": "int64",
          "description": "Amount of gas consumed by transaction."
        },
        "tx": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "timestamp": {
          "type": "string",
          "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
        },
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "attributes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "key": {
                      "type": "string"
                    },
                    "value": {
                      "type": "string"
                    },
                    "index": {
                      "type": "boolean"
                    }
                  },
                  "description": "EventAttribute is a single key-value pair, associated with an event."
                }
              }
            },
            "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
          },
          "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
        }
      },
      "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
    },
    "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
      "type": "object",
      "properties": {
        "extra_bits_stored": {
          "type": "integer",
          "format": "int64"
        },
        "elems": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
    },
    "cosmos.tx.signing.v1beta1.SignMode": {
      "type": "string",
      "enum": [
        "SIGN_MODE_UNSPECIFIED",
        "SIGN_MODE_DIRECT",
        "SIGN_MODE_TEXTUAL",
        "SIGN_MODE_DIRECT_AUX",
        "SIGN_MODE_LEGACY_AMINO_JSON",
        "SIGN_MODE_EIP_191"
      ],
      "default": "SIGN_MODE_UNSPECIFIED",
      "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently not supported.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2"
    },
    "cosmos.tx.v1beta1.AuthInfo": {
      "type": "object",
      "properties": {
        "signer_infos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.SignerInfo"
          },
          "description": "signer_infos defines the signing modes for the required signers. The number\nand order of elements must match the required signers from TxBody's\nmessages. The first element is the primary signer and the one which pays\nthe fee."
        },
        "fee": {
          "description": "Fee is the fee and gas limit for the transaction. The first signer is the\nprimary signer and the one which pays the fee. The fee can be calculated\nbased on the cost of evaluating the body and doing signature verification\nof the signers. This can be estimated via simulation.",
          "type": "object",
          "properties": {
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "title": "amount is the amount of coins to be paid as a fee"
            },
            "gas_limit": {
              "type": "string",
              "format": "uint64",
              "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs"
            },
            "payer": {
              "type": "string",
              "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
            },
            "granter": {
              "type": "string",
              "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail"
            }
          }
        },
        "tip": {
          "description": "Tip is the optional tip used for transactions fees paid in another denom.\n\nThis field is ignored if the chain didn't enable tips, i.e. didn't add the\n`TipDecorator` in its posthandler.\n\nSince: cosmos-sdk 0.46",
          "type": "object",
          "properties": {
            "amount": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              },
              "title": "amount is the amount of the tip"
            },
            "tipper": {
              "type": "string",
              "title": "tipper is the address of the account paying for the tip"
            }
          }
        }
      },
      "description": "AuthInfo describes the fee and signer modes that are used to sign a\ntransaction."
    },
    "cosmos.tx.v1beta1.BroadcastMode": {
      "type": "string",
      "enum": [
        "BROADCAST_MODE_UNSPECIFIED",
        "BROADCAST_MODE_BLOCK",
        "BROADCAST_MODE_SYNC",
        "BROADCAST_MODE_ASYNC"
      ],
      "default": "BROADCAST_MODE_UNSPECIFIED",
      "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
    },
    "cosmos.tx.v1beta1.BroadcastTxRequest": {
      "type": "object",
      "properties": {
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        },
        "mode": {
          "type": "string",
          "enum": [
            "BROADCAST_MODE_UNSPECIFIED",
            "BROADCAST_MODE_BLOCK",
            "BROADCAST_MODE_SYNC",
            "BROADCAST_MODE_ASYNC"
          ],
          "default": "BROADCAST_MODE_UNSPECIFIED",
          "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately."
        }
      },
      "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
    },
    "cosmos.tx.v1beta1.BroadcastTxResponse": {
      "type": "object",
      "properties": {
        "tx_response": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64",
              "title": "The block height"
            },
            "txhash": {
              "type": "string",
              "description": "The transaction hash."
            },
            "codespace": {
              "type": "string",
              "title": "Namespace for the Code"
            },
            "code": {
              "type": "integer",
              "format": "int64",
              "description": "Response code."
            },
            "data": {
              "type": "string",
              "description": "Result bytes, if any."
            },
            "raw_log": {
              "type": "string",
              "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
            },
            "logs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "msg_index": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "log": {
                    "type": "string"
                  },
                  "events": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string"
                        },
                        "attributes": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            },
                            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                          }
                        }
                      },
                      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                    },
                    "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                  }
                },
                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
              },
              "description": "The output of the application's logger (typed). May be non-deterministic."
            },
            "info": {
              "type": "string",
              "description": "Additional information. May be non-deterministic."
            },
            "gas_wanted": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas requested for transaction."
            },
            "gas_used": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas consumed by transaction."
            },
            "tx": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "timestamp": {
              "type": "string",
              "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        },
                        "index": {
                          "type": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
            }
          },
          "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
        }
      },
      "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
    },
    "cosmos.tx.v1beta1.Fee": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "amount is the amount of coins to be paid as a fee"
        },
        "gas_limit": {
          "type": "string",
          "format": "uint64",
          "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs"
        },
        "payer": {
          "type": "string",
          "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
        },
        "granter": {
          "type": "string",
          "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail"
        }
      },
      "description": "Fee includes the amount of coins paid in fees and the maximum\ngas to be used by the transaction. The ratio yields an effective \"gasprice\",\nwhich must be above some miminum to be accepted into the mempool."
    },
    "cosmos.tx.v1beta1.GetBlockWithTxsResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
          },
          "description": "txs are the transactions in the block."
        },
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "block": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        },
        "pagination": {
          "description": "pagination defines a pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs method.\n\nSince: cosmos-sdk 0.45.2"
    },
    "cosmos.tx.v1beta1.GetTxResponse": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the queried transaction."
        },
        "tx_response": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64",
              "title": "The block height"
            },
            "txhash": {
              "type": "string",
              "description": "The transaction hash."
            },
            "codespace": {
              "type": "string",
              "title": "Namespace for the Code"
            },
            "code": {
              "type": "integer",
              "format": "int64",
              "description": "Response code."
            },
            "data": {
              "type": "string",
              "description": "Result bytes, if any."
            },
            "raw_log": {
              "type": "string",
              "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
            },
            "logs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "msg_index": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "log": {
                    "type": "string"
                  },
                  "events": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string"
                        },
                        "attributes": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            },
                            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                          }
                        }
                      },
                      "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                    },
                    "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                  }
                },
                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
              },
              "description": "The output of the application's logger (typed). May be non-deterministic."
            },
            "info": {
              "type": "string",
              "description": "Additional information. May be non-deterministic."
            },
            "gas_wanted": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas requested for transaction."
            },
            "gas_used": {
              "type": "string",
              "format": "int64",
              "description": "Amount of gas consumed by transaction."
            },
            "tx": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            },
            "timestamp": {
              "type": "string",
              "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        },
                        "index": {
                          "type": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
            }
          },
          "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
        }
      },
      "description": "GetTxResponse is the response type for the Service.GetTx method."
    },
    "cosmos.tx.v1beta1.GetTxsEventResponse": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
          },
          "description": "txs is the list of queried transactions."
        },
        "tx_responses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "height": {
                "type": "string",
                "format": "int64",
                "title": "The block height"
              },
              "txhash": {
                "type": "string",
                "description": "The transaction hash."
              },
              "codespace": {
                "type": "string",
                "title": "Namespace for the Code"
              },
              "code": {
                "type": "integer",
                "format": "int64",
                "description": "Response code."
              },
              "data": {
                "type": "string",
                "description": "Result bytes, if any."
              },
              "raw_log": {
                "type": "string",
                "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
              },
              "logs": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "msg_index": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "log": {
                      "type": "string"
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              },
                              "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                            }
                          }
                        },
                        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                      },
                      "description": "Events contains a slice of Event objects that were emitted during some\nexecution."
                    }
                  },
                  "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                },
                "description": "The output of the application's logger (typed). May be non-deterministic."
              },
              "info": {
                "type": "string",
                "description": "Additional information. May be non-deterministic."
              },
              "gas_wanted": {
                "type": "string",
                "format": "int64",
                "description": "Amount of gas requested for transaction."
              },
              "gas_used": {
                "type": "string",
                "format": "int64",
                "description": "Amount of gas consumed by transaction."
              },
              "tx": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "timestamp": {
                "type": "string",
                "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
              },
              "events": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "description": "EventAttribute is a single key-value pair, associated with an event."
                      }
                    }
                  },
                  "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
                },
                "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"
              }
            },
            "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
          },
          "description": "tx_responses is the list of queried TxResponses."
        },
        "pagination": {
          "description": "pagination defines a pagination for the response.\nDeprecated post v0.46.x: use total instead.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        },
        "total": {
          "type": "string",
          "format": "uint64",
          "title": "total is total number of results available"
        }
      },
      "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents\nRPC method."
    },
    "cosmos.tx.v1beta1.ModeInfo": {
      "type": "object",
      "properties": {
        "single": {
          "title": "single represents a single signer",
          "type": "object",
          "properties": {
            "mode": {
              "title": "mode is the signing mode of the single signer",
              "type": "string",
              "enum": [
                "SIGN_MODE_UNSPECIFIED",
                "SIGN_MODE_DIRECT",
                "SIGN_MODE_TEXTUAL",
                "SIGN_MODE_DIRECT_AUX",
                "SIGN_MODE_LEGACY_AMINO_JSON",
                "SIGN_MODE_EIP_191"
              ],
              "default": "SIGN_MODE_UNSPECIFIED",
              "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently not supported.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2"
            }
          }
        },
        "multi": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo.Multi",
          "title": "multi represents a nested multisig signer"
        }
      },
      "description": "ModeInfo describes the signing mode of a single or nested multisig signer."
    },
    "cosmos.tx.v1beta1.ModeInfo.Multi": {
      "type": "object",
      "properties": {
        "bitarray": {
          "title": "bitarray specifies which keys within the multisig are signing",
          "type": "object",
          "properties": {
            "extra_bits_stored": {
              "type": "integer",
              "format": "int64"
            },
            "elems": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
        },
        "mode_infos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo"
          },
          "title": "mode_infos is the corresponding modes of the signers of the multisig\nwhich could include nested multisig public keys"
        }
      },
      "title": "Multi is the mode info for a multisig public key"
    },
    "cosmos.tx.v1beta1.ModeInfo.Single": {
      "type": "object",
      "properties": {
        "mode": {
          "title": "mode is the signing mode of the single signer",
          "type": "string",
          "enum": [
            "SIGN_MODE_UNSPECIFIED",
            "SIGN_MODE_DIRECT",
            "SIGN_MODE_TEXTUAL",
            "SIGN_MODE_DIRECT_AUX",
            "SIGN_MODE_LEGACY_AMINO_JSON",
            "SIGN_MODE_EIP_191"
          ],
          "default": "SIGN_MODE_UNSPECIFIED",
          "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently not supported.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2"
        }
      },
      "title": "Single is the mode info for a single signer. It is structured as a message\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\nfuture"
    },
    "cosmos.tx.v1beta1.OrderBy": {
      "type": "string",
      "enum": [
        "ORDER_BY_UNSPECIFIED",
        "ORDER_BY_ASC",
        "ORDER_BY_DESC"
      ],
      "default": "ORDER_BY_UNSPECIFIED",
      "description": "- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
      "title": "OrderBy defines the sorting order"
    },
    "cosmos.tx.v1beta1.SignerInfo": {
      "type": "object",
      "properties": {
        "public_key": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "mode_info": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo",
          "title": "mode_info describes the signing mode of the signer and is a nested\nstructure to support nested multisig pubkey's"
        },
        "sequence": {
          "type": "string",
          "format": "uint64",
          "description": "sequence is the sequence of the account, which describes the\nnumber of committed transactions signed by a given address. It is used to\nprevent replay attacks."
        }
      },
      "description": "SignerInfo describes the public key and signing mode of a single top-level\nsigner."
    },
    "cosmos.tx.v1beta1.SimulateRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to simulate.\nDeprecated. Send raw tx bytes instead."
        },
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction.\n\nSince: cosmos-sdk 0.43"
        }
      },
      "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method."
    },
    "cosmos.tx.v1beta1.SimulateResponse": {
      "type": "object",
      "properties": {
        "gas_info": {
          "description": "gas_info is the information about gas used in the simulation.",
          "type": "object",
          "properties": {
            "gas_wanted": {
              "type": "string",
              "format": "uint64",
              "description": "GasWanted is the maximum units of work we allow this tx to perform."
            },
            "gas_used": {
              "type": "string",
              "format": "uint64",
              "description": "GasUsed is the amount of gas actually consumed."
            }
          }
        },
        "result": {
          "description": "result is the result of the simulation.",
          "type": "object",
          "properties": {
            "data": {
              "type": "string",
              "format": "byte",
              "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL."
            },
            "log": {
              "type": "string",
              "description": "Log contains the log information from message or handler execution."
            },
            "events": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "attributes": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        },
                        "index": {
                          "type": "boolean"
                        }
                      },
                      "description": "EventAttribute is a single key-value pair, associated with an event."
                    }
                  }
                },
                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
              },
              "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution."
            },
            "msg_responses": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46"
            }
          }
        }
      },
      "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
    },
    "cosmos.tx.v1beta1.Tip": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          },
          "title": "amount is the amount of the tip"
        },
        "tipper": {
          "type": "string",
          "title": "tipper is the address of the account paying for the tip"
        }
      },
      "description": "Tip is the tip used for meta-transactions.\n\nSince: cosmos-sdk 0.46"
    },
    "cosmos.tx.v1beta1.Tx": {
      "type": "object",
      "properties": {
        "body": {
          "title": "body is the processable content of the transaction",
          "type": "object",
          "properties": {
            "messages": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction."
            },
            "memo": {
              "type": "string",
              "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
            },
            "timeout_height": {
              "type": "string",
              "format": "uint64",
              "title": "timeout is the block height after which this transaction will not\nbe processed by the chain"
            },
            "extension_options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected"
            },
            "non_critical_extension_options": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored"
            }
          },
          "description": "TxBody is the body of a transaction that all signers sign over."
        },
        "auth_info": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.AuthInfo",
          "title": "auth_info is the authorization related content of the transaction,\nspecifically signers, signer modes and fee"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "signatures is a list of signatures that matches the length and order of\nAuthInfo's signer_infos to allow connecting signature meta information like\npublic key and signing mode by position."
        }
      },
      "description": "Tx is the standard type used for broadcasting transactions."
    },
    "cosmos.tx.v1beta1.TxBody": {
      "type": "object",
      "properties": {
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction."
        },
        "memo": {
          "type": "string",
          "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
        },
        "timeout_height": {
          "type": "string",
          "format": "uint64",
          "title": "timeout is the block height after which this transaction will not\nbe processed by the chain"
        },
        "extension_options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected"
        },
        "non_critical_extension_options": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "type": "string",
                "format": "byte",
                "description": "Must be a valid serialized protocol buffer of the above specified type."
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored"
        }
      },
      "description": "TxBody is the body of a transaction that all signers sign over."
    },
    "cosmos.tx.v1beta1.TxDecodeAminoRequest": {
      "type": "object",
      "properties": {
        "amino_binary": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxDecodeAminoResponse": {
      "type": "object",
      "properties": {
        "amino_json": {
          "type": "string"
        }
      },
      "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxDecodeRequest": {
      "type": "object",
      "properties": {
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the raw transaction."
        }
      },
      "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxDecodeResponse": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the decoded transaction."
        }
      },
      "description": "TxDecodeResponse is the response type for the\nService.TxDecode method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxEncodeAminoRequest": {
      "type": "object",
      "properties": {
        "amino_json": {
          "type": "string"
        }
      },
      "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxEncodeAminoResponse": {
      "type": "object",
      "properties": {
        "amino_binary": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxEncodeRequest": {
      "type": "object",
      "properties": {
        "tx": {
          "$ref": "#/definitions/cosmos.tx.v1beta1.Tx",
          "description": "tx is the transaction to encode."
        }
      },
      "description": "TxEncodeRequest is the request type for the Service.TxEncode\nRPC method.\n\nSince: cosmos-sdk 0.47"
    },
    "cosmos.tx.v1beta1.TxEncodeResponse": {
      "type": "object",
      "properties": {
        "tx_bytes": {
          "type": "string",
          "format": "byte",
          "description": "tx_bytes is the encoded transaction bytes."
        }
      },
      "description": "TxEncodeResponse is the response type for the\nService.TxEncode method.\n\nSince: cosmos-sdk 0.47"
    },
    "tendermint.abci.Event": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "attributes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              },
              "index": {
                "type": "boolean"
              }
            },
            "description": "EventAttribute is a single key-value pair, associated with an event."
          }
        }
      },
      "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events."
    },
    "tendermint.abci.EventAttribute": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        },
        "index": {
          "type": "boolean"
        }
      },
      "description": "EventAttribute is a single key-value pair, associated with an event."
    },
    "tendermint.crypto.PublicKey": {
      "type": "object",
      "properties": {
        "ed25519": {
          "type": "string",
          "format": "byte"
        },
        "secp256k1": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PublicKey defines the keys available for use with Validators"
    },
    "tendermint.types.Block": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a block header."
        },
        "data": {
          "type": "object",
          "properties": {
            "txs": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "byte"
              },
              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
            }
          },
          "title": "Data contains the set of transactions included in the block"
        },
        "evidence": {
          "type": "object",
          "properties": {
            "evidence": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "duplicate_vote_evidence": {
                    "type": "object",
                    "properties": {
                      "vote_a": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "vote_b": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "validator_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                  },
                  "light_client_attack_evidence": {
                    "type": "object",
                    "properties": {
                      "conflicting_block": {
                        "type": "object",
                        "properties": {
                          "signed_header": {
                            "type": "object",
                            "properties": {
                              "header": {
                                "type": "object",
                                "properties": {
                                  "version": {
                                    "title": "basic block info",
                                    "type": "object",
                                    "properties": {
                                      "block": {
                                        "type": "string",
                                        "format": "uint64"
                                      },
                                      "app": {
                                        "type": "string",
                                        "format": "uint64"
                                      }
                                    },
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                  },
                                  "chain_id": {
                                    "type": "string"
                                  },
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "time": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "last_block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "last_commit_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes of block data"
                                  },
                                  "data_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "validators_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block"
                                  },
                                  "next_validators_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "consensus_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "app_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "last_results_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "evidence_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "consensus info"
                                  },
                                  "proposer_address": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "Header defines the structure of a block header."
                              },
                              "commit": {
                                "type": "object",
                                "properties": {
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "round": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "signatures": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "block_id_flag": {
                                          "type": "string",
                                          "enum": [
                                            "BLOCK_ID_FLAG_UNKNOWN",
                                            "BLOCK_ID_FLAG_ABSENT",
                                            "BLOCK_ID_FLAG_COMMIT",
                                            "BLOCK_ID_FLAG_NIL"
                                          ],
                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                          "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                        },
                                        "validator_address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "timestamp": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "signature": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                    }
                                  }
                                },
                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                              }
                            }
                          },
                          "validator_set": {
                            "type": "object",
                            "properties": {
                              "validators": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "address": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "pub_key": {
                                      "type": "object",
                                      "properties": {
                                        "ed25519": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "secp256k1": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "title": "PublicKey defines the keys available for use with Validators"
                                    },
                                    "voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "proposer_priority": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              },
                              "proposer": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PublicKey defines the keys available for use with Validators"
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              },
                              "total_voting_power": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "common_height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "byzantine_validators": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "address": {
                              "type": "string",
                              "format": "byte"
                            },
                            "pub_key": {
                              "type": "object",
                              "properties": {
                                "ed25519": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "secp256k1": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PublicKey defines the keys available for use with Validators"
                            },
                            "voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "proposer_priority": {
                              "type": "string",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                  }
                }
              }
            }
          }
        },
        "last_commit": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "signatures": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "block_id_flag": {
                    "type": "string",
                    "enum": [
                      "BLOCK_ID_FLAG_UNKNOWN",
                      "BLOCK_ID_FLAG_ABSENT",
                      "BLOCK_ID_FLAG_COMMIT",
                      "BLOCK_ID_FLAG_NIL"
                    ],
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "title": "BlockIdFlag indicates which BlcokID the signature is for"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "signature": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "CommitSig is a part of the Vote included in a Commit."
              }
            }
          },
          "description": "Commit contains the evidence that a block was committed by a set of validators."
        }
      }
    },
    "tendermint.types.BlockID": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "format": "byte"
        },
        "part_set_header": {
          "type": "object",
          "properties": {
            "total": {
              "type": "integer",
              "format": "int64"
            },
            "hash": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PartsetHeader"
        }
      },
      "title": "BlockID"
    },
    "tendermint.types.BlockIDFlag": {
      "type": "string",
      "enum": [
        "BLOCK_ID_FLAG_UNKNOWN",
        "BLOCK_ID_FLAG_ABSENT",
        "BLOCK_ID_FLAG_COMMIT",
        "BLOCK_ID_FLAG_NIL"
      ],
      "default": "BLOCK_ID_FLAG_UNKNOWN",
      "title": "BlockIdFlag indicates which BlcokID the signature is for"
    },
    "tendermint.types.Commit": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "signatures": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "block_id_flag": {
                "type": "string",
                "enum": [
                  "BLOCK_ID_FLAG_UNKNOWN",
                  "BLOCK_ID_FLAG_ABSENT",
                  "BLOCK_ID_FLAG_COMMIT",
                  "BLOCK_ID_FLAG_NIL"
                ],
                "default": "BLOCK_ID_FLAG_UNKNOWN",
                "title": "BlockIdFlag indicates which BlcokID the signature is for"
              },
              "validator_address": {
                "type": "string",
                "format": "byte"
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              },
              "signature": {
                "type": "string",
                "format": "byte"
              }
            },
            "description": "CommitSig is a part of the Vote included in a Commit."
          }
        }
      },
      "description": "Commit contains the evidence that a block was committed by a set of validators."
    },
    "tendermint.types.CommitSig": {
      "type": "object",
      "properties": {
        "block_id_flag": {
          "type": "string",
          "enum": [
            "BLOCK_ID_FLAG_UNKNOWN",
            "BLOCK_ID_FLAG_ABSENT",
            "BLOCK_ID_FLAG_COMMIT",
            "BLOCK_ID_FLAG_NIL"
          ],
          "default": "BLOCK_ID_FLAG_UNKNOWN",
          "title": "BlockIdFlag indicates which BlcokID the signature is for"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "signature": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "CommitSig is a part of the Vote included in a Commit."
    },
    "tendermint.types.Data": {
      "type": "object",
      "properties": {
        "txs": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
        }
      },
      "title": "Data contains the set of transactions included in the block"
    },
    "tendermint.types.DuplicateVoteEvidence": {
      "type": "object",
      "properties": {
        "vote_a": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SIGNED_MSG_TYPE_UNKNOWN",
                "SIGNED_MSG_TYPE_PREVOTE",
                "SIGNED_MSG_TYPE_PRECOMMIT",
                "SIGNED_MSG_TYPE_PROPOSAL"
              ],
              "default": "SIGNED_MSG_TYPE_UNKNOWN",
              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_index": {
              "type": "integer",
              "format": "int32"
            },
            "signature": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
        },
        "vote_b": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "SIGNED_MSG_TYPE_UNKNOWN",
                "SIGNED_MSG_TYPE_PREVOTE",
                "SIGNED_MSG_TYPE_PRECOMMIT",
                "SIGNED_MSG_TYPE_PROPOSAL"
              ],
              "default": "SIGNED_MSG_TYPE_UNKNOWN",
              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            },
            "validator_address": {
              "type": "string",
              "format": "byte"
            },
            "validator_index": {
              "type": "integer",
              "format": "int32"
            },
            "signature": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        },
        "validator_power": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
    },
    "tendermint.types.Evidence": {
      "type": "object",
      "properties": {
        "duplicate_vote_evidence": {
          "type": "object",
          "properties": {
            "vote_a": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "SIGNED_MSG_TYPE_UNKNOWN",
                    "SIGNED_MSG_TYPE_PREVOTE",
                    "SIGNED_MSG_TYPE_PRECOMMIT",
                    "SIGNED_MSG_TYPE_PROPOSAL"
                  ],
                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "timestamp": {
                  "type": "string",
                  "format": "date-time"
                },
                "validator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "validator_index": {
                  "type": "integer",
                  "format": "int32"
                },
                "signature": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
            },
            "vote_b": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string",
                  "enum": [
                    "SIGNED_MSG_TYPE_UNKNOWN",
                    "SIGNED_MSG_TYPE_PREVOTE",
                    "SIGNED_MSG_TYPE_PRECOMMIT",
                    "SIGNED_MSG_TYPE_PROPOSAL"
                  ],
                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "timestamp": {
                  "type": "string",
                  "format": "date-time"
                },
                "validator_address": {
                  "type": "string",
                  "format": "byte"
                },
                "validator_index": {
                  "type": "integer",
                  "format": "int32"
                },
                "signature": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            },
            "validator_power": {
              "type": "string",
              "format": "int64"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
        },
        "light_client_attack_evidence": {
          "type": "object",
          "properties": {
            "conflicting_block": {
              "type": "object",
              "properties": {
                "signed_header": {
                  "type": "object",
                  "properties": {
                    "header": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "basic block info",
                          "type": "object",
                          "properties": {
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          },
                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                        },
                        "chain_id": {
                          "type": "string"
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "time": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "last_block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "last_commit_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes of block data"
                        },
                        "data_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "validators_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "hashes from the app output from the prev block"
                        },
                        "next_validators_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "consensus_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "app_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "last_results_hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "evidence_hash": {
                          "type": "string",
                          "format": "byte",
                          "title": "consensus info"
                        },
                        "proposer_address": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Header defines the structure of a block header."
                    },
                    "commit": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "type": "object",
                          "properties": {
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PartsetHeader"
                            }
                          },
                          "title": "BlockID"
                        },
                        "signatures": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "block_id_flag": {
                                "type": "string",
                                "enum": [
                                  "BLOCK_ID_FLAG_UNKNOWN",
                                  "BLOCK_ID_FLAG_ABSENT",
                                  "BLOCK_ID_FLAG_COMMIT",
                                  "BLOCK_ID_FLAG_NIL"
                                ],
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "title": "BlockIdFlag indicates which BlcokID the signature is for"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "CommitSig is a part of the Vote included in a Commit."
                          }
                        }
                      },
                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                    }
                  }
                },
                "validator_set": {
                  "type": "object",
                  "properties": {
                    "validators": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "pub_key": {
                            "type": "object",
                            "properties": {
                              "ed25519": {
                                "type": "string",
                                "format": "byte"
                              },
                              "secp256k1": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PublicKey defines the keys available for use with Validators"
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    },
                    "proposer": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "ed25519": {
                              "type": "string",
                              "format": "byte"
                            },
                            "secp256k1": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PublicKey defines the keys available for use with Validators"
                        },
                        "voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "proposer_priority": {
                          "type": "string",
                          "format": "int64"
                        }
                      }
                    },
                    "total_voting_power": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                }
              }
            },
            "common_height": {
              "type": "string",
              "format": "int64"
            },
            "byzantine_validators": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "pub_key": {
                    "type": "object",
                    "properties": {
                      "ed25519": {
                        "type": "string",
                        "format": "byte"
                      },
                      "secp256k1": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "PublicKey defines the keys available for use with Validators"
                  },
                  "voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "proposer_priority": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              }
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            },
            "timestamp": {
              "type": "string",
              "format": "date-time"
            }
          },
          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
        }
      }
    },
    "tendermint.types.EvidenceList": {
      "type": "object",
      "properties": {
        "evidence": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "duplicate_vote_evidence": {
                "type": "object",
                "properties": {
                  "vote_a": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "SIGNED_MSG_TYPE_UNKNOWN",
                          "SIGNED_MSG_TYPE_PREVOTE",
                          "SIGNED_MSG_TYPE_PRECOMMIT",
                          "SIGNED_MSG_TYPE_PROPOSAL"
                        ],
                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                      },
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "round": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "block_id": {
                        "type": "object",
                        "properties": {
                          "hash": {
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PartsetHeader"
                          }
                        },
                        "title": "BlockID"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_index": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                  },
                  "vote_b": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "enum": [
                          "SIGNED_MSG_TYPE_UNKNOWN",
                          "SIGNED_MSG_TYPE_PREVOTE",
                          "SIGNED_MSG_TYPE_PRECOMMIT",
                          "SIGNED_MSG_TYPE_PROPOSAL"
                        ],
                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                      },
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "round": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "block_id": {
                        "type": "object",
                        "properties": {
                          "hash": {
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "title": "PartsetHeader"
                          }
                        },
                        "title": "BlockID"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "validator_index": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                  },
                  "total_voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "validator_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
              },
              "light_client_attack_evidence": {
                "type": "object",
                "properties": {
                  "conflicting_block": {
                    "type": "object",
                    "properties": {
                      "signed_header": {
                        "type": "object",
                        "properties": {
                          "header": {
                            "type": "object",
                            "properties": {
                              "version": {
                                "title": "basic block info",
                                "type": "object",
                                "properties": {
                                  "block": {
                                    "type": "string",
                                    "format": "uint64"
                                  },
                                  "app": {
                                    "type": "string",
                                    "format": "uint64"
                                  }
                                },
                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                              },
                              "chain_id": {
                                "type": "string"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "time": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "last_block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "last_commit_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "hashes of block data"
                              },
                              "data_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validators_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "hashes from the app output from the prev block"
                              },
                              "next_validators_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "consensus_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "app_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "last_results_hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "evidence_hash": {
                                "type": "string",
                                "format": "byte",
                                "title": "consensus info"
                              },
                              "proposer_address": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Header defines the structure of a block header."
                          },
                          "commit": {
                            "type": "object",
                            "properties": {
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "signatures": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "block_id_flag": {
                                      "type": "string",
                                      "enum": [
                                        "BLOCK_ID_FLAG_UNKNOWN",
                                        "BLOCK_ID_FLAG_ABSENT",
                                        "BLOCK_ID_FLAG_COMMIT",
                                        "BLOCK_ID_FLAG_NIL"
                                      ],
                                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                                      "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                    },
                                    "validator_address": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "timestamp": {
                                      "type": "string",
                                      "format": "date-time"
                                    },
                                    "signature": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "description": "CommitSig is a part of the Vote included in a Commit."
                                }
                              }
                            },
                            "description": "Commit contains the evidence that a block was committed by a set of validators."
                          }
                        }
                      },
                      "validator_set": {
                        "type": "object",
                        "properties": {
                          "validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "proposer": {
                            "type": "object",
                            "properties": {
                              "address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "pub_key": {
                                "type": "object",
                                "properties": {
                                  "ed25519": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "secp256k1": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PublicKey defines the keys available for use with Validators"
                              },
                              "voting_power": {
                                "type": "string",
                                "format": "int64"
                              },
                              "proposer_priority": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    }
                  },
                  "common_height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "byzantine_validators": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string",
                          "format": "byte"
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "ed25519": {
                              "type": "string",
                              "format": "byte"
                            },
                            "secp256k1": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PublicKey defines the keys available for use with Validators"
                        },
                        "voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "proposer_priority": {
                          "type": "string",
                          "format": "int64"
                        }
                      }
                    }
                  },
                  "total_voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  }
                },
                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
              }
            }
          }
        }
      }
    },
    "tendermint.types.Header": {
      "type": "object",
      "properties": {
        "version": {
          "title": "basic block info",
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          },
          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
        },
        "chain_id": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "last_block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "last_commit_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes of block data"
        },
        "data_hash": {
          "type": "string",
          "format": "byte"
        },
        "validators_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes from the app output from the prev block"
        },
        "next_validators_hash": {
          "type": "string",
          "format": "byte"
        },
        "consensus_hash": {
          "type": "string",
          "format": "byte"
        },
        "app_hash": {
          "type": "string",
          "format": "byte"
        },
        "last_results_hash": {
          "type": "string",
          "format": "byte"
        },
        "evidence_hash": {
          "type": "string",
          "format": "byte",
          "title": "consensus info"
        },
        "proposer_address": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Header defines the structure of a block header."
    },
    "tendermint.types.LightBlock": {
      "type": "object",
      "properties": {
        "signed_header": {
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a block header."
            },
            "commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        },
        "validator_set": {
          "type": "object",
          "properties": {
            "validators": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "pub_key": {
                    "type": "object",
                    "properties": {
                      "ed25519": {
                        "type": "string",
                        "format": "byte"
                      },
                      "secp256k1": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "title": "PublicKey defines the keys available for use with Validators"
                  },
                  "voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "proposer_priority": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              }
            },
            "proposer": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "format": "byte"
                },
                "pub_key": {
                  "type": "object",
                  "properties": {
                    "ed25519": {
                      "type": "string",
                      "format": "byte"
                    },
                    "secp256k1": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PublicKey defines the keys available for use with Validators"
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              }
            },
            "total_voting_power": {
              "type": "string",
              "format": "int64"
            }
          }
        }
      }
    },
    "tendermint.types.LightClientAttackEvidence": {
      "type": "object",
      "properties": {
        "conflicting_block": {
          "type": "object",
          "properties": {
            "signed_header": {
              "type": "object",
              "properties": {
                "header": {
                  "type": "object",
                  "properties": {
                    "version": {
                      "title": "basic block info",
                      "type": "object",
                      "properties": {
                        "block": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "app": {
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                    },
                    "chain_id": {
                      "type": "string"
                    },
                    "height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "time": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "last_block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PartsetHeader"
                        }
                      },
                      "title": "BlockID"
                    },
                    "last_commit_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "hashes of block data"
                    },
                    "data_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "validators_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "hashes from the app output from the prev block"
                    },
                    "next_validators_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "consensus_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "app_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "last_results_hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "evidence_hash": {
                      "type": "string",
                      "format": "byte",
                      "title": "consensus info"
                    },
                    "proposer_address": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "Header defines the structure of a block header."
                },
                "commit": {
                  "type": "object",
                  "properties": {
                    "height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "round": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "block_id": {
                      "type": "object",
                      "properties": {
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "title": "PartsetHeader"
                        }
                      },
                      "title": "BlockID"
                    },
                    "signatures": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "block_id_flag": {
                            "type": "string",
                            "enum": [
                              "BLOCK_ID_FLAG_UNKNOWN",
                              "BLOCK_ID_FLAG_ABSENT",
                              "BLOCK_ID_FLAG_COMMIT",
                              "BLOCK_ID_FLAG_NIL"
                            ],
                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                            "title": "BlockIdFlag indicates which BlcokID the signature is for"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "CommitSig is a part of the Vote included in a Commit."
                      }
                    }
                  },
                  "description": "Commit contains the evidence that a block was committed by a set of validators."
                }
              }
            },
            "validator_set": {
              "type": "object",
              "properties": {
                "validators": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "pub_key": {
                        "type": "object",
                        "properties": {
                          "ed25519": {
                            "type": "string",
                            "format": "byte"
                          },
                          "secp256k1": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "title": "PublicKey defines the keys available for use with Validators"
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    }
                  }
                },
                "proposer": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "type": "string",
                      "format": "byte"
                    },
                    "pub_key": {
                      "type": "object",
                      "properties": {
                        "ed25519": {
                          "type": "string",
                          "format": "byte"
                        },
                        "secp256k1": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PublicKey defines the keys available for use with Validators"
                    },
                    "voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "proposer_priority": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                },
                "total_voting_power": {
                  "type": "string",
                  "format": "int64"
                }
              }
            }
          }
        },
        "common_height": {
          "type": "string",
          "format": "int64"
        },
        "byzantine_validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "format": "byte"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "ed25519": {
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "title": "PublicKey defines the keys available for use with Validators"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            }
          }
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
    },
    "tendermint.types.PartSetHeader": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int64"
        },
        "hash": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "PartsetHeader"
    },
    "tendermint.types.SignedHeader": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "format": "byte"
            }
          },
          "description": "Header defines the structure of a block header."
        },
        "commit": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "signatures": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "block_id_flag": {
                    "type": "string",
                    "enum": [
                      "BLOCK_ID_FLAG_UNKNOWN",
                      "BLOCK_ID_FLAG_ABSENT",
                      "BLOCK_ID_FLAG_COMMIT",
                      "BLOCK_ID_FLAG_NIL"
                    ],
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "title": "BlockIdFlag indicates which BlcokID the signature is for"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "signature": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "CommitSig is a part of the Vote included in a Commit."
              }
            }
          },
          "description": "Commit contains the evidence that a block was committed by a set of validators."
        }
      }
    },
    "tendermint.types.SignedMsgType": {
      "type": "string",
      "enum": [
        "SIGNED_MSG_TYPE_UNKNOWN",
        "SIGNED_MSG_TYPE_PREVOTE",
        "SIGNED_MSG_TYPE_PRECOMMIT",
        "SIGNED_MSG_TYPE_PROPOSAL"
      ],
      "default": "SIGNED_MSG_TYPE_UNKNOWN",
      "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
    },
    "tendermint.types.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "ed25519": {
              "type": "string",
              "format": "byte"
            },
            "secp256k1": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PublicKey defines the keys available for use with Validators"
        },
        "voting_power": {
          "type": "string",
          "format": "int64"
        },
        "proposer_priority": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "tendermint.types.ValidatorSet": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string",
                "format": "byte"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "ed25519": {
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "title": "PublicKey defines the keys available for use with Validators"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            }
          }
        },
        "proposer": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "format": "byte"
            },
            "pub_key": {
              "type": "object",
              "properties": {
                "ed25519": {
                  "type": "string",
                  "format": "byte"
                },
                "secp256k1": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PublicKey defines the keys available for use with Validators"
            },
            "voting_power": {
              "type": "string",
              "format": "int64"
            },
            "proposer_priority": {
              "type": "string",
              "format": "int64"
            }
          }
        },
        "total_voting_power": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "tendermint.types.Vote": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "SIGNED_MSG_TYPE_UNKNOWN",
            "SIGNED_MSG_TYPE_PREVOTE",
            "SIGNED_MSG_TYPE_PRECOMMIT",
            "SIGNED_MSG_TYPE_PROPOSAL"
          ],
          "default": "SIGNED_MSG_TYPE_UNKNOWN",
          "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "round": {
          "type": "integer",
          "format": "int32"
        },
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "validator_address": {
          "type": "string",
          "format": "byte"
        },
        "validator_index": {
          "type": "integer",
          "format": "int32"
        },
        "signature": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
    },
    "tendermint.version.Consensus": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
    },
    "cosmos.base.tendermint.v1beta1.ABCIQueryResponse": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int64"
        },
        "log": {
          "type": "string"
        },
        "info": {
          "type": "string"
        },
        "index": {
          "type": "string",
          "format": "int64"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "value": {
          "type": "string",
          "format": "byte"
        },
        "proof_ops": {
          "type": "object",
          "properties": {
            "ops": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "key": {
                    "type": "string",
                    "format": "byte"
                  },
                  "data": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
              }
            }
          },
          "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "codespace": {
          "type": "string"
        }
      },
      "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.\n\nNote: This type is a duplicate of the ResponseQuery proto type defined in\nTendermint."
    },
    "cosmos.base.tendermint.v1beta1.Block": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "properties": {
            "version": {
              "title": "basic block info",
              "type": "object",
              "properties": {
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
            },
            "chain_id": {
              "type": "string"
            },
            "height": {
              "type": "string",
              "format": "int64"
            },
            "time": {
              "type": "string",
              "format": "date-time"
            },
            "last_block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "last_commit_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes of block data"
            },
            "data_hash": {
              "type": "string",
              "format": "byte"
            },
            "validators_hash": {
              "type": "string",
              "format": "byte",
              "title": "hashes from the app output from the prev block"
            },
            "next_validators_hash": {
              "type": "string",
              "format": "byte"
            },
            "consensus_hash": {
              "type": "string",
              "format": "byte"
            },
            "app_hash": {
              "type": "string",
              "format": "byte"
            },
            "last_results_hash": {
              "type": "string",
              "format": "byte"
            },
            "evidence_hash": {
              "type": "string",
              "format": "byte",
              "title": "consensus info"
            },
            "proposer_address": {
              "type": "string",
              "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
            }
          },
          "description": "Header defines the structure of a Tendermint block header."
        },
        "data": {
          "type": "object",
          "properties": {
            "txs": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "byte"
              },
              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
            }
          },
          "title": "Data contains the set of transactions included in the block"
        },
        "evidence": {
          "type": "object",
          "properties": {
            "evidence": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "duplicate_vote_evidence": {
                    "type": "object",
                    "properties": {
                      "vote_a": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "vote_b": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string",
                            "enum": [
                              "SIGNED_MSG_TYPE_UNKNOWN",
                              "SIGNED_MSG_TYPE_PREVOTE",
                              "SIGNED_MSG_TYPE_PRECOMMIT",
                              "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "type": "object",
                            "properties": {
                              "hash": {
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "title": "PartsetHeader"
                              }
                            },
                            "title": "BlockID"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "validator_address": {
                            "type": "string",
                            "format": "byte"
                          },
                          "validator_index": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "signature": {
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "validator_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                  },
                  "light_client_attack_evidence": {
                    "type": "object",
                    "properties": {
                      "conflicting_block": {
                        "type": "object",
                        "properties": {
                          "signed_header": {
                            "type": "object",
                            "properties": {
                              "header": {
                                "type": "object",
                                "properties": {
                                  "version": {
                                    "title": "basic block info",
                                    "type": "object",
                                    "properties": {
                                      "block": {
                                        "type": "string",
                                        "format": "uint64"
                                      },
                                      "app": {
                                        "type": "string",
                                        "format": "uint64"
                                      }
                                    },
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                  },
                                  "chain_id": {
                                    "type": "string"
                                  },
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "time": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "last_block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "last_commit_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes of block data"
                                  },
                                  "data_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "validators_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block"
                                  },
                                  "next_validators_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "consensus_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "app_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "last_results_hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "evidence_hash": {
                                    "type": "string",
                                    "format": "byte",
                                    "title": "consensus info"
                                  },
                                  "proposer_address": {
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "Header defines the structure of a block header."
                              },
                              "commit": {
                                "type": "object",
                                "properties": {
                                  "height": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "round": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "block_id": {
                                    "type": "object",
                                    "properties": {
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "part_set_header": {
                                        "type": "object",
                                        "properties": {
                                          "total": {
                                            "type": "integer",
                                            "format": "int64"
                                          },
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PartsetHeader"
                                      }
                                    },
                                    "title": "BlockID"
                                  },
                                  "signatures": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "block_id_flag": {
                                          "type": "string",
                                          "enum": [
                                            "BLOCK_ID_FLAG_UNKNOWN",
                                            "BLOCK_ID_FLAG_ABSENT",
                                            "BLOCK_ID_FLAG_COMMIT",
                                            "BLOCK_ID_FLAG_NIL"
                                          ],
                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                          "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                        },
                                        "validator_address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "timestamp": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "signature": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                    }
                                  }
                                },
                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                              }
                            }
                          },
                          "validator_set": {
                            "type": "object",
                            "properties": {
                              "validators": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "address": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "pub_key": {
                                      "type": "object",
                                      "properties": {
                                        "ed25519": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "secp256k1": {
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "title": "PublicKey defines the keys available for use with Validators"
                                    },
                                    "voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "proposer_priority": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              },
                              "proposer": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PublicKey defines the keys available for use with Validators"
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              },
                              "total_voting_power": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          }
                        }
                      },
                      "common_height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "byzantine_validators": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "address": {
                              "type": "string",
                              "format": "byte"
                            },
                            "pub_key": {
                              "type": "object",
                              "properties": {
                                "ed25519": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "secp256k1": {
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "title": "PublicKey defines the keys available for use with Validators"
                            },
                            "voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "proposer_priority": {
                              "type": "string",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      }
                    },
                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                  }
                }
              }
            }
          }
        },
        "last_commit": {
          "type": "object",
          "properties": {
            "height": {
              "type": "string",
              "format": "int64"
            },
            "round": {
              "type": "integer",
              "format": "int32"
            },
            "block_id": {
              "type": "object",
              "properties": {
                "hash": {
                  "type": "string",
                  "format": "byte"
                },
                "part_set_header": {
                  "type": "object",
                  "properties": {
                    "total": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "title": "PartsetHeader"
                }
              },
              "title": "BlockID"
            },
            "signatures": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "block_id_flag": {
                    "type": "string",
                    "enum": [
                      "BLOCK_ID_FLAG_UNKNOWN",
                      "BLOCK_ID_FLAG_ABSENT",
                      "BLOCK_ID_FLAG_COMMIT",
                      "BLOCK_ID_FLAG_NIL"
                    ],
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "title": "BlockIdFlag indicates which BlcokID the signature is for"
                  },
                  "validator_address": {
                    "type": "string",
                    "format": "byte"
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "signature": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "CommitSig is a part of the Vote included in a Commit."
              }
            }
          },
          "description": "Commit contains the evidence that a block was committed by a set of validators."
        }
      },
      "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
    },
    "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
      "type": "object",
      "properties": {
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "block": {
          "title": "Deprecated: please use `sdk_block` instead",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        },
        "sdk_block": {
          "title": "Since: cosmos-sdk 0.47",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          },
          "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
        }
      },
      "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
      "type": "object",
      "properties": {
        "block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "block": {
          "title": "Deprecated: please use `sdk_block` instead",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "Header defines the structure of a block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          }
        },
        "sdk_block": {
          "title": "Since: cosmos-sdk 0.47",
          "type": "object",
          "properties": {
            "header": {
              "type": "object",
              "properties": {
                "version": {
                  "title": "basic block info",
                  "type": "object",
                  "properties": {
                    "block": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "app": {
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                },
                "chain_id": {
                  "type": "string"
                },
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "time": {
                  "type": "string",
                  "format": "date-time"
                },
                "last_block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "last_commit_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes of block data"
                },
                "data_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "validators_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "hashes from the app output from the prev block"
                },
                "next_validators_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "consensus_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "app_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "last_results_hash": {
                  "type": "string",
                  "format": "byte"
                },
                "evidence_hash": {
                  "type": "string",
                  "format": "byte",
                  "title": "consensus info"
                },
                "proposer_address": {
                  "type": "string",
                  "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                }
              },
              "description": "Header defines the structure of a Tendermint block header."
            },
            "data": {
              "type": "object",
              "properties": {
                "txs": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "byte"
                  },
                  "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs."
                }
              },
              "title": "Data contains the set of transactions included in the block"
            },
            "evidence": {
              "type": "object",
              "properties": {
                "evidence": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "duplicate_vote_evidence": {
                        "type": "object",
                        "properties": {
                          "vote_a": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "vote_b": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string",
                                "enum": [
                                  "SIGNED_MSG_TYPE_UNKNOWN",
                                  "SIGNED_MSG_TYPE_PREVOTE",
                                  "SIGNED_MSG_TYPE_PRECOMMIT",
                                  "SIGNED_MSG_TYPE_PROPOSAL"
                                ],
                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"
                              },
                              "height": {
                                "type": "string",
                                "format": "int64"
                              },
                              "round": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "block_id": {
                                "type": "object",
                                "properties": {
                                  "hash": {
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "part_set_header": {
                                    "type": "object",
                                    "properties": {
                                      "total": {
                                        "type": "integer",
                                        "format": "int64"
                                      },
                                      "hash": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "title": "PartsetHeader"
                                  }
                                },
                                "title": "BlockID"
                              },
                              "timestamp": {
                                "type": "string",
                                "format": "date-time"
                              },
                              "validator_address": {
                                "type": "string",
                                "format": "byte"
                              },
                              "validator_index": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "signature": {
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus."
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "validator_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                      },
                      "light_client_attack_evidence": {
                        "type": "object",
                        "properties": {
                          "conflicting_block": {
                            "type": "object",
                            "properties": {
                              "signed_header": {
                                "type": "object",
                                "properties": {
                                  "header": {
                                    "type": "object",
                                    "properties": {
                                      "version": {
                                        "title": "basic block info",
                                        "type": "object",
                                        "properties": {
                                          "block": {
                                            "type": "string",
                                            "format": "uint64"
                                          },
                                          "app": {
                                            "type": "string",
                                            "format": "uint64"
                                          }
                                        },
                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                      },
                                      "chain_id": {
                                        "type": "string"
                                      },
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "time": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "last_block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "last_commit_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes of block data"
                                      },
                                      "data_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "validators_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "hashes from the app output from the prev block"
                                      },
                                      "next_validators_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "consensus_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "app_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "last_results_hash": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "evidence_hash": {
                                        "type": "string",
                                        "format": "byte",
                                        "title": "consensus info"
                                      },
                                      "proposer_address": {
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "Header defines the structure of a block header."
                                  },
                                  "commit": {
                                    "type": "object",
                                    "properties": {
                                      "height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "round": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "block_id": {
                                        "type": "object",
                                        "properties": {
                                          "hash": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "part_set_header": {
                                            "type": "object",
                                            "properties": {
                                              "total": {
                                                "type": "integer",
                                                "format": "int64"
                                              },
                                              "hash": {
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "title": "PartsetHeader"
                                          }
                                        },
                                        "title": "BlockID"
                                      },
                                      "signatures": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "block_id_flag": {
                                              "type": "string",
                                              "enum": [
                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                "BLOCK_ID_FLAG_ABSENT",
                                                "BLOCK_ID_FLAG_COMMIT",
                                                "BLOCK_ID_FLAG_NIL"
                                              ],
                                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                                              "title": "BlockIdFlag indicates which BlcokID the signature is for"
                                            },
                                            "validator_address": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "timestamp": {
                                              "type": "string",
                                              "format": "date-time"
                                            },
                                            "signature": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "description": "CommitSig is a part of the Vote included in a Commit."
                                        }
                                      }
                                    },
                                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                                  }
                                }
                              },
                              "validator_set": {
                                "type": "object",
                                "properties": {
                                  "validators": {
                                    "type": "array",
                                    "items": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          },
                                          "title": "PublicKey defines the keys available for use with Validators"
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    }
                                  },
                                  "proposer": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "title": "PublicKey defines the keys available for use with Validators"
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  },
                                  "total_voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            }
                          },
                          "common_height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "byzantine_validators": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "title": "PublicKey defines the keys available for use with Validators"
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          },
                          "total_voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "timestamp": {
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                      }
                    }
                  }
                }
              }
            },
            "last_commit": {
              "type": "object",
              "properties": {
                "height": {
                  "type": "string",
                  "format": "int64"
                },
                "round": {
                  "type": "integer",
                  "format": "int32"
                },
                "block_id": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "format": "byte"
                    },
                    "part_set_header": {
                      "type": "object",
                      "properties": {
                        "total": {
                          "type": "integer",
                          "format": "int64"
                        },
                        "hash": {
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "title": "PartsetHeader"
                    }
                  },
                  "title": "BlockID"
                },
                "signatures": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "block_id_flag": {
                        "type": "string",
                        "enum": [
                          "BLOCK_ID_FLAG_UNKNOWN",
                          "BLOCK_ID_FLAG_ABSENT",
                          "BLOCK_ID_FLAG_COMMIT",
                          "BLOCK_ID_FLAG_NIL"
                        ],
                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                        "title": "BlockIdFlag indicates which BlcokID the signature is for"
                      },
                      "validator_address": {
                        "type": "string",
                        "format": "byte"
                      },
                      "timestamp": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "signature": {
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "CommitSig is a part of the Vote included in a Commit."
                  }
                }
              },
              "description": "Commit contains the evidence that a block was committed by a set of validators."
            }
          },
          "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
        }
      },
      "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
      "type": "object",
      "properties": {
        "block_height": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            },
            "description": "Validator is the type for the validator-set."
          }
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
      "type": "object",
      "properties": {
        "default_node_info": {
          "type": "object",
          "properties": {
            "protocol_version": {
              "type": "object",
              "properties": {
                "p2p": {
                  "type": "string",
                  "format": "uint64"
                },
                "block": {
                  "type": "string",
                  "format": "uint64"
                },
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              }
            },
            "default_node_id": {
              "type": "string"
            },
            "listen_addr": {
              "type": "string"
            },
            "network": {
              "type": "string"
            },
            "version": {
              "type": "string"
            },
            "channels": {
              "type": "string",
              "format": "byte"
            },
            "moniker": {
              "type": "string"
            },
            "other": {
              "type": "object",
              "properties": {
                "tx_index": {
                  "type": "string"
                },
                "rpc_address": {
                  "type": "string"
                }
              }
            }
          }
        },
        "application_version": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "app_name": {
              "type": "string"
            },
            "version": {
              "type": "string"
            },
            "git_commit": {
              "type": "string"
            },
            "build_tags": {
              "type": "string"
            },
            "go_version": {
              "type": "string"
            },
            "build_deps": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "path": {
                    "type": "string",
                    "title": "module path"
                  },
                  "version": {
                    "type": "string",
                    "title": "module version"
                  },
                  "sum": {
                    "type": "string",
                    "title": "checksum"
                  }
                },
                "title": "Module is the type for VersionInfo"
              }
            },
            "cosmos_sdk_version": {
              "type": "string",
              "title": "Since: cosmos-sdk 0.43"
            }
          },
          "description": "VersionInfo is the type for the GetNodeInfoResponse message."
        }
      },
      "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
      "type": "object",
      "properties": {
        "syncing": {
          "type": "boolean"
        }
      },
      "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
    },
    "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
      "type": "object",
      "properties": {
        "block_height": {
          "type": "string",
          "format": "int64"
        },
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            },
            "description": "Validator is the type for the validator-set."
          }
        },
        "pagination": {
          "description": "pagination defines an pagination for the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
    },
    "cosmos.base.tendermint.v1beta1.Header": {
      "type": "object",
      "properties": {
        "version": {
          "title": "basic block info",
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          },
          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
        },
        "chain_id": {
          "type": "string"
        },
        "height": {
          "type": "string",
          "format": "int64"
        },
        "time": {
          "type": "string",
          "format": "date-time"
        },
        "last_block_id": {
          "type": "object",
          "properties": {
            "hash": {
              "type": "string",
              "format": "byte"
            },
            "part_set_header": {
              "type": "object",
              "properties": {
                "total": {
                  "type": "integer",
                  "format": "int64"
                },
                "hash": {
                  "type": "string",
                  "format": "byte"
                }
              },
              "title": "PartsetHeader"
            }
          },
          "title": "BlockID"
        },
        "last_commit_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes of block data"
        },
        "data_hash": {
          "type": "string",
          "format": "byte"
        },
        "validators_hash": {
          "type": "string",
          "format": "byte",
          "title": "hashes from the app output from the prev block"
        },
        "next_validators_hash": {
          "type": "string",
          "format": "byte"
        },
        "consensus_hash": {
          "type": "string",
          "format": "byte"
        },
        "app_hash": {
          "type": "string",
          "format": "byte"
        },
        "last_results_hash": {
          "type": "string",
          "format": "byte"
        },
        "evidence_hash": {
          "type": "string",
          "format": "byte",
          "title": "consensus info"
        },
        "proposer_address": {
          "type": "string",
          "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
        }
      },
      "description": "Header defines the structure of a Tendermint block header."
    },
    "cosmos.base.tendermint.v1beta1.Module": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "title": "module path"
        },
        "version": {
          "type": "string",
          "title": "module version"
        },
        "sum": {
          "type": "string",
          "title": "checksum"
        }
      },
      "title": "Module is the type for VersionInfo"
    },
    "cosmos.base.tendermint.v1beta1.ProofOp": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "key": {
          "type": "string",
          "format": "byte"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
    },
    "cosmos.base.tendermint.v1beta1.ProofOps": {
      "type": "object",
      "properties": {
        "ops": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "key": {
                "type": "string",
                "format": "byte"
              },
              "data": {
                "type": "string",
                "format": "byte"
              }
            },
            "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
          }
        }
      },
      "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
    },
    "cosmos.base.tendermint.v1beta1.Validator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "pub_key": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        },
        "voting_power": {
          "type": "string",
          "format": "int64"
        },
        "proposer_priority": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Validator is the type for the validator-set."
    },
    "cosmos.base.tendermint.v1beta1.VersionInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "app_name": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "git_commit": {
          "type": "string"
        },
        "build_tags": {
          "type": "string"
        },
        "go_version": {
          "type": "string"
        },
        "build_deps": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "title": "module path"
              },
              "version": {
                "type": "string",
                "title": "module version"
              },
              "sum": {
                "type": "string",
                "title": "checksum"
              }
            },
            "title": "Module is the type for VersionInfo"
          }
        },
        "cosmos_sdk_version": {
          "type": "string",
          "title": "Since: cosmos-sdk 0.43"
        }
      },
      "description": "VersionInfo is the type for the GetNodeInfoResponse message."
    },
    "tendermint.p2p.DefaultNodeInfo": {
      "type": "object",
      "properties": {
        "protocol_version": {
          "type": "object",
          "properties": {
            "p2p": {
              "type": "string",
              "format": "uint64"
            },
            "block": {
              "type": "string",
              "format": "uint64"
            },
            "app": {
              "type": "string",
              "format": "uint64"
            }
          }
        },
        "default_node_id": {
          "type": "string"
        },
        "listen_addr": {
          "type": "string"
        },
        "network": {
          "type": "string"
        },
        "version": {
          "type": "string"
        },
        "channels": {
          "type": "string",
          "format": "byte"
        },
        "moniker": {
          "type": "string"
        },
        "other": {
          "type": "object",
          "properties": {
            "tx_index": {
              "type": "string"
            },
            "rpc_address": {
              "type": "string"
            }
          }
        }
      }
    },
    "tendermint.p2p.DefaultNodeInfoOther": {
      "type": "object",
      "properties": {
        "tx_index": {
          "type": "string"
        },
        "rpc_address": {
          "type": "string"
        }
      }
    },
    "tendermint.p2p.ProtocolVersion": {
      "type": "object",
      "properties": {
        "p2p": {
          "type": "string",
          "format": "uint64"
        },
        "block": {
          "type": "string",
          "format": "uint64"
        },
        "app": {
          "type": "string",
          "format": "uint64"
        }
      }
    },
    "exocore.dogfood.v1.AccountAddresses": {
      "type": "object",
      "properties": {
        "list": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "list is the list of account addresses."
        }
      },
      "description": "AccountAddresses represents a list of account addresses. It is used to store the list of\noperator addresses whose operations are maturing at an epoch."
    },
    "exocore.dogfood.v1.ExocoreValidator": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string",
          "format": "byte",
          "description": "The address, as derived from the consensus key. It has no relation\nwith the operator's account address."
        },
        "power": {
          "type": "string",
          "format": "int64",
          "title": "Last known power"
        },
        "pubkey": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "ExocoreValidator is a validator that is part of the Exocore network. It is\nused to validate and sign blocks."
    },
    "exocore.dogfood.v1.Params": {
      "type": "object",
      "properties": {
        "epochs_until_unbonded": {
          "type": "integer",
          "format": "int64",
          "description": "EpochsUntilUnbonded is the number of epochs after which an unbonding\nis released. Note that it starts from the beginning of the next epoch\nin which the unbonding request was received. At that point, the vote\npower is reduced by the amount of the unbonding operation."
        },
        "epoch_identifier": {
          "type": "string",
          "description": "EpochIdentifier is the identifier of the epoch (week, hour, day)."
        },
        "max_validators": {
          "type": "integer",
          "format": "int64",
          "description": "MaxValidators is the maximum number of validators."
        },
        "historical_entries": {
          "type": "integer",
          "format": "int64",
          "description": "HistoricalEntries is the number of historical entries to persist."
        },
        "asset_ids": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "AssetIDs is the ids of the assets which will be accepted by the module.\nIt must be within the list of assets supported by the restaking module.\nThe typical format of these IDs is\nlower(assetAddress) + _ + hex(clientChainLzID)"
        },
        "min_self_delegation": {
          "type": "string",
          "description": "MinSelfDelegation is the minimum self delegation in USD required to be a validator."
        }
      },
      "description": "Params defines the parameters for the module."
    },
    "exocore.dogfood.v1.QueryOperatorOptOutFinishEpochResponse": {
      "type": "object",
      "properties": {
        "epoch": {
          "type": "string",
          "format": "int64",
          "description": "epoch is the epoch when the operator's opt-out will finish."
        }
      },
      "description": "QueryOperatorOptOutFinishEpochResponse is response type for the\nQuery/OperatorOptOutFinishEpoch RPC method."
    },
    "exocore.dogfood.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "epochs_until_unbonded": {
              "type": "integer",
              "format": "int64",
              "description": "EpochsUntilUnbonded is the number of epochs after which an unbonding\nis released. Note that it starts from the beginning of the next epoch\nin which the unbonding request was received. At that point, the vote\npower is reduced by the amount of the unbonding operation."
            },
            "epoch_identifier": {
              "type": "string",
              "description": "EpochIdentifier is the identifier of the epoch (week, hour, day)."
            },
            "max_validators": {
              "type": "integer",
              "format": "int64",
              "description": "MaxValidators is the maximum number of validators."
            },
            "historical_entries": {
              "type": "integer",
              "format": "int64",
              "description": "HistoricalEntries is the number of historical entries to persist."
            },
            "asset_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "AssetIDs is the ids of the assets which will be accepted by the module.\nIt must be within the list of assets supported by the restaking module.\nThe typical format of these IDs is\nlower(assetAddress) + _ + hex(clientChainLzID)"
            },
            "min_self_delegation": {
              "type": "string",
              "description": "MinSelfDelegation is the minimum self delegation in USD required to be a validator."
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "exocore.dogfood.v1.QueryUndelegationMaturityEpochResponse": {
      "type": "object",
      "properties": {
        "epoch": {
          "type": "string",
          "format": "int64",
          "description": "epoch is the epoch when the undelegation will mature."
        }
      },
      "description": "QueryUndelegationMaturityEpochResponse is response type for the\nQuery/UndelegationMaturityEpoch RPC method."
    },
    "exocore.dogfood.v1.UndelegationRecordKeys": {
      "type": "object",
      "properties": {
        "list": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "byte"
          },
          "description": "list is the list of undelegation record keys."
        }
      },
      "description": "UndelegationRecordKeys is a collection of undelegation record keys. This is used to store a\nlist of undelegation records to mature in the delegation module at the end of the epoch."
    },
    "exocore.assets.v1.AssetByID": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "asset_id is the id of the asset."
        },
        "info": {
          "description": "info is the asset info.",
          "type": "object",
          "properties": {
            "total_amount": {
              "type": "string",
              "description": "total_amount is the total amount of the asset deposited, which excludes the\npending_undelegation_amount. It represent the total delegated amount of asset pool,\nit will be used to calculate the asset amount of a specified staker from its\ndelegated share."
            },
            "pending_undelegation_amount": {
              "type": "string",
              "description": "pending_undelegation_amount is the amount that is waiting for unbonding."
            },
            "total_share": {
              "type": "string",
              "description": "total_share is the total share of an asset, in the formula to update the staker's share\nS_j = S * T_j / T, `S` represent it.\nSo when the shares of staker and operator change, it also needs to add `S_j` to update."
            },
            "operator_share": {
              "type": "string",
              "description": "operator_share is similar to the share of the staker, the calculation and update should\nbe same, the difference is that it represents the share of the operator itself.\nthe field is used to mark operator's own asset share."
            }
          }
        }
      },
      "title": "AssetByID is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an operator.\nIt is named AssetByID (since it is indexed by the assetID)"
    },
    "exocore.assets.v1.AssetInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the asset, like \"Tether USD\""
        },
        "symbol": {
          "type": "string",
          "title": "symbol of the asset, like \"USDT\""
        },
        "address": {
          "type": "string",
          "title": "address of the asset on the client chain"
        },
        "decimals": {
          "type": "integer",
          "format": "int64",
          "description": "decimals used in the asset, typically 6 or 18."
        },
        "layer_zero_chain_id": {
          "type": "string",
          "format": "uint64",
          "description": "layer_zero_chain_id is the chain id of the asset, according to L0."
        },
        "exocore_chain_index": {
          "type": "string",
          "format": "uint64",
          "description": "exocore_chain_index is the index of the client chain within the exosystem."
        },
        "meta_info": {
          "type": "string",
          "description": "meta_info about the asset, like \"Tether USD on Ethereum blockchain\"."
        }
      },
      "description": "AssetInfo defines the information for an asset to be used in staking."
    },
    "exocore.assets.v1.ClientChainInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name of the client chain, like \"Ethereum\"."
        },
        "meta_info": {
          "type": "string",
          "description": "meta_info about the client chain, like \"Ethereum blockchain\"."
        },
        "chain_id": {
          "type": "string",
          "format": "uint64",
          "description": "chain_id of the client chain. Not necessarily the EVM chain id."
        },
        "exocore_chain_index": {
          "type": "string",
          "format": "uint64",
          "description": "exocore_chain_index is the index of the client chain within the exosystem."
        },
        "finalization_blocks": {
          "type": "string",
          "format": "uint64",
          "description": "finalization_blocks is the number of blocks to wait for finalization."
        },
        "layer_zero_chain_id": {
          "type": "string",
          "format": "uint64",
          "title": "layer_zero_chain_id is the chain id of the client chain, according to L0.\nhttps://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids"
        },
        "signature_type": {
          "type": "string",
          "description": "signature_type is the type of signature used to sign the client chain address."
        },
        "address_length": {
          "type": "integer",
          "format": "int64",
          "description": "client_chain_addr is the length of addresses on the client chain."
        }
      },
      "description": "ClientChainInfo defines the client chain information."
    },
    "exocore.assets.v1.DepositByAsset": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "asset_id is the id of the asset."
        },
        "info": {
          "description": "info is the asset info.",
          "type": "object",
          "properties": {
            "total_deposit_amount": {
              "type": "string",
              "description": "total_deposit_amount is the total amount of the asset deposited."
            },
            "withdrawable_amount": {
              "type": "string",
              "description": "withdrawable_amount is the amount that can be withdrawn."
            },
            "pending_undelegation_amount": {
              "type": "string",
              "description": "pending_undelegation_amount is the amount that is waiting for undelegation."
            }
          }
        }
      },
      "description": "DepositByAsset is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an staker.\nThe info contains the deposit amount, the withdrawable amount\nand the amount currently unbonding.\nIt is named DepositByAsset (since it is indexed by the assetID)\nand not Deposit to prevent conflict with CrossChainOpType."
    },
    "exocore.assets.v1.OperatorAssetInfo": {
      "type": "object",
      "properties": {
        "total_amount": {
          "type": "string",
          "description": "total_amount is the total amount of the asset deposited, which excludes the\npending_undelegation_amount. It represent the total delegated amount of asset pool,\nit will be used to calculate the asset amount of a specified staker from its\ndelegated share."
        },
        "pending_undelegation_amount": {
          "type": "string",
          "description": "pending_undelegation_amount is the amount that is waiting for unbonding."
        },
        "total_share": {
          "type": "string",
          "description": "total_share is the total share of an asset, in the formula to update the staker's share\nS_j = S * T_j / T, `S` represent it.\nSo when the shares of staker and operator change, it also needs to add `S_j` to update."
        },
        "operator_share": {
          "type": "string",
          "description": "operator_share is similar to the share of the staker, the calculation and update should\nbe same, the difference is that it represents the share of the operator itself.\nthe field is used to mark operator's own asset share."
        }
      },
      "description": "OperatorAssetInfo defines the information for a single asset,\nfor an operator."
    },
    "exocore.assets.v1.Params": {
      "type": "object",
      "properties": {
        "exocore_lz_app_address": {
          "type": "string",
          "description": "exocore_lz_app_address is the address of ExocoreGateway.sol."
        },
        "exocore_lz_app_event_topic": {
          "type": "string",
          "description": "exocore_lz_app_event_topic is the topic of the exocore lz app event."
        }
      },
      "description": "GenesisState defines the deposit module's genesis state."
    },
    "exocore.assets.v1.QueryAllClientChainInfoResponse": {
      "type": "object",
      "properties": {
        "all_client_chain_infos": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "name of the client chain, like \"Ethereum\"."
              },
              "meta_info": {
                "type": "string",
                "description": "meta_info about the client chain, like \"Ethereum blockchain\"."
              },
              "chain_id": {
                "type": "string",
                "format": "uint64",
                "description": "chain_id of the client chain. Not necessarily the EVM chain id."
              },
              "exocore_chain_index": {
                "type": "string",
                "format": "uint64",
                "description": "exocore_chain_index is the index of the client chain within the exosystem."
              },
              "finalization_blocks": {
                "type": "string",
                "format": "uint64",
                "description": "finalization_blocks is the number of blocks to wait for finalization."
              },
              "layer_zero_chain_id": {
                "type": "string",
                "format": "uint64",
                "title": "layer_zero_chain_id is the chain id of the client chain, according to L0.\nhttps://layerzero.gitbook.io/docs/technical-reference/mainnet/supported-chain-ids"
              },
              "signature_type": {
                "type": "string",
                "description": "signature_type is the type of signature used to sign the client chain address."
              },
              "address_length": {
                "type": "integer",
                "format": "int64",
                "description": "client_chain_addr is the length of addresses on the client chain."
              }
            },
            "description": "ClientChainInfo defines the client chain information."
          },
          "description": "all_client_chain_infos is a list of all client chain info."
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllClientChainInfoResponse is the response for all client chains info."
    },
    "exocore.assets.v1.QueryAllStakingAssetsInfoResponse": {
      "type": "object",
      "properties": {
        "all_staking_assets_info": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "asset_basic_info": {
                "description": "asset_basic_info is the basic information of the asset.",
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "name of the asset, like \"Tether USD\""
                  },
                  "symbol": {
                    "type": "string",
                    "title": "symbol of the asset, like \"USDT\""
                  },
                  "address": {
                    "type": "string",
                    "title": "address of the asset on the client chain"
                  },
                  "decimals": {
                    "type": "integer",
                    "format": "int64",
                    "description": "decimals used in the asset, typically 6 or 18."
                  },
                  "layer_zero_chain_id": {
                    "type": "string",
                    "format": "uint64",
                    "description": "layer_zero_chain_id is the chain id of the asset, according to L0."
                  },
                  "exocore_chain_index": {
                    "type": "string",
                    "format": "uint64",
                    "description": "exocore_chain_index is the index of the client chain within the exosystem."
                  },
                  "meta_info": {
                    "type": "string",
                    "description": "meta_info about the asset, like \"Tether USD on Ethereum blockchain\"."
                  }
                }
              },
              "staking_total_amount": {
                "type": "string",
                "description": "staking_total_amount is the total amount of the asset staked."
              }
            },
            "description": "StakingAssetInfo defines the information for an asset to be used in staking."
          },
          "description": "all_staking_assets_info is the response for all staking assets info."
        }
      },
      "description": "QueryAllStakingAssetsInfoResponse is the response for all staking assets info,\nindexed by the asset id."
    },
    "exocore.assets.v1.QueryAssetInfoResponse": {
      "type": "object",
      "properties": {
        "asset_infos": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "asset_id": {
                "type": "string",
                "description": "asset_id is the id of the asset."
              },
              "info": {
                "description": "info is the asset info.",
                "type": "object",
                "properties": {
                  "total_deposit_amount": {
                    "type": "string",
                    "description": "total_deposit_amount is the total amount of the asset deposited."
                  },
                  "withdrawable_amount": {
                    "type": "string",
                    "description": "withdrawable_amount is the amount that can be withdrawn."
                  },
                  "pending_undelegation_amount": {
                    "type": "string",
                    "description": "pending_undelegation_amount is the amount that is waiting for undelegation."
                  }
                }
              }
            },
            "description": "DepositByAsset is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an staker.\nThe info contains the deposit amount, the withdrawable amount\nand the amount currently unbonding.\nIt is named DepositByAsset (since it is indexed by the assetID)\nand not Deposit to prevent conflict with CrossChainOpType."
          },
          "description": "asset_infos is the response for the staker asset info, indexed by the asset id."
        }
      },
      "description": "QueryAssetInfoResponse is the response for the staker asset info."
    },
    "exocore.assets.v1.QueryOperatorAssetInfosResponse": {
      "type": "object",
      "properties": {
        "asset_infos": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "asset_id": {
                "type": "string",
                "description": "asset_id is the id of the asset."
              },
              "info": {
                "description": "info is the asset info.",
                "type": "object",
                "properties": {
                  "total_amount": {
                    "type": "string",
                    "description": "total_amount is the total amount of the asset deposited, which excludes the\npending_undelegation_amount. It represent the total delegated amount of asset pool,\nit will be used to calculate the asset amount of a specified staker from its\ndelegated share."
                  },
                  "pending_undelegation_amount": {
                    "type": "string",
                    "description": "pending_undelegation_amount is the amount that is waiting for unbonding."
                  },
                  "total_share": {
                    "type": "string",
                    "description": "total_share is the total share of an asset, in the formula to update the staker's share\nS_j = S * T_j / T, `S` represent it.\nSo when the shares of staker and operator change, it also needs to add `S_j` to update."
                  },
                  "operator_share": {
                    "type": "string",
                    "description": "operator_share is similar to the share of the staker, the calculation and update should\nbe same, the difference is that it represents the share of the operator itself.\nthe field is used to mark operator's own asset share."
                  }
                }
              }
            },
            "title": "AssetByID is a helper struct to be used in the genesis state.\nIt is used to store the asset id and its info for an operator.\nIt is named AssetByID (since it is indexed by the assetID)"
          },
          "description": "asset_infos is the response for the operator asset info, indexed by the asset id."
        }
      },
      "description": "QueryOperatorAssetInfosResponse is the response to the operator asset info query."
    },
    "exocore.assets.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters for this module.",
          "type": "object",
          "properties": {
            "exocore_lz_app_address": {
              "type": "string",
              "description": "exocore_lz_app_address is the address of ExocoreGateway.sol."
            },
            "exocore_lz_app_event_topic": {
              "type": "string",
              "description": "exocore_lz_app_event_topic is the topic of the exocore lz app event."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
    },
    "exocore.assets.v1.StakerAssetInfo": {
      "type": "object",
      "properties": {
        "total_deposit_amount": {
          "type": "string",
          "description": "total_deposit_amount is the total amount of the asset deposited."
        },
        "withdrawable_amount": {
          "type": "string",
          "description": "withdrawable_amount is the amount that can be withdrawn."
        },
        "pending_undelegation_amount": {
          "type": "string",
          "description": "pending_undelegation_amount is the amount that is waiting for undelegation."
        }
      },
      "description": "StakerAssetInfo defines the information for a single asset.\nThe type include three states:\nstaker's deposited, withdrawable, and currently unbonding amount."
    },
    "exocore.assets.v1.StakingAssetInfo": {
      "type": "object",
      "properties": {
        "asset_basic_info": {
          "description": "asset_basic_info is the basic information of the asset.",
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "name of the asset, like \"Tether USD\""
            },
            "symbol": {
              "type": "string",
              "title": "symbol of the asset, like \"USDT\""
            },
            "address": {
              "type": "string",
              "title": "address of the asset on the client chain"
            },
            "decimals": {
              "type": "integer",
              "format": "int64",
              "description": "decimals used in the asset, typically 6 or 18."
            },
            "layer_zero_chain_id": {
              "type": "string",
              "format": "uint64",
              "description": "layer_zero_chain_id is the chain id of the asset, according to L0."
            },
            "exocore_chain_index": {
              "type": "string",
              "format": "uint64",
              "description": "exocore_chain_index is the index of the client chain within the exosystem."
            },
            "meta_info": {
              "type": "string",
              "description": "meta_info about the asset, like \"Tether USD on Ethereum blockchain\"."
            }
          }
        },
        "staking_total_amount": {
          "type": "string",
          "description": "staking_total_amount is the total amount of the asset staked."
        }
      },
      "description": "StakingAssetInfo defines the information for an asset to be used in staking."
    },
    "exocore.slash.v1.Params": {
      "type": "object",
      "description": "Params defines the parameters for the module."
    },
    "exocore.slash.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object"
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "exocore.oracle.v1.Action": {
      "type": "string",
      "enum": [
        "ACTION_ROUND_UNSPECIFIED",
        "ACTION_DEPOSIT",
        "ACTION_WITHDRAW",
        "ACTION_SLASH_REFUND"
      ],
      "default": "ACTION_ROUND_UNSPECIFIED",
      "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened",
      "title": "Action defines the reason the balance changed"
    },
    "exocore.oracle.v1.BalanceInfo": {
      "type": "object",
      "properties": {
        "round_id": {
          "type": "string",
          "format": "uint64",
          "title": "current round of price, this is updated based on tokenFeeder"
        },
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
        },
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "index used to distinguish multiple balanceInfo for one same roundid"
        },
        "balance": {
          "type": "string",
          "format": "int64",
          "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
        },
        "change": {
          "title": "change tells the reason balance changed",
          "type": "string",
          "enum": [
            "ACTION_ROUND_UNSPECIFIED",
            "ACTION_DEPOSIT",
            "ACTION_WITHDRAW",
            "ACTION_SLASH_REFUND"
          ],
          "default": "ACTION_ROUND_UNSPECIFIED",
          "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
        }
      },
      "title": "BalanceInfo tells effective-balance for native-restaking asset"
    },
    "exocore.oracle.v1.Chain": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "eg.\"bitcoin\""
        },
        "desc": {
          "type": "string",
          "title": "TODO: metadata"
        }
      },
      "title": "Chain represents for the Chain on which token contracts deployed"
    },
    "exocore.oracle.v1.ConsensusMode": {
      "type": "string",
      "enum": [
        "CONSENSUS_MODE_UNSPECIFIED",
        "CONSENSUS_MODE_ASAP"
      ],
      "default": "CONSENSUS_MODE_UNSPECIFIED",
      "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
    },
    "exocore.oracle.v1.Endpoint": {
      "type": "object",
      "properties": {
        "offchain": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
        },
        "onchain": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
        }
      },
      "title": "Endpoint tells where to fetch the price info"
    },
    "exocore.oracle.v1.IndexRecentMsg": {
      "type": "object",
      "properties": {
        "index": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "index list"
        }
      },
      "title": "index for the cached recent messages"
    },
    "exocore.oracle.v1.IndexRecentParams": {
      "type": "object",
      "properties": {
        "index": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "index list"
        }
      },
      "title": "index for the cached recent params"
    },
    "exocore.oracle.v1.MsgItem": {
      "type": "object",
      "properties": {
        "feeder_id": {
          "type": "string",
          "format": "uint64",
          "title": "feeder_id tells of wich feeder this price if corresponding to"
        },
        "p_sources": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "source_id": {
                "type": "string",
                "format": "uint64",
                "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
              },
              "prices": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "price": {
                      "type": "string",
                      "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                    },
                    "decimal": {
                      "type": "integer",
                      "format": "int32",
                      "title": "decimal of the corresponding price"
                    },
                    "timestamp": {
                      "type": "string",
                      "title": "timestamp when the price corresponding to"
                    },
                    "det_id": {
                      "type": "string",
                      "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                    }
                  },
                  "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                },
                "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
              },
              "desc": {
                "type": "string",
                "title": "used for 0-sourceID-customDefinedSource"
              }
            },
            "title": "price with its corresponding source"
          },
          "title": "p_source price with its source info"
        },
        "validator": {
          "type": "string",
          "title": "validator tells which validator create this price"
        }
      },
      "title": "MsgItem represents the message info of createPrice"
    },
    "exocore.oracle.v1.NOMSource": {
      "type": "object",
      "properties": {
        "source_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
        },
        "minimum": {
          "type": "string",
          "format": "uint64",
          "title": "minimum number from the required sources to be fullfiled"
        }
      },
      "title": "n out of m required source"
    },
    "exocore.oracle.v1.Params": {
      "type": "object",
      "properties": {
        "chains": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "eg.\"bitcoin\""
              },
              "desc": {
                "type": "string",
                "title": "TODO: metadata"
              }
            },
            "title": "Chain represents for the Chain on which token contracts deployed"
          },
          "title": "chains represents the blockchains info"
        },
        "tokens": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "token name"
              },
              "chain_id": {
                "type": "string",
                "format": "uint64",
                "title": "id refer to chainList's index"
              },
              "contract_address": {
                "type": "string",
                "title": "if any, like erc20 tokens"
              },
              "decimal": {
                "type": "integer",
                "format": "int32",
                "title": "decimal of token price"
              },
              "active": {
                "type": "boolean",
                "title": "set false when we stop official price oracle service for a specified token"
              },
              "asset_id": {
                "type": "string",
                "title": "refer to assetID from assets module if exists"
              }
            },
            "title": "Token represents the token info"
          },
          "title": "tokens info"
        },
        "sources": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name of price source, like 'chainlink'"
              },
              "entry": {
                "title": "endpoint of corresponding source to fetch price data from",
                "type": "object",
                "properties": {
                  "offchain": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    },
                    "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                  },
                  "onchain": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    },
                    "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                  }
                }
              },
              "valid": {
                "type": "boolean",
                "title": "set false when the source is out of service or reject to accept this source for official service"
              },
              "deterministic": {
                "type": "boolean",
                "title": "if this source is deteministic or not"
              }
            },
            "title": "Source represents price data source"
          },
          "title": "sources info from where the price data would be fetched"
        },
        "rules": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "source_ids": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uint64"
                },
                "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
              },
              "nom": {
                "title": "n out of total sources are required",
                "type": "object",
                "properties": {
                  "source_ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                  },
                  "minimum": {
                    "type": "string",
                    "format": "uint64",
                    "title": "minimum number from the required sources to be fullfiled"
                  }
                }
              }
            },
            "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
          },
          "title": "rules specified on how to decide the provided price source to be accept"
        },
        "token_feeders": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "token_id": {
                "type": "string",
                "format": "uint64",
                "title": "refer to params.tokenList, from 1"
              },
              "rule_id": {
                "type": "string",
                "format": "uint64",
                "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
              },
              "start_round_id": {
                "type": "string",
                "format": "uint64",
                "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
              },
              "start_base_block": {
                "type": "string",
                "format": "uint64",
                "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
              },
              "interval": {
                "type": "string",
                "format": "uint64",
                "title": "set as count of blocks, for how many blocks interval the price will be update once"
              },
              "end_block": {
                "type": "string",
                "format": "uint64",
                "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
              }
            },
            "title": "Tokenfeeder represents a price oracle for one token"
          },
          "title": "each tokenFeeder represents an active token whose price being updated"
        },
        "max_nonce": {
          "type": "integer",
          "format": "int32",
          "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
        },
        "threshold_a": {
          "type": "integer",
          "format": "int32",
          "title": "voting power need to reach more than threshold_a/threshold_b"
        },
        "threshold_b": {
          "type": "integer",
          "format": "int32",
          "title": "voting power need to reach more than threshold_a/threshold_b"
        },
        "mode": {
          "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
          "type": "string",
          "enum": [
            "CONSENSUS_MODE_UNSPECIFIED",
            "CONSENSUS_MODE_ASAP"
          ],
          "default": "CONSENSUS_MODE_UNSPECIFIED",
          "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
        },
        "max_det_id": {
          "type": "integer",
          "format": "int32",
          "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
        },
        "max_size_prices": {
          "type": "integer",
          "format": "int32",
          "title": "for each token, only keep max_size_prices round of prices"
        },
        "slashing": {
          "title": "slashing defines the slashing related params",
          "type": "object",
          "properties": {
            "reported_rounds_window": {
              "type": "string",
              "format": "int64",
              "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
            },
            "min_reported_per_window": {
              "type": "string",
              "format": "byte",
              "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
            },
            "oracle_miss_jail_duration": {
              "type": "string",
              "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
            },
            "oracle_malicious_jail_duration": {
              "type": "string",
              "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
            },
            "slash_fraction_miss": {
              "type": "string",
              "format": "byte",
              "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
            },
            "slash_fraction_malicious": {
              "type": "string",
              "format": "byte",
              "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
            }
          }
        }
      },
      "description": "Params defines the parameters for the module."
    },
    "exocore.oracle.v1.PriceSource": {
      "type": "object",
      "properties": {
        "source_id": {
          "type": "string",
          "format": "uint64",
          "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
        },
        "prices": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "price": {
                "type": "string",
                "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
              },
              "decimal": {
                "type": "integer",
                "format": "int32",
                "title": "decimal of the corresponding price"
              },
              "timestamp": {
                "type": "string",
                "title": "timestamp when the price corresponding to"
              },
              "det_id": {
                "type": "string",
                "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
              }
            },
            "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
          },
          "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
        },
        "desc": {
          "type": "string",
          "title": "used for 0-sourceID-customDefinedSource"
        }
      },
      "title": "price with its corresponding source"
    },
    "exocore.oracle.v1.PriceTimeDetID": {
      "type": "object",
      "properties": {
        "price": {
          "type": "string",
          "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
        },
        "decimal": {
          "type": "integer",
          "format": "int32",
          "title": "decimal of the corresponding price"
        },
        "timestamp": {
          "type": "string",
          "title": "timestamp when the price corresponding to"
        },
        "det_id": {
          "type": "string",
          "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
        }
      },
      "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
    },
    "exocore.oracle.v1.PriceTimeRound": {
      "type": "object",
      "properties": {
        "price": {
          "type": "string",
          "title": "price"
        },
        "decimal": {
          "type": "integer",
          "format": "int32",
          "title": "decimal of the corresponding price"
        },
        "timestamp": {
          "type": "string",
          "title": "timestamp when the price is corresponded"
        },
        "round_id": {
          "type": "string",
          "format": "uint64",
          "title": "roundid of the price if the source is deteministic"
        }
      },
      "title": "price with its specified timestamp and roundid(if from deteministic source)"
    },
    "exocore.oracle.v1.Prices": {
      "type": "object",
      "properties": {
        "token_id": {
          "type": "string",
          "format": "uint64",
          "title": "for which token these prices are"
        },
        "next_round_id": {
          "type": "string",
          "format": "uint64",
          "title": "next round id of the price to be updated"
        },
        "price_list": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "price": {
                "type": "string",
                "title": "price"
              },
              "decimal": {
                "type": "integer",
                "format": "int32",
                "title": "decimal of the corresponding price"
              },
              "timestamp": {
                "type": "string",
                "title": "timestamp when the price is corresponded"
              },
              "round_id": {
                "type": "string",
                "format": "uint64",
                "title": "roundid of the price if the source is deteministic"
              }
            },
            "title": "price with its specified timestamp and roundid(if from deteministic source)"
          },
          "title": "price list of all history round prices for the token"
        }
      },
      "title": "prices of all rounds of a specific token"
    },
    "exocore.oracle.v1.QueryAllRecentMsgResponse": {
      "type": "object",
      "properties": {
        "recent_msg": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "block": {
                "type": "string",
                "format": "uint64",
                "title": "block height these messages from"
              },
              "msgs": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "feeder_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "feeder_id tells of wich feeder this price if corresponding to"
                    },
                    "p_sources": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "source_id": {
                            "type": "string",
                            "format": "uint64",
                            "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
                          },
                          "prices": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "price": {
                                  "type": "string",
                                  "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                                },
                                "decimal": {
                                  "type": "integer",
                                  "format": "int32",
                                  "title": "decimal of the corresponding price"
                                },
                                "timestamp": {
                                  "type": "string",
                                  "title": "timestamp when the price corresponding to"
                                },
                                "det_id": {
                                  "type": "string",
                                  "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                                }
                              },
                              "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                            },
                            "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
                          },
                          "desc": {
                            "type": "string",
                            "title": "used for 0-sourceID-customDefinedSource"
                          }
                        },
                        "title": "price with its corresponding source"
                      },
                      "title": "p_source price with its source info"
                    },
                    "validator": {
                      "type": "string",
                      "title": "validator tells which validator create this price"
                    }
                  },
                  "title": "MsgItem represents the message info of createPrice"
                },
                "title": "cached messages"
              }
            },
            "title": "RecentMsg represent the messages to be cached for recent blocks"
          },
          "title": "recent_msg represets the cached recent message"
        },
        "pagination": {
          "title": "info of pagination",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryAllRecentMsgResponse"
    },
    "exocore.oracle.v1.QueryAllRecentParamsResponse": {
      "type": "object",
      "properties": {
        "recent_params": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "block": {
                "type": "string",
                "format": "uint64",
                "title": "block height of which the params from"
              },
              "params": {
                "title": "params the module params",
                "type": "object",
                "properties": {
                  "chains": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "title": "eg.\"bitcoin\""
                        },
                        "desc": {
                          "type": "string",
                          "title": "TODO: metadata"
                        }
                      },
                      "title": "Chain represents for the Chain on which token contracts deployed"
                    },
                    "title": "chains represents the blockchains info"
                  },
                  "tokens": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "title": "token name"
                        },
                        "chain_id": {
                          "type": "string",
                          "format": "uint64",
                          "title": "id refer to chainList's index"
                        },
                        "contract_address": {
                          "type": "string",
                          "title": "if any, like erc20 tokens"
                        },
                        "decimal": {
                          "type": "integer",
                          "format": "int32",
                          "title": "decimal of token price"
                        },
                        "active": {
                          "type": "boolean",
                          "title": "set false when we stop official price oracle service for a specified token"
                        },
                        "asset_id": {
                          "type": "string",
                          "title": "refer to assetID from assets module if exists"
                        }
                      },
                      "title": "Token represents the token info"
                    },
                    "title": "tokens info"
                  },
                  "sources": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string",
                          "title": "name of price source, like 'chainlink'"
                        },
                        "entry": {
                          "title": "endpoint of corresponding source to fetch price data from",
                          "type": "object",
                          "properties": {
                            "offchain": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              },
                              "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                            },
                            "onchain": {
                              "type": "object",
                              "additionalProperties": {
                                "type": "string"
                              },
                              "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                            }
                          }
                        },
                        "valid": {
                          "type": "boolean",
                          "title": "set false when the source is out of service or reject to accept this source for official service"
                        },
                        "deterministic": {
                          "type": "boolean",
                          "title": "if this source is deteministic or not"
                        }
                      },
                      "title": "Source represents price data source"
                    },
                    "title": "sources info from where the price data would be fetched"
                  },
                  "rules": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "source_ids": {
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "uint64"
                          },
                          "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                        },
                        "nom": {
                          "title": "n out of total sources are required",
                          "type": "object",
                          "properties": {
                            "source_ids": {
                              "type": "array",
                              "items": {
                                "type": "string",
                                "format": "uint64"
                              },
                              "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                            },
                            "minimum": {
                              "type": "string",
                              "format": "uint64",
                              "title": "minimum number from the required sources to be fullfiled"
                            }
                          }
                        }
                      },
                      "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
                    },
                    "title": "rules specified on how to decide the provided price source to be accept"
                  },
                  "token_feeders": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "token_id": {
                          "type": "string",
                          "format": "uint64",
                          "title": "refer to params.tokenList, from 1"
                        },
                        "rule_id": {
                          "type": "string",
                          "format": "uint64",
                          "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                        },
                        "start_round_id": {
                          "type": "string",
                          "format": "uint64",
                          "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                        },
                        "start_base_block": {
                          "type": "string",
                          "format": "uint64",
                          "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                        },
                        "interval": {
                          "type": "string",
                          "format": "uint64",
                          "title": "set as count of blocks, for how many blocks interval the price will be update once"
                        },
                        "end_block": {
                          "type": "string",
                          "format": "uint64",
                          "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                        }
                      },
                      "title": "Tokenfeeder represents a price oracle for one token"
                    },
                    "title": "each tokenFeeder represents an active token whose price being updated"
                  },
                  "max_nonce": {
                    "type": "integer",
                    "format": "int32",
                    "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
                  },
                  "threshold_a": {
                    "type": "integer",
                    "format": "int32",
                    "title": "voting power need to reach more than threshold_a/threshold_b"
                  },
                  "threshold_b": {
                    "type": "integer",
                    "format": "int32",
                    "title": "voting power need to reach more than threshold_a/threshold_b"
                  },
                  "mode": {
                    "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
                    "type": "string",
                    "enum": [
                      "CONSENSUS_MODE_UNSPECIFIED",
                      "CONSENSUS_MODE_ASAP"
                    ],
                    "default": "CONSENSUS_MODE_UNSPECIFIED",
                    "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
                  },
                  "max_det_id": {
                    "type": "integer",
                    "format": "int32",
                    "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
                  },
                  "max_size_prices": {
                    "type": "integer",
                    "format": "int32",
                    "title": "for each token, only keep max_size_prices round of prices"
                  },
                  "slashing": {
                    "title": "slashing defines the slashing related params",
                    "type": "object",
                    "properties": {
                      "reported_rounds_window": {
                        "type": "string",
                        "format": "int64",
                        "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                      },
                      "min_reported_per_window": {
                        "type": "string",
                        "format": "byte",
                        "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                      },
                      "oracle_miss_jail_duration": {
                        "type": "string",
                        "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                      },
                      "oracle_malicious_jail_duration": {
                        "type": "string",
                        "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                      },
                      "slash_fraction_miss": {
                        "type": "string",
                        "format": "byte",
                        "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                      },
                      "slash_fraction_malicious": {
                        "type": "string",
                        "format": "byte",
                        "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                      }
                    }
                  }
                },
                "description": "Params defines the parameters for the module."
              }
            },
            "title": "RecentParams represents the params cached for recent blocks"
          },
          "title": "recent_params cached recent params"
        },
        "pagination": {
          "title": "info of pagination",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          },
          "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
        }
      },
      "title": "QueryAllRecentParamsResponse"
    },
    "exocore.oracle.v1.QueryGetIndexRecentMsgResponse": {
      "type": "object",
      "properties": {
        "index_recent_msg": {
          "title": "index_recent_msg index of cached recent messages",
          "type": "object",
          "properties": {
            "index": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              },
              "title": "index list"
            }
          }
        }
      },
      "title": "QueryIndexRecentMsgResponse"
    },
    "exocore.oracle.v1.QueryGetIndexRecentParamsResponse": {
      "type": "object",
      "properties": {
        "index_recent_params": {
          "title": "index_recent_params index of cached recent params",
          "type": "object",
          "properties": {
            "index": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              },
              "title": "index list"
            }
          }
        }
      },
      "title": "QueryGetIndexRecentParamsResponse"
    },
    "exocore.oracle.v1.QueryGetLatestPriceResponse": {
      "type": "object",
      "properties": {
        "price": {
          "title": "prices returned prices",
          "type": "object",
          "properties": {
            "price": {
              "type": "string",
              "title": "price"
            },
            "decimal": {
              "type": "integer",
              "format": "int32",
              "title": "decimal of the corresponding price"
            },
            "timestamp": {
              "type": "string",
              "title": "timestamp when the price is corresponded"
            },
            "round_id": {
              "type": "string",
              "format": "uint64",
              "title": "roundid of the price if the source is deteministic"
            }
          }
        }
      },
      "title": "QueryGetLatestPriceResponse"
    },
    "exocore.oracle.v1.QueryGetPricesResponse": {
      "type": "object",
      "properties": {
        "prices": {
          "title": "prices returned prices",
          "type": "object",
          "properties": {
            "token_id": {
              "type": "string",
              "format": "uint64",
              "title": "for which token these prices are"
            },
            "next_round_id": {
              "type": "string",
              "format": "uint64",
              "title": "next round id of the price to be updated"
            },
            "price_list": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "price": {
                    "type": "string",
                    "title": "price"
                  },
                  "decimal": {
                    "type": "integer",
                    "format": "int32",
                    "title": "decimal of the corresponding price"
                  },
                  "timestamp": {
                    "type": "string",
                    "title": "timestamp when the price is corresponded"
                  },
                  "round_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "roundid of the price if the source is deteministic"
                  }
                },
                "title": "price with its specified timestamp and roundid(if from deteministic source)"
              },
              "title": "price list of all history round prices for the token"
            }
          }
        }
      },
      "title": "QueryGetPricesResponse"
    },
    "exocore.oracle.v1.QueryGetRecentMsgResponse": {
      "type": "object",
      "properties": {
        "recent_msg": {
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64",
              "title": "block height these messages from"
            },
            "msgs": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "feeder_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "feeder_id tells of wich feeder this price if corresponding to"
                  },
                  "p_sources": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "source_id": {
                          "type": "string",
                          "format": "uint64",
                          "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
                        },
                        "prices": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "price": {
                                "type": "string",
                                "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                              },
                              "decimal": {
                                "type": "integer",
                                "format": "int32",
                                "title": "decimal of the corresponding price"
                              },
                              "timestamp": {
                                "type": "string",
                                "title": "timestamp when the price corresponding to"
                              },
                              "det_id": {
                                "type": "string",
                                "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                              }
                            },
                            "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                          },
                          "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
                        },
                        "desc": {
                          "type": "string",
                          "title": "used for 0-sourceID-customDefinedSource"
                        }
                      },
                      "title": "price with its corresponding source"
                    },
                    "title": "p_source price with its source info"
                  },
                  "validator": {
                    "type": "string",
                    "title": "validator tells which validator create this price"
                  }
                },
                "title": "MsgItem represents the message info of createPrice"
              },
              "title": "cached messages"
            }
          },
          "title": "RecentMsg represent the messages to be cached for recent blocks"
        }
      },
      "title": "QueryGetRecentMsgResponse"
    },
    "exocore.oracle.v1.QueryGetRecentParamsResponse": {
      "type": "object",
      "properties": {
        "recent_params": {
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64",
              "title": "block height of which the params from"
            },
            "params": {
              "title": "params the module params",
              "type": "object",
              "properties": {
                "chains": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "title": "eg.\"bitcoin\""
                      },
                      "desc": {
                        "type": "string",
                        "title": "TODO: metadata"
                      }
                    },
                    "title": "Chain represents for the Chain on which token contracts deployed"
                  },
                  "title": "chains represents the blockchains info"
                },
                "tokens": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "title": "token name"
                      },
                      "chain_id": {
                        "type": "string",
                        "format": "uint64",
                        "title": "id refer to chainList's index"
                      },
                      "contract_address": {
                        "type": "string",
                        "title": "if any, like erc20 tokens"
                      },
                      "decimal": {
                        "type": "integer",
                        "format": "int32",
                        "title": "decimal of token price"
                      },
                      "active": {
                        "type": "boolean",
                        "title": "set false when we stop official price oracle service for a specified token"
                      },
                      "asset_id": {
                        "type": "string",
                        "title": "refer to assetID from assets module if exists"
                      }
                    },
                    "title": "Token represents the token info"
                  },
                  "title": "tokens info"
                },
                "sources": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "name": {
                        "type": "string",
                        "title": "name of price source, like 'chainlink'"
                      },
                      "entry": {
                        "title": "endpoint of corresponding source to fetch price data from",
                        "type": "object",
                        "properties": {
                          "offchain": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            },
                            "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                          },
                          "onchain": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            },
                            "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                          }
                        }
                      },
                      "valid": {
                        "type": "boolean",
                        "title": "set false when the source is out of service or reject to accept this source for official service"
                      },
                      "deterministic": {
                        "type": "boolean",
                        "title": "if this source is deteministic or not"
                      }
                    },
                    "title": "Source represents price data source"
                  },
                  "title": "sources info from where the price data would be fetched"
                },
                "rules": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "source_ids": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                      },
                      "nom": {
                        "title": "n out of total sources are required",
                        "type": "object",
                        "properties": {
                          "source_ids": {
                            "type": "array",
                            "items": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                          },
                          "minimum": {
                            "type": "string",
                            "format": "uint64",
                            "title": "minimum number from the required sources to be fullfiled"
                          }
                        }
                      }
                    },
                    "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
                  },
                  "title": "rules specified on how to decide the provided price source to be accept"
                },
                "token_feeders": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "token_id": {
                        "type": "string",
                        "format": "uint64",
                        "title": "refer to params.tokenList, from 1"
                      },
                      "rule_id": {
                        "type": "string",
                        "format": "uint64",
                        "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                      },
                      "start_round_id": {
                        "type": "string",
                        "format": "uint64",
                        "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                      },
                      "start_base_block": {
                        "type": "string",
                        "format": "uint64",
                        "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                      },
                      "interval": {
                        "type": "string",
                        "format": "uint64",
                        "title": "set as count of blocks, for how many blocks interval the price will be update once"
                      },
                      "end_block": {
                        "type": "string",
                        "format": "uint64",
                        "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                      }
                    },
                    "title": "Tokenfeeder represents a price oracle for one token"
                  },
                  "title": "each tokenFeeder represents an active token whose price being updated"
                },
                "max_nonce": {
                  "type": "integer",
                  "format": "int32",
                  "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
                },
                "threshold_a": {
                  "type": "integer",
                  "format": "int32",
                  "title": "voting power need to reach more than threshold_a/threshold_b"
                },
                "threshold_b": {
                  "type": "integer",
                  "format": "int32",
                  "title": "voting power need to reach more than threshold_a/threshold_b"
                },
                "mode": {
                  "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
                  "type": "string",
                  "enum": [
                    "CONSENSUS_MODE_UNSPECIFIED",
                    "CONSENSUS_MODE_ASAP"
                  ],
                  "default": "CONSENSUS_MODE_UNSPECIFIED",
                  "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
                },
                "max_det_id": {
                  "type": "integer",
                  "format": "int32",
                  "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
                },
                "max_size_prices": {
                  "type": "integer",
                  "format": "int32",
                  "title": "for each token, only keep max_size_prices round of prices"
                },
                "slashing": {
                  "title": "slashing defines the slashing related params",
                  "type": "object",
                  "properties": {
                    "reported_rounds_window": {
                      "type": "string",
                      "format": "int64",
                      "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                    },
                    "min_reported_per_window": {
                      "type": "string",
                      "format": "byte",
                      "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                    },
                    "oracle_miss_jail_duration": {
                      "type": "string",
                      "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                    },
                    "oracle_malicious_jail_duration": {
                      "type": "string",
                      "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                    },
                    "slash_fraction_miss": {
                      "type": "string",
                      "format": "byte",
                      "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                    },
                    "slash_fraction_malicious": {
                      "type": "string",
                      "format": "byte",
                      "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                    }
                  }
                }
              },
              "description": "Params defines the parameters for the module."
            }
          },
          "title": "RecentParams represents the params cached for recent blocks"
        }
      },
      "title": "QueryGetRecentParamsResponse"
    },
    "exocore.oracle.v1.QueryGetValidatorUpdateBlockResponse": {
      "type": "object",
      "properties": {
        "validator_update_block": {
          "title": "ValidatorUpdateBlock tells the latest block on which the valdiator set was updated",
          "type": "object",
          "properties": {
            "block": {
              "type": "string",
              "format": "uint64",
              "title": "block height on which the validator set changed"
            }
          }
        }
      },
      "title": "QueryGetValidatorUpdateBlockResponse"
    },
    "exocore.oracle.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "chains": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "eg.\"bitcoin\""
                  },
                  "desc": {
                    "type": "string",
                    "title": "TODO: metadata"
                  }
                },
                "title": "Chain represents for the Chain on which token contracts deployed"
              },
              "title": "chains represents the blockchains info"
            },
            "tokens": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "token name"
                  },
                  "chain_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "id refer to chainList's index"
                  },
                  "contract_address": {
                    "type": "string",
                    "title": "if any, like erc20 tokens"
                  },
                  "decimal": {
                    "type": "integer",
                    "format": "int32",
                    "title": "decimal of token price"
                  },
                  "active": {
                    "type": "boolean",
                    "title": "set false when we stop official price oracle service for a specified token"
                  },
                  "asset_id": {
                    "type": "string",
                    "title": "refer to assetID from assets module if exists"
                  }
                },
                "title": "Token represents the token info"
              },
              "title": "tokens info"
            },
            "sources": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "name of price source, like 'chainlink'"
                  },
                  "entry": {
                    "title": "endpoint of corresponding source to fetch price data from",
                    "type": "object",
                    "properties": {
                      "offchain": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        },
                        "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                      },
                      "onchain": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        },
                        "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                      }
                    }
                  },
                  "valid": {
                    "type": "boolean",
                    "title": "set false when the source is out of service or reject to accept this source for official service"
                  },
                  "deterministic": {
                    "type": "boolean",
                    "title": "if this source is deteministic or not"
                  }
                },
                "title": "Source represents price data source"
              },
              "title": "sources info from where the price data would be fetched"
            },
            "rules": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "source_ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                  },
                  "nom": {
                    "title": "n out of total sources are required",
                    "type": "object",
                    "properties": {
                      "source_ids": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                      },
                      "minimum": {
                        "type": "string",
                        "format": "uint64",
                        "title": "minimum number from the required sources to be fullfiled"
                      }
                    }
                  }
                },
                "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
              },
              "title": "rules specified on how to decide the provided price source to be accept"
            },
            "token_feeders": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "token_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "refer to params.tokenList, from 1"
                  },
                  "rule_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                  },
                  "start_round_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                  },
                  "start_base_block": {
                    "type": "string",
                    "format": "uint64",
                    "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                  },
                  "interval": {
                    "type": "string",
                    "format": "uint64",
                    "title": "set as count of blocks, for how many blocks interval the price will be update once"
                  },
                  "end_block": {
                    "type": "string",
                    "format": "uint64",
                    "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                  }
                },
                "title": "Tokenfeeder represents a price oracle for one token"
              },
              "title": "each tokenFeeder represents an active token whose price being updated"
            },
            "max_nonce": {
              "type": "integer",
              "format": "int32",
              "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
            },
            "threshold_a": {
              "type": "integer",
              "format": "int32",
              "title": "voting power need to reach more than threshold_a/threshold_b"
            },
            "threshold_b": {
              "type": "integer",
              "format": "int32",
              "title": "voting power need to reach more than threshold_a/threshold_b"
            },
            "mode": {
              "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
              "type": "string",
              "enum": [
                "CONSENSUS_MODE_UNSPECIFIED",
                "CONSENSUS_MODE_ASAP"
              ],
              "default": "CONSENSUS_MODE_UNSPECIFIED",
              "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
            },
            "max_det_id": {
              "type": "integer",
              "format": "int32",
              "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
            },
            "max_size_prices": {
              "type": "integer",
              "format": "int32",
              "title": "for each token, only keep max_size_prices round of prices"
            },
            "slashing": {
              "title": "slashing defines the slashing related params",
              "type": "object",
              "properties": {
                "reported_rounds_window": {
                  "type": "string",
                  "format": "int64",
                  "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                },
                "min_reported_per_window": {
                  "type": "string",
                  "format": "byte",
                  "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                },
                "oracle_miss_jail_duration": {
                  "type": "string",
                  "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                },
                "oracle_malicious_jail_duration": {
                  "type": "string",
                  "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                },
                "slash_fraction_miss": {
                  "type": "string",
                  "format": "byte",
                  "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                },
                "slash_fraction_malicious": {
                  "type": "string",
                  "format": "byte",
                  "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                }
              }
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "exocore.oracle.v1.QueryStakerInfoResponse": {
      "type": "object",
      "properties": {
        "staker_info": {
          "title": "all staker infos under the specified asset",
          "type": "object",
          "properties": {
            "staker_addr": {
              "type": "string",
              "title": "staker's address"
            },
            "staker_index": {
              "type": "string",
              "format": "int64",
              "title": "the index of corresponding staker in staker list"
            },
            "validator_pubkey_list": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "list of validators that this staker corresponding to on beacon chain"
            },
            "balance_list": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "round_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "current round of price, this is updated based on tokenFeeder"
                  },
                  "block": {
                    "type": "string",
                    "format": "uint64",
                    "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
                  },
                  "index": {
                    "type": "string",
                    "format": "uint64",
                    "title": "index used to distinguish multiple balanceInfo for one same roundid"
                  },
                  "balance": {
                    "type": "string",
                    "format": "int64",
                    "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
                  },
                  "change": {
                    "title": "change tells the reason balance changed",
                    "type": "string",
                    "enum": [
                      "ACTION_ROUND_UNSPECIFIED",
                      "ACTION_DEPOSIT",
                      "ACTION_WITHDRAW",
                      "ACTION_SLASH_REFUND"
                    ],
                    "default": "ACTION_ROUND_UNSPECIFIED",
                    "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
                  }
                },
                "title": "BalanceInfo tells effective-balance for native-restaking asset"
              },
              "title": "list of balances to represets the history of this staker"
            }
          }
        }
      },
      "title": "QueryStakerInfoResponse is response type for Query/StakerInfo RCP method"
    },
    "exocore.oracle.v1.QueryStakerInfosResponse": {
      "type": "object",
      "properties": {
        "staker_infos": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "staker_addr": {
                "type": "string",
                "title": "staker's address"
              },
              "staker_index": {
                "type": "string",
                "format": "int64",
                "title": "the index of corresponding staker in staker list"
              },
              "validator_pubkey_list": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "title": "list of validators that this staker corresponding to on beacon chain"
              },
              "balance_list": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "round_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "current round of price, this is updated based on tokenFeeder"
                    },
                    "block": {
                      "type": "string",
                      "format": "uint64",
                      "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
                    },
                    "index": {
                      "type": "string",
                      "format": "uint64",
                      "title": "index used to distinguish multiple balanceInfo for one same roundid"
                    },
                    "balance": {
                      "type": "string",
                      "format": "int64",
                      "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
                    },
                    "change": {
                      "title": "change tells the reason balance changed",
                      "type": "string",
                      "enum": [
                        "ACTION_ROUND_UNSPECIFIED",
                        "ACTION_DEPOSIT",
                        "ACTION_WITHDRAW",
                        "ACTION_SLASH_REFUND"
                      ],
                      "default": "ACTION_ROUND_UNSPECIFIED",
                      "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
                    }
                  },
                  "title": "BalanceInfo tells effective-balance for native-restaking asset"
                },
                "title": "list of balances to represets the history of this staker"
              }
            },
            "title": "StakerInfo represents all related information for a staker of native-restaking"
          },
          "title": "all staker infos under the specified asset"
        }
      },
      "title": "QueryStakerInfosResponse is response type for Query/StakerInfo RCP method"
    },
    "exocore.oracle.v1.QueryStakerListResponse": {
      "type": "object",
      "properties": {
        "staker_list": {
          "title": "staker list including all stakers of request asset",
          "type": "object",
          "properties": {
            "staker_addrs": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "staker's address"
            }
          }
        }
      },
      "title": "QueryStakerListResponse is response type for Query/StakerList RPC method"
    },
    "exocore.oracle.v1.QueryTokenIndexesResponse": {
      "type": "object",
      "properties": {
        "token_indexes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "token": {
                "type": "string",
                "title": "token name"
              },
              "index": {
                "type": "string",
                "format": "uint64",
                "title": "the index registered in params.Token"
              }
            },
            "title": "TokenIndex is the pair of tokenName and its index defined in params"
          },
          "title": "token_indexes includes all the token-index mapping"
        }
      },
      "title": "QueryTokenIndexesResponse is response type for Query/TokenIndexes RPC method"
    },
    "exocore.oracle.v1.RecentMsg": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "block height these messages from"
        },
        "msgs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "feeder_id": {
                "type": "string",
                "format": "uint64",
                "title": "feeder_id tells of wich feeder this price if corresponding to"
              },
              "p_sources": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "source_id": {
                      "type": "string",
                      "format": "uint64",
                      "title": "source_id refers to id from Params.SourceList, where this price fetched from, 0 is reserved for custom usage"
                    },
                    "prices": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "price": {
                            "type": "string",
                            "title": "price at a specific point(timestamp of non-deterministic source, roundId of deteministic source)"
                          },
                          "decimal": {
                            "type": "integer",
                            "format": "int32",
                            "title": "decimal of the corresponding price"
                          },
                          "timestamp": {
                            "type": "string",
                            "title": "timestamp when the price corresponding to"
                          },
                          "det_id": {
                            "type": "string",
                            "title": "det_id is used for deterministic source to tell of which round from this source the price is corresponded"
                          }
                        },
                        "title": "token price with timestamp fetched from source\n{price:\"12345\",decimal:\"2\"}->price: 123.45 usdt"
                      },
                      "description": "if source is deteministic like chainlink with roundID, set this value with which returned from source\nup to 3 values in case of the async of network, to give more time for oracle nodes(validators) get into consensus\neg.with deterministic source, this array will contian 3 continuous values up to latest\nfor non-deterministic source, it's a choice by v2 rules."
                    },
                    "desc": {
                      "type": "string",
                      "title": "used for 0-sourceID-customDefinedSource"
                    }
                  },
                  "title": "price with its corresponding source"
                },
                "title": "p_source price with its source info"
              },
              "validator": {
                "type": "string",
                "title": "validator tells which validator create this price"
              }
            },
            "title": "MsgItem represents the message info of createPrice"
          },
          "title": "cached messages"
        }
      },
      "title": "RecentMsg represent the messages to be cached for recent blocks"
    },
    "exocore.oracle.v1.RecentParams": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "block height of which the params from"
        },
        "params": {
          "title": "params the module params",
          "type": "object",
          "properties": {
            "chains": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "eg.\"bitcoin\""
                  },
                  "desc": {
                    "type": "string",
                    "title": "TODO: metadata"
                  }
                },
                "title": "Chain represents for the Chain on which token contracts deployed"
              },
              "title": "chains represents the blockchains info"
            },
            "tokens": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "token name"
                  },
                  "chain_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "id refer to chainList's index"
                  },
                  "contract_address": {
                    "type": "string",
                    "title": "if any, like erc20 tokens"
                  },
                  "decimal": {
                    "type": "integer",
                    "format": "int32",
                    "title": "decimal of token price"
                  },
                  "active": {
                    "type": "boolean",
                    "title": "set false when we stop official price oracle service for a specified token"
                  },
                  "asset_id": {
                    "type": "string",
                    "title": "refer to assetID from assets module if exists"
                  }
                },
                "title": "Token represents the token info"
              },
              "title": "tokens info"
            },
            "sources": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "title": "name of price source, like 'chainlink'"
                  },
                  "entry": {
                    "title": "endpoint of corresponding source to fetch price data from",
                    "type": "object",
                    "properties": {
                      "offchain": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        },
                        "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
                      },
                      "onchain": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        },
                        "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
                      }
                    }
                  },
                  "valid": {
                    "type": "boolean",
                    "title": "set false when the source is out of service or reject to accept this source for official service"
                  },
                  "deterministic": {
                    "type": "boolean",
                    "title": "if this source is deteministic or not"
                  }
                },
                "title": "Source represents price data source"
              },
              "title": "sources info from where the price data would be fetched"
            },
            "rules": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "source_ids": {
                    "type": "array",
                    "items": {
                      "type": "string",
                      "format": "uint64"
                    },
                    "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
                  },
                  "nom": {
                    "title": "n out of total sources are required",
                    "type": "object",
                    "properties": {
                      "source_ids": {
                        "type": "array",
                        "items": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
                      },
                      "minimum": {
                        "type": "string",
                        "format": "uint64",
                        "title": "minimum number from the required sources to be fullfiled"
                      }
                    }
                  }
                },
                "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
              },
              "title": "rules specified on how to decide the provided price source to be accept"
            },
            "token_feeders": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "token_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "refer to params.tokenList, from 1"
                  },
                  "rule_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
                  },
                  "start_round_id": {
                    "type": "string",
                    "format": "uint64",
                    "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
                  },
                  "start_base_block": {
                    "type": "string",
                    "format": "uint64",
                    "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
                  },
                  "interval": {
                    "type": "string",
                    "format": "uint64",
                    "title": "set as count of blocks, for how many blocks interval the price will be update once"
                  },
                  "end_block": {
                    "type": "string",
                    "format": "uint64",
                    "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
                  }
                },
                "title": "Tokenfeeder represents a price oracle for one token"
              },
              "title": "each tokenFeeder represents an active token whose price being updated"
            },
            "max_nonce": {
              "type": "integer",
              "format": "int32",
              "title": "for each round allow at most max_nonce transactions to be sent by one validator, [1,max_nonce]"
            },
            "threshold_a": {
              "type": "integer",
              "format": "int32",
              "title": "voting power need to reach more than threshold_a/threshold_b"
            },
            "threshold_b": {
              "type": "integer",
              "format": "int32",
              "title": "voting power need to reach more than threshold_a/threshold_b"
            },
            "mode": {
              "title": "for v1, mode=1, get final price as soon as voting power reach threshold_a/threshold_b",
              "type": "string",
              "enum": [
                "CONSENSUS_MODE_UNSPECIFIED",
                "CONSENSUS_MODE_ASAP"
              ],
              "default": "CONSENSUS_MODE_UNSPECIFIED",
              "description": "ConsensusMode defines the consensus mode for the prices.\n\n - CONSENSUS_MODE_UNSPECIFIED: CONSENSUS_MODE_UNSPECIFIED defines an invalid mode.\n - CONSENSUS_MODE_ASAP: CONSENSUS_MODE_ASAP defines the mode to get final price immediately when the voting power\nexceeds the threshold."
            },
            "max_det_id": {
              "type": "integer",
              "format": "int32",
              "title": "for each round, a validator only allowed to provide at most max_det_id consecutive rounds of prices for DS"
            },
            "max_size_prices": {
              "type": "integer",
              "format": "int32",
              "title": "for each token, only keep max_size_prices round of prices"
            },
            "slashing": {
              "title": "slashing defines the slashing related params",
              "type": "object",
              "properties": {
                "reported_rounds_window": {
                  "type": "string",
                  "format": "int64",
                  "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
                },
                "min_reported_per_window": {
                  "type": "string",
                  "format": "byte",
                  "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
                },
                "oracle_miss_jail_duration": {
                  "type": "string",
                  "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
                },
                "oracle_malicious_jail_duration": {
                  "type": "string",
                  "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
                },
                "slash_fraction_miss": {
                  "type": "string",
                  "format": "byte",
                  "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
                },
                "slash_fraction_malicious": {
                  "type": "string",
                  "format": "byte",
                  "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
                }
              }
            }
          },
          "description": "Params defines the parameters for the module."
        }
      },
      "title": "RecentParams represents the params cached for recent blocks"
    },
    "exocore.oracle.v1.RuleSource": {
      "type": "object",
      "properties": {
        "source_ids": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uint64"
          },
          "title": "refer to params.sourceList.ID, when length>0, ignore the other field, when 1st set to 0, means all valid sources,\nlength==0->check next field:minimum"
        },
        "nom": {
          "title": "n out of total sources are required",
          "type": "object",
          "properties": {
            "source_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              },
              "title": "required source set, refer to params.sourceList, 1st set to 0 means all valid sources"
            },
            "minimum": {
              "type": "string",
              "format": "uint64",
              "title": "minimum number from the required sources to be fullfiled"
            }
          }
        }
      },
      "title": "specify data from which source is needed\nrule_1: specified sources\nrule_2: n out of total sources are required"
    },
    "exocore.oracle.v1.SlashingParams": {
      "type": "object",
      "properties": {
        "reported_rounds_window": {
          "type": "string",
          "format": "int64",
          "title": "reported_rounds_window defines how many rounds included in one window for performance review of missing report"
        },
        "min_reported_per_window": {
          "type": "string",
          "format": "byte",
          "title": "min_reported_perwindow defines at least how many rounds should be reported, this is a percentage of window"
        },
        "oracle_miss_jail_duration": {
          "type": "string",
          "title": "oracle_miss_jail_duration defines the duration one validator should be jailed for missing reporting price"
        },
        "oracle_malicious_jail_duration": {
          "type": "string",
          "title": "oracle_malicious_jail_duration defines the duratin one validator should be jailed for malicious behavior"
        },
        "slash_fraction_miss": {
          "type": "string",
          "format": "byte",
          "title": "slash_fraction_miss defines the fraction one validator should be punished for msissing reporting price"
        },
        "slash_fraction_malicious": {
          "type": "string",
          "format": "byte",
          "title": "slash_fraction_malicious defines the fraction one validator should be punished for malicious behavior"
        }
      },
      "title": "slashing related params"
    },
    "exocore.oracle.v1.Source": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of price source, like 'chainlink'"
        },
        "entry": {
          "title": "endpoint of corresponding source to fetch price data from",
          "type": "object",
          "properties": {
            "offchain": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "title": "url int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"https://chainlink.../eth\""
            },
            "onchain": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "title": "url  int refer to TokenList.ID, 0 reprents default for all (as fall back)\nkey refer to tokenID, 1->\"eth://0xabc...def\""
            }
          }
        },
        "valid": {
          "type": "boolean",
          "title": "set false when the source is out of service or reject to accept this source for official service"
        },
        "deterministic": {
          "type": "boolean",
          "title": "if this source is deteministic or not"
        }
      },
      "title": "Source represents price data source"
    },
    "exocore.oracle.v1.StakerInfo": {
      "type": "object",
      "properties": {
        "staker_addr": {
          "type": "string",
          "title": "staker's address"
        },
        "staker_index": {
          "type": "string",
          "format": "int64",
          "title": "the index of corresponding staker in staker list"
        },
        "validator_pubkey_list": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of validators that this staker corresponding to on beacon chain"
        },
        "balance_list": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "round_id": {
                "type": "string",
                "format": "uint64",
                "title": "current round of price, this is updated based on tokenFeeder"
              },
              "block": {
                "type": "string",
                "format": "uint64",
                "title": "on which block the balance updated, deposit/withdraw will update this and round_id might not change"
              },
              "index": {
                "type": "string",
                "format": "uint64",
                "title": "index used to distinguish multiple balanceInfo for one same roundid"
              },
              "balance": {
                "type": "string",
                "format": "int64",
                "title": "beaconchain epoch related to slash_refund\nuint epoch = 3;"
              },
              "change": {
                "title": "change tells the reason balance changed",
                "type": "string",
                "enum": [
                  "ACTION_ROUND_UNSPECIFIED",
                  "ACTION_DEPOSIT",
                  "ACTION_WITHDRAW",
                  "ACTION_SLASH_REFUND"
                ],
                "default": "ACTION_ROUND_UNSPECIFIED",
                "description": "- ACTION_ROUND_UNSPECIFIED: balance updated when a new round generated\n - ACTION_DEPOSIT: balance updated when a deposit happened\n - ACTION_WITHDRAW: balance updated when a withdraw happened\n - ACTION_SLASH_REFUND: balance updatd when a slah/refund on beacon chain happened"
              }
            },
            "title": "BalanceInfo tells effective-balance for native-restaking asset"
          },
          "title": "list of balances to represets the history of this staker"
        }
      },
      "title": "StakerInfo represents all related information for a staker of native-restaking"
    },
    "exocore.oracle.v1.StakerList": {
      "type": "object",
      "properties": {
        "staker_addrs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "staker's address"
        }
      },
      "title": "StakerList tells which stakers are active for one specific native-restaking asset"
    },
    "exocore.oracle.v1.Token": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "token name"
        },
        "chain_id": {
          "type": "string",
          "format": "uint64",
          "title": "id refer to chainList's index"
        },
        "contract_address": {
          "type": "string",
          "title": "if any, like erc20 tokens"
        },
        "decimal": {
          "type": "integer",
          "format": "int32",
          "title": "decimal of token price"
        },
        "active": {
          "type": "boolean",
          "title": "set false when we stop official price oracle service for a specified token"
        },
        "asset_id": {
          "type": "string",
          "title": "refer to assetID from assets module if exists"
        }
      },
      "title": "Token represents the token info"
    },
    "exocore.oracle.v1.TokenFeeder": {
      "type": "object",
      "properties": {
        "token_id": {
          "type": "string",
          "format": "uint64",
          "title": "refer to params.tokenList, from 1"
        },
        "rule_id": {
          "type": "string",
          "format": "uint64",
          "title": "refer to params.ruleList, 0 means no restriction, accept any source including customer defined"
        },
        "start_round_id": {
          "type": "string",
          "format": "uint64",
          "title": "include, from 1, when some token's feeder had been stop and then restart,\nthe token_id will be continuous from previous one"
        },
        "start_base_block": {
          "type": "string",
          "format": "uint64",
          "title": "include, first block which start_round_id can be settled is at least start_base_block+1"
        },
        "interval": {
          "type": "string",
          "format": "uint64",
          "title": "set as count of blocks, for how many blocks interval the price will be update once"
        },
        "end_block": {
          "type": "string",
          "format": "uint64",
          "title": "tokenfeeder is initialized with forever live, update the End parameters by voting,\nand will off service by the end\nthis is set by updateParams, and the EndRoundID will be update by related. excluded,\nwill not work if current height >=EndBlock"
        }
      },
      "title": "Tokenfeeder represents a price oracle for one token"
    },
    "exocore.oracle.v1.TokenIndex": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string",
          "title": "token name"
        },
        "index": {
          "type": "string",
          "format": "uint64",
          "title": "the index registered in params.Token"
        }
      },
      "title": "TokenIndex is the pair of tokenName and its index defined in params"
    },
    "exocore.oracle.v1.ValidatorUpdateBlock": {
      "type": "object",
      "properties": {
        "block": {
          "type": "string",
          "format": "uint64",
          "title": "block height on which the validator set changed"
        }
      },
      "title": "ValidatorUpdateBlock"
    },
    "exocore.exomint.v1.Params": {
      "type": "object",
      "properties": {
        "mint_denom": {
          "type": "string",
          "title": "mint_denom is the denomination of the minted coin"
        },
        "epoch_reward": {
          "type": "string",
          "description": "epoch_reward is the reward minted by the module, per epoch. note that\nthis is in addition to any other fees that are collected, or rewards\nthat are minted."
        },
        "epoch_identifier": {
          "type": "string",
          "description": "epoch_identifier is the epoch identifier used to determine when to mint\nthe reward."
        }
      },
      "description": "Params defines the parameters for the module."
    },
    "exocore.exomint.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "mint_denom": {
              "type": "string",
              "title": "mint_denom is the denomination of the minted coin"
            },
            "epoch_reward": {
              "type": "string",
              "description": "epoch_reward is the reward minted by the module, per epoch. note that\nthis is in addition to any other fees that are collected, or rewards\nthat are minted."
            },
            "epoch_identifier": {
              "type": "string",
              "description": "epoch_identifier is the epoch identifier used to determine when to mint\nthe reward."
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "exocore.feedistribution.v1.Params": {
      "type": "object",
      "properties": {
        "epoch_identifier": {
          "type": "string",
          "title": "epoch_identifier for fee distribution"
        },
        "community_tax": {
          "type": "string",
          "title": "community_tax is the tax defined for allocation"
        }
      },
      "description": "Params defines the parameters for the module."
    },
    "exocore.feedistribution.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object",
          "properties": {
            "epoch_identifier": {
              "type": "string",
              "title": "epoch_identifier for fee distribution"
            },
            "community_tax": {
              "type": "string",
              "title": "community_tax is the tax defined for allocation"
            }
          }
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    },
    "exocore.delegation.v1.DelegationAmounts": {
      "type": "object",
      "properties": {
        "undelegatable_share": {
          "type": "string",
          "description": "undelegatable_share is the share that can be undelegated.\nIt's to reduce the state updating when slash occurs.\nS_j = S * T_j / T, `S` and `T` is the current asset share and amount of operator,\nand the T_j represents the change in staker's asset amount when some external\noperations occur, such as: delegation, undelegation and slashing.\nS_j represents the change in the staker's asset share,\nso the updated share should be added by it.\nA special case is the initial delegation, when T = 0 and S = 0, so T_j / T is undefined.\nFor the initial delegation, delegator j who delegates T_j tokens receive S_j = T_j shares."
        },
        "wait_undelegation_amount": {
          "type": "string",
          "description": "wait_undelegation_amount is the amount that is waiting to be unbonded."
        }
      },
      "description": "DelegationAmounts is the delegation amount response for a single delegation."
    },
    "exocore.delegation.v1.QueryAssociatedOperatorByStakerResponse": {
      "type": "object",
      "properties": {
        "operator": {
          "type": "string",
          "title": "operator is the returned operator owner of the specified staker"
        }
      },
      "title": "QueryAssociatedOperatorByStakerResponse is the response to QueryAssociatedOperatorByStakerReq"
    },
    "exocore.delegation.v1.QueryAssociatedStakersByOperatorResponse": {
      "type": "object",
      "properties": {
        "stakers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "stakers is the returned stakers associated to the specified operator"
        }
      },
      "title": "QueryAssociatedStakersByOperatorResponse is the response to QueryAssociatedStakersByOperatorReq"
    },
    "exocore.delegation.v1.QueryDelegationInfoResponse": {
      "type": "object",
      "properties": {
        "delegation_infos": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "undelegatable_share": {
                "type": "string",
                "description": "undelegatable_share is the share that can be undelegated.\nIt's to reduce the state updating when slash occurs.\nS_j = S * T_j / T, `S` and `T` is the current asset share and amount of operator,\nand the T_j represents the change in staker's asset amount when some external\noperations occur, such as: delegation, undelegation and slashing.\nS_j represents the change in the staker's asset share,\nso the updated share should be added by it.\nA special case is the initial delegation, when T = 0 and S = 0, so T_j / T is undefined.\nFor the initial delegation, delegator j who delegates T_j tokens receive S_j = T_j shares."
              },
              "wait_undelegation_amount": {
                "type": "string",
                "description": "wait_undelegation_amount is the amount that is waiting to be unbonded."
              }
            },
            "description": "DelegationAmounts is the delegation amount response for a single delegation."
          },
          "description": "delegation_infos is the delegation information for each operator."
        }
      },
      "description": "QueryDelegationInfoResponse is the response for delegations by staker id and\nasset id."
    },
    "exocore.delegation.v1.UndelegationHoldCountResponse": {
      "type": "object",
      "properties": {
        "hold_count": {
          "type": "string",
          "format": "uint64",
          "description": "hold_count is the number of undelegations that are on hold."
        }
      },
      "description": "UndelegationHoldCountResponse is the response for the undelegation hold count."
    },
    "exocore.delegation.v1.UndelegationRecord": {
      "type": "object",
      "properties": {
        "staker_id": {
          "type": "string",
          "description": "staker_id is the staker id."
        },
        "asset_id": {
          "type": "string",
          "description": "asset_id is the asset id."
        },
        "operator_addr": {
          "type": "string",
          "description": "operator_addr is the operator address."
        },
        "tx_hash": {
          "type": "string",
          "description": "tx_hash is the transaction hash on the client chain."
        },
        "is_pending": {
          "type": "boolean",
          "description": "is_pending is the flag to indicate if the undelegation is pending."
        },
        "block_number": {
          "type": "string",
          "format": "uint64",
          "description": "block_number is the block number on Exocore."
        },
        "complete_block_number": {
          "type": "string",
          "format": "uint64",
          "description": "complete_block_number is the block number on Exocore at which the undelegation\nshould be completed."
        },
        "lz_tx_nonce": {
          "type": "string",
          "format": "uint64",
          "description": "lz_tx_nonce is the nonce of the transaction on the client chain."
        },
        "amount": {
          "type": "string",
          "description": "amount is the amount of the asset to be undelegated."
        },
        "actual_completed_amount": {
          "type": "string",
          "description": "actual_completed_amount is the actual amount of the asset that has been\nundelegated so far. it may be lower than the amount in the case of slashing."
        }
      },
      "description": "UndelegationRecord is the undelegation record, keyed by a RecordKey."
    },
    "exocore.delegation.v1.UndelegationRecordList": {
      "type": "object",
      "properties": {
        "undelegations": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "staker_id": {
                "type": "string",
                "description": "staker_id is the staker id."
              },
              "asset_id": {
                "type": "string",
                "description": "asset_id is the asset id."
              },
              "operator_addr": {
                "type": "string",
                "description": "operator_addr is the operator address."
              },
              "tx_hash": {
                "type": "string",
                "description": "tx_hash is the transaction hash on the client chain."
              },
              "is_pending": {
                "type": "boolean",
                "description": "is_pending is the flag to indicate if the undelegation is pending."
              },
              "block_number": {
                "type": "string",
                "format": "uint64",
                "description": "block_number is the block number on Exocore."
              },
              "complete_block_number": {
                "type": "string",
                "format": "uint64",
                "description": "complete_block_number is the block number on Exocore at which the undelegation\nshould be completed."
              },
              "lz_tx_nonce": {
                "type": "string",
                "format": "uint64",
                "description": "lz_tx_nonce is the nonce of the transaction on the client chain."
              },
              "amount": {
                "type": "string",
                "description": "amount is the amount of the asset to be undelegated."
              },
              "actual_completed_amount": {
                "type": "string",
                "description": "actual_completed_amount is the actual amount of the asset that has been\nundelegated so far. it may be lower than the amount in the case of slashing."
              }
            },
            "description": "UndelegationRecord is the undelegation record, keyed by a RecordKey."
          },
          "title": "UndelegationRecord is the returned undelegations"
        }
      },
      "description": "UndelegationRecordList is the response to query undelegations."
    },
    "exocore.avs.v1.AVSInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of avs as an arbitrary string"
        },
        "avs_address": {
          "type": "string",
          "title": "avs_address is the address of avs as a hex string"
        },
        "min_stake_amount": {
          "type": "string",
          "format": "uint64",
          "title": "min_stake_amount is the minimum stake amount required for a task to start"
        },
        "task_addr": {
          "type": "string",
          "title": "task_addr is the address of task as a hex string"
        },
        "slash_addr": {
          "type": "string",
          "title": "slash_addr is the hex address of the slashing contract for the AVS"
        },
        "reward_addr": {
          "type": "string",
          "title": "reward_addr is the hex address of the reward contract for the AVS"
        },
        "avs_owner_address": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "avs_owner_address are the bech32 addresses of the owners of the avs"
        },
        "asset_ids": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "asset_ids is a list of asset_ids that the AVS accepts"
        },
        "avs_unbonding_period": {
          "type": "string",
          "format": "uint64",
          "title": "avs_unbonding_period is the number of epochs that an operator must wait to unbond"
        },
        "min_self_delegation": {
          "type": "string",
          "format": "uint64",
          "title": "min_self_delegation is the minimum self delegation required for an operator to join the AVS"
        },
        "epoch_identifier": {
          "type": "string",
          "title": "epoch_identifier is the identifier from the epochs module"
        },
        "min_opt_in_operators": {
          "type": "string",
          "format": "uint64",
          "title": "min_opt_in_operators is the minimum number of operators required for a task"
        },
        "min_total_stake_amount": {
          "type": "string",
          "format": "uint64",
          "title": "min_total_stake_amount is the minimum total stake amount required for a task"
        },
        "starting_epoch": {
          "type": "string",
          "format": "uint64",
          "title": "starting_epoch is the epoch at which the AVS starts"
        },
        "chain_id": {
          "type": "string",
          "title": "chain_id is an optional parameter to specify the chain_id of the AVS, if any"
        },
        "avs_reward": {
          "type": "string",
          "title": "avs_reward defines the proportion of reward"
        },
        "avs_slash": {
          "type": "string",
          "title": "avs_slash defines the proportion of slash"
        },
        "asset_reward_amount_epoch_basis": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          },
          "description": "asset_reward_commission_epoch_basis is the avs reward distribution based on asset per eopch end."
        }
      },
      "title": "AVSinfo represent the information of avs"
    },
    "exocore.avs.v1.OperatorActivePowerInfo": {
      "type": "object",
      "properties": {
        "operator_addr": {
          "type": "string",
          "description": "operator_addr is the operator  address."
        },
        "active_power": {
          "type": "string",
          "description": "active_power is the USD value owned by the operator itself."
        }
      },
      "description": "OperatorActivePowerInfo is the operator power info."
    },
    "exocore.avs.v1.OperatorActivePowerList": {
      "type": "object",
      "properties": {
        "operator_power_list": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_addr": {
                "type": "string",
                "description": "operator_addr is the operator  address."
              },
              "active_power": {
                "type": "string",
                "description": "active_power is the USD value owned by the operator itself."
              }
            },
            "description": "OperatorActivePowerInfo is the operator power info."
          },
          "description": "operator_power_list is a power list of operators."
        }
      },
      "title": "OperatorActivePowerList is the power list of operators opt-in to the current task.\nBecause power is always changing, record the power of all operators\nwho have completed tasks and submitted results by the task deadline"
    },
    "exocore.avs.v1.Phase": {
      "type": "string",
      "enum": [
        "PHASE_UNSPECIFIED",
        "PHASE_PREPARE",
        "PHASE_DO_COMMIT"
      ],
      "default": "PHASE_UNSPECIFIED",
      "description": "- PHASE_UNSPECIFIED: Default value when phase is not specified\n - PHASE_PREPARE: First phase where operators prepare and submit their initial responses\n - PHASE_DO_COMMIT: Second phase where operators commit their prepared responses",
      "title": "It is a two-phase submission with two values, 1 and 2"
    },
    "exocore.avs.v1.QueryAVSAddrByChainIDResponse": {
      "type": "object",
      "properties": {
        "avs_address": {
          "type": "string",
          "title": "avs_address is the hex address of avs"
        }
      },
      "title": "QueryAVSAddrByChainIDResponse is the response of avs address by chain id"
    },
    "exocore.avs.v1.QueryAVSInfoResponse": {
      "type": "object",
      "properties": {
        "info": {
          "title": "basic information of avs",
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "title": "name of avs as an arbitrary string"
            },
            "avs_address": {
              "type": "string",
              "title": "avs_address is the address of avs as a hex string"
            },
            "min_stake_amount": {
              "type": "string",
              "format": "uint64",
              "title": "min_stake_amount is the minimum stake amount required for a task to start"
            },
            "task_addr": {
              "type": "string",
              "title": "task_addr is the address of task as a hex string"
            },
            "slash_addr": {
              "type": "string",
              "title": "slash_addr is the hex address of the slashing contract for the AVS"
            },
            "reward_addr": {
              "type": "string",
              "title": "reward_addr is the hex address of the reward contract for the AVS"
            },
            "avs_owner_address": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "avs_owner_address are the bech32 addresses of the owners of the avs"
            },
            "asset_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "title": "asset_ids is a list of asset_ids that the AVS accepts"
            },
            "avs_unbonding_period": {
              "type": "string",
              "format": "uint64",
              "title": "avs_unbonding_period is the number of epochs that an operator must wait to unbond"
            },
            "min_self_delegation": {
              "type": "string",
              "format": "uint64",
              "title": "min_self_delegation is the minimum self delegation required for an operator to join the AVS"
            },
            "epoch_identifier": {
              "type": "string",
              "title": "epoch_identifier is the identifier from the epochs module"
            },
            "min_opt_in_operators": {
              "type": "string",
              "format": "uint64",
              "title": "min_opt_in_operators is the minimum number of operators required for a task"
            },
            "min_total_stake_amount": {
              "type": "string",
              "format": "uint64",
              "title": "min_total_stake_amount is the minimum total stake amount required for a task"
            },
            "starting_epoch": {
              "type": "string",
              "format": "uint64",
              "title": "starting_epoch is the epoch at which the AVS starts"
            },
            "chain_id": {
              "type": "string",
              "title": "chain_id is an optional parameter to specify the chain_id of the AVS, if any"
            },
            "avs_reward": {
              "type": "string",
              "title": "avs_reward defines the proportion of reward"
            },
            "avs_slash": {
              "type": "string",
              "title": "avs_slash defines the proportion of slash"
            },
            "asset_reward_amount_epoch_basis": {
              "type": "object",
              "additionalProperties": {
                "type": "string",
                "format": "int64"
              },
              "description": "asset_reward_commission_epoch_basis is the avs reward distribution based on asset per eopch end."
            }
          }
        }
      },
      "title": "QueryAVSInfoResponse is the response of avs related information"
    },
    "exocore.avs.v1.QueryChallengeInfoResponse": {
      "type": "object",
      "properties": {
        "challenge_addr": {
          "type": "string",
          "description": "challenge_addr is the challenge address,its type should be a common.HexAddress."
        }
      },
      "title": "QueryChallengeInfoResponse is the response of avs related information"
    },
    "exocore.avs.v1.QuerySubmitTaskResultResponse": {
      "type": "object",
      "properties": {
        "info": {
          "description": "info is the taskResult.",
          "type": "object",
          "properties": {
            "operator_address": {
              "type": "string",
              "title": "operator_address operator address"
            },
            "task_response_hash": {
              "type": "string",
              "description": "task_response_hash is the task_response msg hash."
            },
            "task_response": {
              "type": "string",
              "format": "byte",
              "description": "task_response is the task response data."
            },
            "bls_signature": {
              "type": "string",
              "format": "byte",
              "description": "bls_signature is the operator bls sig info."
            },
            "task_contract_address": {
              "type": "string",
              "title": "task_contract_address is contract address of task"
            },
            "task_id": {
              "type": "string",
              "format": "uint64",
              "title": "task_id is the  task id"
            },
            "phase": {
              "title": "phase this field is used to solve the problem of task results being copied by other operators.\nIt is a two-phase submission with two values, 1 and 2",
              "type": "string",
              "enum": [
                "PHASE_UNSPECIFIED",
                "PHASE_PREPARE",
                "PHASE_DO_COMMIT"
              ],
              "default": "PHASE_UNSPECIFIED",
              "description": "- PHASE_UNSPECIFIED: Default value when phase is not specified\n - PHASE_PREPARE: First phase where operators prepare and submit their initial responses\n - PHASE_DO_COMMIT: Second phase where operators commit their prepared responses"
            }
          }
        }
      },
      "title": "QuerySubmitTaskResultResponse is the response of avs related information"
    },
    "exocore.avs.v1.TaskInfo": {
      "type": "object",
      "properties": {
        "task_contract_address": {
          "type": "string",
          "title": "contract address of avstask"
        },
        "name": {
          "type": "string",
          "title": "name of task"
        },
        "hash": {
          "type": "string",
          "format": "byte",
          "title": "data which is supplied by the contract, usually ABI-encoded"
        },
        "task_id": {
          "type": "string",
          "format": "uint64",
          "title": "task_id of task"
        },
        "task_response_period": {
          "type": "string",
          "format": "uint64",
          "title": "Deadline for task response"
        },
        "task_statistical_period": {
          "type": "string",
          "format": "uint64",
          "title": "Statistical period: threshold calculation, signature verification,\nnosig quantity statistics, operator submits messages corresponding to signatures"
        },
        "task_challenge_period": {
          "type": "string",
          "format": "uint64",
          "title": "challenge period for  task"
        },
        "threshold_percentage": {
          "type": "string",
          "format": "uint64",
          "title": "Signature threshold percentage"
        },
        "starting_epoch": {
          "type": "string",
          "format": "uint64",
          "title": "Effective current epoch, accounting for current_epoch + 1\nand current_epoch is the integer identifier of the epoch module"
        },
        "actual_threshold": {
          "type": "string",
          "format": "uint64",
          "title": "actual_threshold is the Actual threshold"
        },
        "opt_in_operators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "opt_in_count when creating a task, the actual opt-in operator counts at this moment"
        },
        "signed_operators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "signed_count is Actual number of signatures already signed"
        },
        "no_signed_operators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "no_signed_count is the final number of unsigned operators"
        },
        "err_signed_operators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "err_signed_count is the number of operators with final incorrect signatures"
        },
        "task_total_power": {
          "type": "string",
          "description": "task_total_power is the USD value owned by the avs task itself."
        },
        "operator_active_power": {
          "title": "operator_active_power_list is a power list of operators opt-in to the current task",
          "type": "object",
          "properties": {
            "operator_power_list": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_addr": {
                    "type": "string",
                    "description": "operator_addr is the operator  address."
                  },
                  "active_power": {
                    "type": "string",
                    "description": "active_power is the USD value owned by the operator itself."
                  }
                },
                "description": "OperatorActivePowerInfo is the operator power info."
              },
              "description": "operator_power_list is a power list of operators."
            }
          }
        }
      },
      "description": "TaskContractInfo is the task info."
    },
    "exocore.avs.v1.TaskResultInfo": {
      "type": "object",
      "properties": {
        "operator_address": {
          "type": "string",
          "title": "operator_address operator address"
        },
        "task_response_hash": {
          "type": "string",
          "description": "task_response_hash is the task_response msg hash."
        },
        "task_response": {
          "type": "string",
          "format": "byte",
          "description": "task_response is the task response data."
        },
        "bls_signature": {
          "type": "string",
          "format": "byte",
          "description": "bls_signature is the operator bls sig info."
        },
        "task_contract_address": {
          "type": "string",
          "title": "task_contract_address is contract address of task"
        },
        "task_id": {
          "type": "string",
          "format": "uint64",
          "title": "task_id is the  task id"
        },
        "phase": {
          "title": "phase this field is used to solve the problem of task results being copied by other operators.\nIt is a two-phase submission with two values, 1 and 2",
          "type": "string",
          "enum": [
            "PHASE_UNSPECIFIED",
            "PHASE_PREPARE",
            "PHASE_DO_COMMIT"
          ],
          "default": "PHASE_UNSPECIFIED",
          "description": "- PHASE_UNSPECIFIED: Default value when phase is not specified\n - PHASE_PREPARE: First phase where operators prepare and submit their initial responses\n - PHASE_DO_COMMIT: Second phase where operators commit their prepared responses"
        }
      },
      "description": "TaskResultInfo is the operator sign task info result."
    },
    "cosmos.staking.v1beta1.BondStatus": {
      "type": "string",
      "enum": [
        "BOND_STATUS_UNSPECIFIED",
        "BOND_STATUS_UNBONDED",
        "BOND_STATUS_UNBONDING",
        "BOND_STATUS_BONDED"
      ],
      "default": "BOND_STATUS_UNSPECIFIED",
      "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
    },
    "cosmos.staking.v1beta1.Commission": {
      "type": "object",
      "properties": {
        "commission_rates": {
          "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
          "type": "object",
          "properties": {
            "rate": {
              "type": "string",
              "description": "rate is the commission rate charged to delegators, as a fraction."
            },
            "max_rate": {
              "type": "string",
              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
            },
            "max_change_rate": {
              "type": "string",
              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
            }
          }
        },
        "update_time": {
          "type": "string",
          "format": "date-time",
          "description": "update_time is the last time the commission rate was changed."
        }
      },
      "description": "Commission defines commission parameters for a given validator."
    },
    "cosmos.staking.v1beta1.CommissionRates": {
      "type": "object",
      "properties": {
        "rate": {
          "type": "string",
          "description": "rate is the commission rate charged to delegators, as a fraction."
        },
        "max_rate": {
          "type": "string",
          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
        },
        "max_change_rate": {
          "type": "string",
          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
        }
      },
      "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
    },
    "exocore.operator.v1.ClientChainEarningAddrInfo": {
      "type": "object",
      "properties": {
        "lz_client_chain_id": {
          "type": "string",
          "format": "uint64",
          "description": "lz_client_chain_id is the layer0 client chain id."
        },
        "client_chain_earning_addr": {
          "type": "string",
          "description": "client_chain_earning_addr is the client chain earning address."
        }
      },
      "description": "ClientChainEarningAddrInfo is the client chain earning address info."
    },
    "exocore.operator.v1.ClientChainEarningAddrList": {
      "type": "object",
      "properties": {
        "earning_info_list": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "lz_client_chain_id": {
                "type": "string",
                "format": "uint64",
                "description": "lz_client_chain_id is the layer0 client chain id."
              },
              "client_chain_earning_addr": {
                "type": "string",
                "description": "client_chain_earning_addr is the client chain earning address."
              }
            },
            "description": "ClientChainEarningAddrInfo is the client chain earning address info."
          },
          "description": "earning_info_list is the contents of ClientChainEarningAddrList."
        }
      },
      "description": "ClientChainEarningAddrList is the list of client chain earning addresses.\nBecause the reward token provide by the AVS might be located at different client chain, the operator need to\nprovide the different client chain address to receive the token rewards."
    },
    "exocore.operator.v1.DecValueField": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "string",
          "description": "amount is the USD value of the asset, as an sdk.LegacyDec."
        }
      },
      "description": "DecValueField is a field that holds a value of sdk.LegacyDec type."
    },
    "exocore.operator.v1.DelegatorInfo": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "title": "asset_id is the asset for which the query is made"
        },
        "symbol": {
          "type": "string",
          "title": "symbol of the asset, like \"USDT\""
        },
        "name": {
          "type": "string",
          "title": "name of the asset, like \"Tether USD\""
        },
        "self_amount": {
          "type": "string",
          "title": "self_amount is the self amount of the asset which delegation"
        },
        "total_amount": {
          "type": "string",
          "title": "total_amount is the total amount of the asset which delegation"
        },
        "self_usd_value": {
          "type": "string",
          "title": "self_usd_value is the self delegation USD value for the validator"
        },
        "total_usd_value": {
          "type": "string",
          "title": "total_usd_value is the total delegation USD value for the validator"
        }
      },
      "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
    },
    "exocore.operator.v1.OperatorAVSAddress": {
      "type": "object",
      "properties": {
        "operator_addr": {
          "type": "string",
          "title": "operator_addr should be the string type of sdk.AccAddress"
        },
        "avs_address": {
          "type": "string",
          "description": "avs_address is the address of the AVS - either an 0x address or a chainID."
        }
      },
      "title": "OperatorAVSAddress includes the address of operator and AVS"
    },
    "exocore.operator.v1.OperatorConsAddrPair": {
      "type": "object",
      "properties": {
        "operator_acc_addr": {
          "type": "string",
          "description": "operator_acc_addr is the operator account address."
        },
        "cons_addr": {
          "type": "string",
          "description": "cons_addr is the consensus address corresponding to the consensus public key\ncurrently in use by the operator."
        },
        "opting_out": {
          "type": "boolean",
          "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
        }
      },
      "description": "OperatorConsAddrPair holds the operator address and the corresponding consensus address."
    },
    "exocore.operator.v1.OperatorConsKeyPair": {
      "type": "object",
      "properties": {
        "operator_acc_addr": {
          "type": "string",
          "description": "operator_acc_addr is the operator account address."
        },
        "public_key": {
          "description": "public_key is the consensus public key of the operator.",
          "type": "object",
          "properties": {
            "ed25519": {
              "type": "string",
              "format": "byte"
            },
            "secp256k1": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PublicKey defines the keys available for use with Validators"
        },
        "opting_out": {
          "type": "boolean",
          "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
        }
      },
      "description": "OperatorConsKeyPair holds the operator address and the consensus public key currently in\nuse by the operator."
    },
    "exocore.operator.v1.OperatorInfo": {
      "type": "object",
      "properties": {
        "earnings_addr": {
          "type": "string",
          "description": "earnings_addr is the earnings address."
        },
        "approve_addr": {
          "type": "string",
          "description": "approve_addr is the approve address."
        },
        "operator_meta_info": {
          "type": "string",
          "description": "operator_meta_info is the operator meta info."
        },
        "client_chain_earnings_addr": {
          "description": "client_chain_earning_addr_list is the client chain earning address list.",
          "type": "object",
          "properties": {
            "earning_info_list": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "lz_client_chain_id": {
                    "type": "string",
                    "format": "uint64",
                    "description": "lz_client_chain_id is the layer0 client chain id."
                  },
                  "client_chain_earning_addr": {
                    "type": "string",
                    "description": "client_chain_earning_addr is the client chain earning address."
                  }
                },
                "description": "ClientChainEarningAddrInfo is the client chain earning address info."
              },
              "description": "earning_info_list is the contents of ClientChainEarningAddrList."
            }
          }
        },
        "commission": {
          "description": "commission defines the commission parameters. it includes the time at which the commission\nwas last updated.",
          "type": "object",
          "properties": {
            "commission_rates": {
              "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
              "type": "object",
              "properties": {
                "rate": {
                  "type": "string",
                  "description": "rate is the commission rate charged to delegators, as a fraction."
                },
                "max_rate": {
                  "type": "string",
                  "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                },
                "max_change_rate": {
                  "type": "string",
                  "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                }
              }
            },
            "update_time": {
              "type": "string",
              "format": "date-time",
              "description": "update_time is the last time the commission rate was changed."
            }
          }
        }
      },
      "description": "OperatorInfo is the operator info."
    },
    "exocore.operator.v1.OperatorOptedUSDValue": {
      "type": "object",
      "properties": {
        "self_usd_value": {
          "type": "string",
          "description": "self_usd_value is the USD value owned by the operator itself."
        },
        "total_usd_value": {
          "type": "string",
          "title": "total_usd_value is the total opted-in USD value for the specified operator and AVS"
        },
        "active_usd_value": {
          "type": "string",
          "description": "active_usd_value is the active opted-in USD value for the specified operator and AVS\nthis field will be zero if the operator's self staking isn't sufficient. Of course, it will\nbe equal to total_usd_value if the operator's self staking meets the AVS requirement."
        }
      },
      "title": "OperatorOptedUSDValue records the self and total opted-in USD value for the specified operator and AVS"
    },
    "exocore.operator.v1.OperatorSlashInfo": {
      "type": "object",
      "properties": {
        "slash_contract": {
          "type": "string",
          "title": "slash_contract is the address of slash contract"
        },
        "submitted_height": {
          "type": "string",
          "format": "int64",
          "title": "submitted_height is the exocore block height at which the slash event is submitted"
        },
        "event_height": {
          "type": "string",
          "format": "int64",
          "title": "event_height is the exocore block height at which the slash event occurs"
        },
        "is_vetoed": {
          "type": "boolean",
          "title": "is_vetoed is a flag to indicate if this slash is vetoed"
        },
        "slash_proportion": {
          "type": "string",
          "title": "slash_proportion is the proportion of assets that need to be slashed"
        },
        "slash_type": {
          "type": "integer",
          "format": "int64",
          "description": "slash_type indicates the slash type of specified AVS."
        },
        "execution_info": {
          "title": "SlashExecutionInfo stores the slashed execution information",
          "type": "object",
          "properties": {
            "slash_proportion": {
              "type": "string",
              "title": "slash_proportion is the new calculated proportion when execute the slash"
            },
            "slash_value": {
              "type": "string",
              "title": "slash_value is the usd value of all slashed assets"
            },
            "slash_undelegations": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "staker_id": {
                    "type": "string",
                    "description": "staker_id is the staker id."
                  },
                  "asset_id": {
                    "type": "string",
                    "description": "asset_id is the asset id."
                  },
                  "amount": {
                    "type": "string",
                    "description": "amount is the slashed amount from the undelegation."
                  }
                },
                "title": "SlashFromUndelegation records the slash detail from the undelegation"
              },
              "title": "SlashUndelegations records all slash info related to the undelegation"
            },
            "slash_assets_pool": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "asset_id": {
                    "type": "string",
                    "description": "asset_id is the asset id."
                  },
                  "amount": {
                    "type": "string",
                    "description": "amount is the slashed amount from the assets pool."
                  }
                },
                "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
              },
              "title": "SlashFromAssetsPool records all slash info related to the assets pool"
            },
            "undelegation_filter_height": {
              "type": "string",
              "format": "int64",
              "title": "undelegation_filter_height records the height before which undelegations are not slashed"
            }
          }
        }
      },
      "title": "OperatorSlashInfo is the slash info of operator"
    },
    "exocore.operator.v1.OperatorSlashInfoByID": {
      "type": "object",
      "properties": {
        "slash_id": {
          "type": "string",
          "description": "slash_id is stored as the key of the slash information,\nso it will be parsed and padding here."
        },
        "info": {
          "description": "info is the specified detailed information for the slashing event.",
          "type": "object",
          "properties": {
            "slash_contract": {
              "type": "string",
              "title": "slash_contract is the address of slash contract"
            },
            "submitted_height": {
              "type": "string",
              "format": "int64",
              "title": "submitted_height is the exocore block height at which the slash event is submitted"
            },
            "event_height": {
              "type": "string",
              "format": "int64",
              "title": "event_height is the exocore block height at which the slash event occurs"
            },
            "is_vetoed": {
              "type": "boolean",
              "title": "is_vetoed is a flag to indicate if this slash is vetoed"
            },
            "slash_proportion": {
              "type": "string",
              "title": "slash_proportion is the proportion of assets that need to be slashed"
            },
            "slash_type": {
              "type": "integer",
              "format": "int64",
              "description": "slash_type indicates the slash type of specified AVS."
            },
            "execution_info": {
              "title": "SlashExecutionInfo stores the slashed execution information",
              "type": "object",
              "properties": {
                "slash_proportion": {
                  "type": "string",
                  "title": "slash_proportion is the new calculated proportion when execute the slash"
                },
                "slash_value": {
                  "type": "string",
                  "title": "slash_value is the usd value of all slashed assets"
                },
                "slash_undelegations": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "staker_id": {
                        "type": "string",
                        "description": "staker_id is the staker id."
                      },
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the asset id."
                      },
                      "amount": {
                        "type": "string",
                        "description": "amount is the slashed amount from the undelegation."
                      }
                    },
                    "title": "SlashFromUndelegation records the slash detail from the undelegation"
                  },
                  "title": "SlashUndelegations records all slash info related to the undelegation"
                },
                "slash_assets_pool": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "asset_id": {
                        "type": "string",
                        "description": "asset_id is the asset id."
                      },
                      "amount": {
                        "type": "string",
                        "description": "amount is the slashed amount from the assets pool."
                      }
                    },
                    "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
                  },
                  "title": "SlashFromAssetsPool records all slash info related to the assets pool"
                },
                "undelegation_filter_height": {
                  "type": "string",
                  "format": "int64",
                  "title": "undelegation_filter_height records the height before which undelegations are not slashed"
                }
              }
            }
          },
          "title": "OperatorSlashInfo is the slash info of operator"
        }
      },
      "title": "OperatorSlashInfoByID includes the slash information and the slashID"
    },
    "exocore.operator.v1.OperatorVotingPower": {
      "type": "object",
      "properties": {
        "operator_addr": {
          "type": "string",
          "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
        },
        "voting_power": {
          "type": "string",
          "title": "voting_power is the active voting power for the above operator address"
        }
      },
      "title": "OperatorVotingPower represents the voting power for the specified operator address"
    },
    "exocore.operator.v1.OptedInfo": {
      "type": "object",
      "properties": {
        "slash_contract": {
          "type": "string",
          "title": "slash_contract is the slash contract address of AVS opted-in by the operator"
        },
        "opted_in_height": {
          "type": "string",
          "format": "uint64",
          "title": "opted_in_height is the exocore block height at which the operator opted in"
        },
        "opted_out_height": {
          "type": "string",
          "format": "uint64",
          "title": "opted_out_height is the exocore block height at which the operator opted out"
        },
        "jailed": {
          "type": "boolean",
          "description": "jailed defined whether the operator has been jailed from bonded status or not."
        }
      },
      "title": "OptedInfo is the opted information about operator"
    },
    "exocore.operator.v1.QueryAllAVSsByOperatorResponse": {
      "type": "object",
      "properties": {
        "avs_list": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "avs_list is a list of avs addresses  ."
        }
      },
      "description": "QueryAllAVSsByOperatorResponse is the response that includes a list of all operators\nand their consensus keys for a specified chain ID."
    },
    "exocore.operator.v1.QueryAllOperatorConsAddrsByChainIDResponse": {
      "type": "object",
      "properties": {
        "operator_cons_addrs": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_acc_addr": {
                "type": "string",
                "description": "operator_acc_addr is the operator account address."
              },
              "cons_addr": {
                "type": "string",
                "description": "cons_addr is the consensus address corresponding to the consensus public key\ncurrently in use by the operator."
              },
              "opting_out": {
                "type": "boolean",
                "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
              }
            },
            "description": "OperatorConsAddrPair holds the operator address and the corresponding consensus address."
          },
          "description": "operator_cons_addrs is a list of operator account addresses and the consensus addresses."
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllOperatorConsAddrsByChainIDResponse is the response that includes a list of all operators\nand their consensus addresses for a specified chain ID."
    },
    "exocore.operator.v1.QueryAllOperatorConsKeysByChainIDResponse": {
      "type": "object",
      "properties": {
        "operator_cons_keys": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_acc_addr": {
                "type": "string",
                "description": "operator_acc_addr is the operator account address."
              },
              "public_key": {
                "description": "public_key is the consensus public key of the operator.",
                "type": "object",
                "properties": {
                  "ed25519": {
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "type": "string",
                    "format": "byte"
                  }
                },
                "title": "PublicKey defines the keys available for use with Validators"
              },
              "opting_out": {
                "type": "boolean",
                "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
              }
            },
            "description": "OperatorConsKeyPair holds the operator address and the consensus public key currently in\nuse by the operator."
          },
          "description": "operator_cons_keys is a list of operator addresses and their consensus public keys."
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllOperatorConsKeysByChainIDResponse is the response that includes a list of all operators\nand their consensus keys for a specified chain ID."
    },
    "exocore.operator.v1.QueryAllOperatorsByOptInAVSResponse": {
      "type": "object",
      "properties": {
        "operator_list": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "operator_list is a list of operator addresses."
        }
      },
      "description": "QueryAllOperatorsWithOptInAVSResponse is the response that includes a list of all avs\n  for a specified operator address."
    },
    "exocore.operator.v1.QueryAllOperatorsResponse": {
      "type": "object",
      "properties": {
        "operator_acc_addrs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "operators is a list of all operators."
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "description": "QueryAllOperatorsResponse is the response containing all operator account addresses."
    },
    "exocore.operator.v1.QueryAllSnapshotResponse": {
      "type": "object",
      "properties": {
        "snapshots": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "snapshot_key_height": {
                "type": "string",
                "format": "int64",
                "description": "snapshot_key_height when it is used in QuerySpecifiedSnapshot, it's the latest\nheight with a snapshot key found based on the input height; this height is typically\nthe start height of the epoch in which the input height is located.\nwhen it is used in QueryAllSnapshot, it's the height in the current snapshot key."
              },
              "snapshot": {
                "description": "snapshot when it is used in QuerySpecifiedSnapshot, it is the final retrieved information\ncontaining the voting power set.\nwhen it is used in QueryAllSnapshot, It is the snapshot stored under `snapshot_key_height`,\nand its voting power set may be nil.",
                "type": "object",
                "properties": {
                  "total_voting_power": {
                    "type": "string",
                    "title": "total_voting_power is the total voting power of specified AVS"
                  },
                  "operator_voting_powers": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "operator_addr": {
                          "type": "string",
                          "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
                        },
                        "voting_power": {
                          "type": "string",
                          "title": "voting_power is the active voting power for the above operator address"
                        }
                      },
                      "title": "OperatorVotingPower represents the voting power for the specified operator address"
                    },
                    "title": "operator_voting_powers records the active voting power of all operators\nfor the specified AVS"
                  },
                  "last_changed_height": {
                    "type": "string",
                    "format": "int64",
                    "description": "last_changed_height is used to indicate the height of most recent change when\nthe operator_voting_powers is nil, which can help to fall back to the correct epoch height."
                  },
                  "epoch_identifier": {
                    "type": "string",
                    "title": "epoch_identifier record the epoch info"
                  },
                  "epoch_number": {
                    "type": "string",
                    "format": "int64",
                    "title": "epoch_number indicates which epoch this snapshot serve for"
                  }
                }
              }
            },
            "title": "VotingPowerSnapshotKeyHeight is used in the response of QuerySpecifiedSnapshot\nand QueryAllSnapshot"
          },
          "description": "snapshots is a list of all snapshots for the specified AVS."
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryAllSnapshotResponse is the response to obtain all voting power snapshot\nfor the specified AVS"
    },
    "exocore.operator.v1.QueryOperatorConsAddressResponse": {
      "type": "object",
      "properties": {
        "cons_addr": {
          "type": "string",
          "description": "cons_addr is the consensus address corresponding to the consensus public key\ncurrently in use by the operator."
        },
        "opting_out": {
          "type": "boolean",
          "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
        }
      },
      "description": "QueryOperatorConsAddressResponse is the response for QueryOperatorConsAddressRequest."
    },
    "exocore.operator.v1.QueryOperatorConsKeyResponse": {
      "type": "object",
      "properties": {
        "public_key": {
          "description": "public_key is the consensus public key of the operator.",
          "type": "object",
          "properties": {
            "ed25519": {
              "type": "string",
              "format": "byte"
            },
            "secp256k1": {
              "type": "string",
              "format": "byte"
            }
          },
          "title": "PublicKey defines the keys available for use with Validators"
        },
        "opting_out": {
          "type": "boolean",
          "description": "opting_out is a flag to indicate if the operator is opting out of consensus."
        }
      },
      "description": "QueryOperatorConsKeyResponse is the response for QueryOperatorConsKeyRequest."
    },
    "exocore.operator.v1.QueryOperatorSlashInfoResponse": {
      "type": "object",
      "properties": {
        "all_slash_info": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "slash_id": {
                "type": "string",
                "description": "slash_id is stored as the key of the slash information,\nso it will be parsed and padding here."
              },
              "info": {
                "description": "info is the specified detailed information for the slashing event.",
                "type": "object",
                "properties": {
                  "slash_contract": {
                    "type": "string",
                    "title": "slash_contract is the address of slash contract"
                  },
                  "submitted_height": {
                    "type": "string",
                    "format": "int64",
                    "title": "submitted_height is the exocore block height at which the slash event is submitted"
                  },
                  "event_height": {
                    "type": "string",
                    "format": "int64",
                    "title": "event_height is the exocore block height at which the slash event occurs"
                  },
                  "is_vetoed": {
                    "type": "boolean",
                    "title": "is_vetoed is a flag to indicate if this slash is vetoed"
                  },
                  "slash_proportion": {
                    "type": "string",
                    "title": "slash_proportion is the proportion of assets that need to be slashed"
                  },
                  "slash_type": {
                    "type": "integer",
                    "format": "int64",
                    "description": "slash_type indicates the slash type of specified AVS."
                  },
                  "execution_info": {
                    "title": "SlashExecutionInfo stores the slashed execution information",
                    "type": "object",
                    "properties": {
                      "slash_proportion": {
                        "type": "string",
                        "title": "slash_proportion is the new calculated proportion when execute the slash"
                      },
                      "slash_value": {
                        "type": "string",
                        "title": "slash_value is the usd value of all slashed assets"
                      },
                      "slash_undelegations": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "staker_id": {
                              "type": "string",
                              "description": "staker_id is the staker id."
                            },
                            "asset_id": {
                              "type": "string",
                              "description": "asset_id is the asset id."
                            },
                            "amount": {
                              "type": "string",
                              "description": "amount is the slashed amount from the undelegation."
                            }
                          },
                          "title": "SlashFromUndelegation records the slash detail from the undelegation"
                        },
                        "title": "SlashUndelegations records all slash info related to the undelegation"
                      },
                      "slash_assets_pool": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "asset_id": {
                              "type": "string",
                              "description": "asset_id is the asset id."
                            },
                            "amount": {
                              "type": "string",
                              "description": "amount is the slashed amount from the assets pool."
                            }
                          },
                          "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
                        },
                        "title": "SlashFromAssetsPool records all slash info related to the assets pool"
                      },
                      "undelegation_filter_height": {
                        "type": "string",
                        "format": "int64",
                        "title": "undelegation_filter_height records the height before which undelegations are not slashed"
                      }
                    }
                  }
                },
                "title": "OperatorSlashInfo is the slash info of operator"
              }
            },
            "title": "OperatorSlashInfoByID includes the slash information and the slashID"
          },
          "title": "all_slash_info is a list of the slash information for the specified operator and AVS"
        },
        "pagination": {
          "description": "pagination related response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryOperatorSlashInfoResponse is the response for GetOperatorSlashInfoRequest"
    },
    "exocore.operator.v1.QueryOperatorUSDValueResponse": {
      "type": "object",
      "properties": {
        "usd_values": {
          "title": "usd_info includes the self and total staking for the operator and AVS",
          "type": "object",
          "properties": {
            "self_usd_value": {
              "type": "string",
              "description": "self_usd_value is the USD value owned by the operator itself."
            },
            "total_usd_value": {
              "type": "string",
              "title": "total_usd_value is the total opted-in USD value for the specified operator and AVS"
            },
            "active_usd_value": {
              "type": "string",
              "description": "active_usd_value is the active opted-in USD value for the specified operator and AVS\nthis field will be zero if the operator's self staking isn't sufficient. Of course, it will\nbe equal to total_usd_value if the operator's self staking meets the AVS requirement."
            }
          }
        }
      },
      "description": "QueryOperatorUSDValueResponse is the response to obtain the USD value for operator."
    },
    "exocore.operator.v1.QueryValidatorResponse": {
      "type": "object",
      "properties": {
        "validator": {
          "description": "validator defines the validator info.",
          "type": "object",
          "properties": {
            "operator_earnings_addr": {
              "type": "string",
              "description": "earnoperator_earnings_addrings_addr is the earnings address."
            },
            "operator_approve_addr": {
              "type": "string",
              "description": "operator_approve_addr is the approve address."
            },
            "operator_meta_info": {
              "type": "string",
              "description": "operator_meta_info is the operator meta info."
            },
            "cons_address": {
              "type": "string",
              "description": "ConsAddress defines a wrapper around bytes meant to present a consensus node.\nWhen marshaled to a string or JSON, it uses Bech32."
            },
            "consensus_pubkey": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
              "title": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any"
            },
            "jailed": {
              "type": "boolean",
              "title": "jailed defined whether the validator has been jailed from bonded status or not"
            },
            "status": {
              "title": "status is the validator status (bonded/unbonding/unbonded)",
              "type": "string",
              "enum": [
                "BOND_STATUS_UNSPECIFIED",
                "BOND_STATUS_UNBONDED",
                "BOND_STATUS_UNBONDING",
                "BOND_STATUS_BONDED"
              ],
              "default": "BOND_STATUS_UNSPECIFIED",
              "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
            },
            "voting_power": {
              "type": "string",
              "title": "voting_power define the validator voting power"
            },
            "delegator_shares": {
              "type": "string",
              "title": "delegator_shares defines total shares issued to a validator's delegators"
            },
            "commission": {
              "description": "commission defines the commission parameters.",
              "type": "object",
              "properties": {
                "commission_rates": {
                  "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                  "type": "object",
                  "properties": {
                    "rate": {
                      "type": "string",
                      "description": "rate is the commission rate charged to delegators, as a fraction."
                    },
                    "max_rate": {
                      "type": "string",
                      "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                    },
                    "max_change_rate": {
                      "type": "string",
                      "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                    }
                  }
                },
                "update_time": {
                  "type": "string",
                  "format": "date-time",
                  "description": "update_time is the last time the commission rate was changed."
                }
              }
            },
            "delegator_tokens": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "asset_id": {
                    "type": "string",
                    "title": "asset_id is the asset for which the query is made"
                  },
                  "symbol": {
                    "type": "string",
                    "title": "symbol of the asset, like \"USDT\""
                  },
                  "name": {
                    "type": "string",
                    "title": "name of the asset, like \"Tether USD\""
                  },
                  "self_amount": {
                    "type": "string",
                    "title": "self_amount is the self amount of the asset which delegation"
                  },
                  "total_amount": {
                    "type": "string",
                    "title": "total_amount is the total amount of the asset which delegation"
                  },
                  "self_usd_value": {
                    "type": "string",
                    "title": "self_usd_value is the self delegation USD value for the validator"
                  },
                  "total_usd_value": {
                    "type": "string",
                    "title": "total_usd_value is the total delegation USD value for the validator"
                  }
                },
                "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
              },
              "title": "delegator_tokens is the list of asset infos"
            }
          },
          "title": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate"
        }
      },
      "title": "QueryValidatorResponse is response type for the Query/Validator RPC method"
    },
    "exocore.operator.v1.QueryValidatorsResponse": {
      "type": "object",
      "properties": {
        "validators": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_earnings_addr": {
                "type": "string",
                "description": "earnoperator_earnings_addrings_addr is the earnings address."
              },
              "operator_approve_addr": {
                "type": "string",
                "description": "operator_approve_addr is the approve address."
              },
              "operator_meta_info": {
                "type": "string",
                "description": "operator_meta_info is the operator meta info."
              },
              "cons_address": {
                "type": "string",
                "description": "ConsAddress defines a wrapper around bytes meant to present a consensus node.\nWhen marshaled to a string or JSON, it uses Bech32."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "type": "string",
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                "title": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any"
              },
              "jailed": {
                "type": "boolean",
                "title": "jailed defined whether the validator has been jailed from bonded status or not"
              },
              "status": {
                "title": "status is the validator status (bonded/unbonding/unbonded)",
                "type": "string",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ],
                "default": "BOND_STATUS_UNSPECIFIED",
                "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
              },
              "voting_power": {
                "type": "string",
                "title": "voting_power define the validator voting power"
              },
              "delegator_shares": {
                "type": "string",
                "title": "delegator_shares defines total shares issued to a validator's delegators"
              },
              "commission": {
                "description": "commission defines the commission parameters.",
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    }
                  },
                  "update_time": {
                    "type": "string",
                    "format": "date-time",
                    "description": "update_time is the last time the commission rate was changed."
                  }
                }
              },
              "delegator_tokens": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "asset_id": {
                      "type": "string",
                      "title": "asset_id is the asset for which the query is made"
                    },
                    "symbol": {
                      "type": "string",
                      "title": "symbol of the asset, like \"USDT\""
                    },
                    "name": {
                      "type": "string",
                      "title": "name of the asset, like \"Tether USD\""
                    },
                    "self_amount": {
                      "type": "string",
                      "title": "self_amount is the self amount of the asset which delegation"
                    },
                    "total_amount": {
                      "type": "string",
                      "title": "total_amount is the total amount of the asset which delegation"
                    },
                    "self_usd_value": {
                      "type": "string",
                      "title": "self_usd_value is the self delegation USD value for the validator"
                    },
                    "total_usd_value": {
                      "type": "string",
                      "title": "total_usd_value is the total delegation USD value for the validator"
                    }
                  },
                  "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
                },
                "title": "delegator_tokens is the list of asset infos"
              }
            },
            "title": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate"
          },
          "description": "validators contains all the queried validators."
        },
        "pagination": {
          "description": "pagination defines the pagination in the response.",
          "type": "object",
          "properties": {
            "next_key": {
              "type": "string",
              "format": "byte",
              "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results."
            },
            "total": {
              "type": "string",
              "format": "uint64",
              "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise"
            }
          }
        }
      },
      "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method"
    },
    "exocore.operator.v1.SlashExecutionInfo": {
      "type": "object",
      "properties": {
        "slash_proportion": {
          "type": "string",
          "title": "slash_proportion is the new calculated proportion when execute the slash"
        },
        "slash_value": {
          "type": "string",
          "title": "slash_value is the usd value of all slashed assets"
        },
        "slash_undelegations": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "staker_id": {
                "type": "string",
                "description": "staker_id is the staker id."
              },
              "asset_id": {
                "type": "string",
                "description": "asset_id is the asset id."
              },
              "amount": {
                "type": "string",
                "description": "amount is the slashed amount from the undelegation."
              }
            },
            "title": "SlashFromUndelegation records the slash detail from the undelegation"
          },
          "title": "SlashUndelegations records all slash info related to the undelegation"
        },
        "slash_assets_pool": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "asset_id": {
                "type": "string",
                "description": "asset_id is the asset id."
              },
              "amount": {
                "type": "string",
                "description": "amount is the slashed amount from the assets pool."
              }
            },
            "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
          },
          "title": "SlashFromAssetsPool records all slash info related to the assets pool"
        },
        "undelegation_filter_height": {
          "type": "string",
          "format": "int64",
          "title": "undelegation_filter_height records the height before which undelegations are not slashed"
        }
      },
      "title": "SlashExecutionInfo is the actual execution state for a slash event"
    },
    "exocore.operator.v1.SlashFromAssetsPool": {
      "type": "object",
      "properties": {
        "asset_id": {
          "type": "string",
          "description": "asset_id is the asset id."
        },
        "amount": {
          "type": "string",
          "description": "amount is the slashed amount from the assets pool."
        }
      },
      "title": "SlashFromAssetsPool records the slash detail from the operator assets pool"
    },
    "exocore.operator.v1.SlashFromUndelegation": {
      "type": "object",
      "properties": {
        "staker_id": {
          "type": "string",
          "description": "staker_id is the staker id."
        },
        "asset_id": {
          "type": "string",
          "description": "asset_id is the asset id."
        },
        "amount": {
          "type": "string",
          "description": "amount is the slashed amount from the undelegation."
        }
      },
      "title": "SlashFromUndelegation records the slash detail from the undelegation"
    },
    "exocore.operator.v1.SnapshotHelper": {
      "type": "object",
      "properties": {
        "last_changed_height": {
          "type": "string",
          "format": "int64",
          "description": "last_changed_height indicates the height of the most recent change.\nIt is used to set the `last_changed_height` field in `VotingPowerSnapshot`."
        },
        "has_opt_out": {
          "type": "boolean",
          "description": "has_opt_out is used to indicate whether there has been any opt-out operation from\nthe most recently saved snapshot to the current height. This is because,\nwhen an opt-out operation occurs, the related AVS validator information changes,\nand the snapshot needs to be updated.\nCurrently, a boolean variable is used instead of an operator list\nbecause the snapshot is set by default to store all operator information related to AVS.\nTherefore, as long as any operator has opted out, the snapshot needs to be updated.\nIf we later introduce a limit on the maximum number of validators in AVS,\nsimilar to the MaxValidatorNumber in Dogfood, this may need to be changed to an operator list\nto track all operators that have opted out, thereby assisting with the correct snapshot update."
        }
      },
      "title": "SnapshotHelper is used to record the helper information for voting power snapshot update"
    },
    "exocore.operator.v1.Validator": {
      "type": "object",
      "properties": {
        "operator_earnings_addr": {
          "type": "string",
          "description": "earnoperator_earnings_addrings_addr is the earnings address."
        },
        "operator_approve_addr": {
          "type": "string",
          "description": "operator_approve_addr is the approve address."
        },
        "operator_meta_info": {
          "type": "string",
          "description": "operator_meta_info is the operator meta info."
        },
        "cons_address": {
          "type": "string",
          "description": "ConsAddress defines a wrapper around bytes meant to present a consensus node.\nWhen marshaled to a string or JSON, it uses Bech32."
        },
        "consensus_pubkey": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
          "title": "consensus_pubkey is the consensus public key of the validator, as a Protobuf Any"
        },
        "jailed": {
          "type": "boolean",
          "title": "jailed defined whether the validator has been jailed from bonded status or not"
        },
        "status": {
          "title": "status is the validator status (bonded/unbonding/unbonded)",
          "type": "string",
          "enum": [
            "BOND_STATUS_UNSPECIFIED",
            "BOND_STATUS_UNBONDED",
            "BOND_STATUS_UNBONDING",
            "BOND_STATUS_BONDED"
          ],
          "default": "BOND_STATUS_UNSPECIFIED",
          "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."
        },
        "voting_power": {
          "type": "string",
          "title": "voting_power define the validator voting power"
        },
        "delegator_shares": {
          "type": "string",
          "title": "delegator_shares defines total shares issued to a validator's delegators"
        },
        "commission": {
          "description": "commission defines the commission parameters.",
          "type": "object",
          "properties": {
            "commission_rates": {
              "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
              "type": "object",
              "properties": {
                "rate": {
                  "type": "string",
                  "description": "rate is the commission rate charged to delegators, as a fraction."
                },
                "max_rate": {
                  "type": "string",
                  "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                },
                "max_change_rate": {
                  "type": "string",
                  "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                }
              }
            },
            "update_time": {
              "type": "string",
              "format": "date-time",
              "description": "update_time is the last time the commission rate was changed."
            }
          }
        },
        "delegator_tokens": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "asset_id": {
                "type": "string",
                "title": "asset_id is the asset for which the query is made"
              },
              "symbol": {
                "type": "string",
                "title": "symbol of the asset, like \"USDT\""
              },
              "name": {
                "type": "string",
                "title": "name of the asset, like \"Tether USD\""
              },
              "self_amount": {
                "type": "string",
                "title": "self_amount is the self amount of the asset which delegation"
              },
              "total_amount": {
                "type": "string",
                "title": "total_amount is the total amount of the asset which delegation"
              },
              "self_usd_value": {
                "type": "string",
                "title": "self_usd_value is the self delegation USD value for the validator"
              },
              "total_usd_value": {
                "type": "string",
                "title": "total_usd_value is the total delegation USD value for the validator"
              }
            },
            "title": "DelegatorInfo records the total opted-in USD value for the specified operator"
          },
          "title": "delegator_tokens is the list of asset infos"
        }
      },
      "title": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate"
    },
    "exocore.operator.v1.VotingPowerSnapshot": {
      "type": "object",
      "properties": {
        "total_voting_power": {
          "type": "string",
          "title": "total_voting_power is the total voting power of specified AVS"
        },
        "operator_voting_powers": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "operator_addr": {
                "type": "string",
                "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
              },
              "voting_power": {
                "type": "string",
                "title": "voting_power is the active voting power for the above operator address"
              }
            },
            "title": "OperatorVotingPower represents the voting power for the specified operator address"
          },
          "title": "operator_voting_powers records the active voting power of all operators\nfor the specified AVS"
        },
        "last_changed_height": {
          "type": "string",
          "format": "int64",
          "description": "last_changed_height is used to indicate the height of most recent change when\nthe operator_voting_powers is nil, which can help to fall back to the correct epoch height."
        },
        "epoch_identifier": {
          "type": "string",
          "title": "epoch_identifier record the epoch info"
        },
        "epoch_number": {
          "type": "string",
          "format": "int64",
          "title": "epoch_number indicates which epoch this snapshot serve for"
        }
      },
      "description": "VotingPowerSnapshot records historical voting power for AVSs at specific epochs\nor after slashing events.These snapshots are created at the end of each epoch and\nwhen slashing occurs, enabling historical queries of operator voting power at\nspecific points in time."
    },
    "exocore.operator.v1.VotingPowerSnapshotKeyHeight": {
      "type": "object",
      "properties": {
        "snapshot_key_height": {
          "type": "string",
          "format": "int64",
          "description": "snapshot_key_height when it is used in QuerySpecifiedSnapshot, it's the latest\nheight with a snapshot key found based on the input height; this height is typically\nthe start height of the epoch in which the input height is located.\nwhen it is used in QueryAllSnapshot, it's the height in the current snapshot key."
        },
        "snapshot": {
          "description": "snapshot when it is used in QuerySpecifiedSnapshot, it is the final retrieved information\ncontaining the voting power set.\nwhen it is used in QueryAllSnapshot, It is the snapshot stored under `snapshot_key_height`,\nand its voting power set may be nil.",
          "type": "object",
          "properties": {
            "total_voting_power": {
              "type": "string",
              "title": "total_voting_power is the total voting power of specified AVS"
            },
            "operator_voting_powers": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "operator_addr": {
                    "type": "string",
                    "title": "operator_addr is the operator address,its type should be a sdk.AccAddress"
                  },
                  "voting_power": {
                    "type": "string",
                    "title": "voting_power is the active voting power for the above operator address"
                  }
                },
                "title": "OperatorVotingPower represents the voting power for the specified operator address"
              },
              "title": "operator_voting_powers records the active voting power of all operators\nfor the specified AVS"
            },
            "last_changed_height": {
              "type": "string",
              "format": "int64",
              "description": "last_changed_height is used to indicate the height of most recent change when\nthe operator_voting_powers is nil, which can help to fall back to the correct epoch height."
            },
            "epoch_identifier": {
              "type": "string",
              "title": "epoch_identifier record the epoch info"
            },
            "epoch_number": {
              "type": "string",
              "format": "int64",
              "title": "epoch_number indicates which epoch this snapshot serve for"
            }
          }
        }
      },
      "title": "VotingPowerSnapshotKeyHeight is used in the response of QuerySpecifiedSnapshot\nand QueryAllSnapshot"
    },
    "cosmos.upgrade.v1beta1.ModuleVersion": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name of the app module"
        },
        "version": {
          "type": "string",
          "format": "uint64",
          "title": "consensus version of the app module"
        }
      },
      "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.upgrade.v1beta1.Plan": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
        },
        "time": {
          "type": "string",
          "format": "date-time",
          "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
        },
        "height": {
          "type": "string",
          "format": "int64",
          "description": "The height at which the upgrade must be performed."
        },
        "info": {
          "type": "string",
          "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
        },
        "upgraded_client_state": {
          "type": "object",
          "properties": {
            "type_url": {
              "type": "string",
              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
            },
            "value": {
              "type": "string",
              "format": "byte",
              "description": "Must be a valid serialized protocol buffer of the above specified type."
            }
          },
          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
        }
      },
      "description": "Plan specifies information about a planned upgrade and when it should occur."
    },
    "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
      "type": "object",
      "properties": {
        "height": {
          "type": "string",
          "format": "int64",
          "description": "height is the block height at which the plan was applied."
        }
      },
      "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryAuthorityResponse": {
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        }
      },
      "description": "Since: cosmos-sdk 0.46",
      "title": "QueryAuthorityResponse is the response type for Query/Authority"
    },
    "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
      "type": "object",
      "properties": {
        "plan": {
          "description": "plan is the current upgrade plan.",
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit."
            },
            "time": {
              "type": "string",
              "format": "date-time",
              "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown."
            },
            "height": {
              "type": "string",
              "format": "int64",
              "description": "The height at which the upgrade must be performed."
            },
            "info": {
              "type": "string",
              "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to"
            },
            "upgraded_client_state": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "type": "string",
                  "format": "byte",
                  "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        }
      },
      "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod."
    },
    "cosmos.upgrade.v1beta1.QueryModuleVersionsResponse": {
      "type": "object",
      "properties": {
        "module_versions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "title": "name of the app module"
              },
              "version": {
                "type": "string",
                "format": "uint64",
                "title": "consensus version of the app module"
              }
            },
            "description": "ModuleVersion specifies a module and its consensus version.\n\nSince: cosmos-sdk 0.43"
          },
          "description": "module_versions is a list of module names with their consensus versions."
        }
      },
      "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.\n\nSince: cosmos-sdk 0.43"
    },
    "cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse": {
      "type": "object",
      "properties": {
        "upgraded_consensus_state": {
          "type": "string",
          "format": "byte",
          "title": "Since: cosmos-sdk 0.43"
        }
      },
      "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method."
    },
    "ibc.applications.interchain_accounts.host.v1.Params": {
      "type": "object",
      "properties": {
        "host_enabled": {
          "type": "boolean",
          "description": "host_enabled enables or disables the host submodule."
        },
        "allow_messages": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain."
        }
      },
      "description": "Params defines the set of on-chain interchain accounts parameters.\nThe following parameters may be used to disable the host submodule."
    },
    "ibc.applications.interchain_accounts.host.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params defines the parameters of the module.",
          "type": "object",
          "properties": {
            "host_enabled": {
              "type": "boolean",
              "description": "host_enabled enables or disables the host submodule."
            },
            "allow_messages": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "allow_messages defines a list of sdk message typeURLs allowed to be executed on a host chain."
            }
          }
        }
      },
      "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
    },
    "cosmos.consensus.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params are the tendermint consensus params stored in the consensus module.\nPlease note that `params.version` is not populated in this response, it is\ntracked separately in the x/upgrade module.",
          "type": "object",
          "properties": {
            "block": {
              "type": "object",
              "properties": {
                "max_bytes": {
                  "type": "string",
                  "format": "int64",
                  "title": "Max block size, in bytes.\nNote: must be greater than 0"
                },
                "max_gas": {
                  "type": "string",
                  "format": "int64",
                  "title": "Max gas per block.\nNote: must be greater or equal to -1"
                }
              },
              "description": "BlockParams contains limits on the block size."
            },
            "evidence": {
              "type": "object",
              "properties": {
                "max_age_num_blocks": {
                  "type": "string",
                  "format": "int64",
                  "description": "Max age of evidence, in blocks.\n\nThe basic formula for calculating this is: MaxAgeDuration / {average block\ntime}."
                },
                "max_age_duration": {
                  "type": "string",
                  "description": "Max age of evidence, in time.\n\nIt should correspond with an app's \"unbonding period\" or other similar\nmechanism for handling [Nothing-At-Stake\nattacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed)."
                },
                "max_bytes": {
                  "type": "string",
                  "format": "int64",
                  "title": "This sets the maximum size of total evidence in bytes that can be committed in a single block.\nand should fall comfortably under the max block bytes.\nDefault is 1048576 or 1MB"
                }
              },
              "description": "EvidenceParams determine how we handle evidence of malfeasance."
            },
            "validator": {
              "type": "object",
              "properties": {
                "pub_key_types": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "description": "ValidatorParams restrict the public key types validators can use.\nNOTE: uses ABCI pubkey naming, not Amino names."
            },
            "version": {
              "type": "object",
              "properties": {
                "app": {
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "VersionParams contains the ABCI application version."
            }
          }
        }
      },
      "description": "QueryParamsResponse defines the response type for querying x/consensus parameters."
    },
    "tendermint.types.BlockParams": {
      "type": "object",
      "properties": {
        "max_bytes": {
          "type": "string",
          "format": "int64",
          "title": "Max block size, in bytes.\nNote: must be greater than 0"
        },
        "max_gas": {
          "type": "string",
          "format": "int64",
          "title": "Max gas per block.\nNote: must be greater or equal to -1"
        }
      },
      "description": "BlockParams contains limits on the block size."
    },
    "tendermint.types.ConsensusParams": {
      "type": "object",
      "properties": {
        "block": {
          "type": "object",
          "properties": {
            "max_bytes": {
              "type": "string",
              "format": "int64",
              "title": "Max block size, in bytes.\nNote: must be greater than 0"
            },
            "max_gas": {
              "type": "string",
              "format": "int64",
              "title": "Max gas per block.\nNote: must be greater or equal to -1"
            }
          },
          "description": "BlockParams contains limits on the block size."
        },
        "evidence": {
          "type": "object",
          "properties": {
            "max_age_num_blocks": {
              "type": "string",
              "format": "int64",
              "description": "Max age of evidence, in blocks.\n\nThe basic formula for calculating this is: MaxAgeDuration / {average block\ntime}."
            },
            "max_age_duration": {
              "type": "string",
              "description": "Max age of evidence, in time.\n\nIt should correspond with an app's \"unbonding period\" or other similar\nmechanism for handling [Nothing-At-Stake\nattacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed)."
            },
            "max_bytes": {
              "type": "string",
              "format": "int64",
              "title": "This sets the maximum size of total evidence in bytes that can be committed in a single block.\nand should fall comfortably under the max block bytes.\nDefault is 1048576 or 1MB"
            }
          },
          "description": "EvidenceParams determine how we handle evidence of malfeasance."
        },
        "validator": {
          "type": "object",
          "properties": {
            "pub_key_types": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "description": "ValidatorParams restrict the public key types validators can use.\nNOTE: uses ABCI pubkey naming, not Amino names."
        },
        "version": {
          "type": "object",
          "properties": {
            "app": {
              "type": "string",
              "format": "uint64"
            }
          },
          "description": "VersionParams contains the ABCI application version."
        }
      },
      "description": "ConsensusParams contains consensus critical parameters that determine the\nvalidity of blocks."
    },
    "tendermint.types.EvidenceParams": {
      "type": "object",
      "properties": {
        "max_age_num_blocks": {
          "type": "string",
          "format": "int64",
          "description": "Max age of evidence, in blocks.\n\nThe basic formula for calculating this is: MaxAgeDuration / {average block\ntime}."
        },
        "max_age_duration": {
          "type": "string",
          "description": "Max age of evidence, in time.\n\nIt should correspond with an app's \"unbonding period\" or other similar\nmechanism for handling [Nothing-At-Stake\nattacks](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ#what-is-the-nothing-at-stake-problem-and-how-can-it-be-fixed)."
        },
        "max_bytes": {
          "type": "string",
          "format": "int64",
          "title": "This sets the maximum size of total evidence in bytes that can be committed in a single block.\nand should fall comfortably under the max block bytes.\nDefault is 1048576 or 1MB"
        }
      },
      "description": "EvidenceParams determine how we handle evidence of malfeasance."
    },
    "tendermint.types.ValidatorParams": {
      "type": "object",
      "properties": {
        "pub_key_types": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "ValidatorParams restrict the public key types validators can use.\nNOTE: uses ABCI pubkey naming, not Amino names."
    },
    "tendermint.types.VersionParams": {
      "type": "object",
      "properties": {
        "app": {
          "type": "string",
          "format": "uint64"
        }
      },
      "description": "VersionParams contains the ABCI application version."
    },
    "exocore.reward.v1.Params": {
      "type": "object",
      "description": "Params defines the parameters for the module."
    },
    "exocore.reward.v1.QueryParamsResponse": {
      "type": "object",
      "properties": {
        "params": {
          "description": "params holds all the parameters of this module.",
          "type": "object"
        }
      },
      "description": "QueryParamsResponse is response type for the Query/Params RPC method."
    }
  }
}